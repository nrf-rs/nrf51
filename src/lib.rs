# ! [ cfg_attr ( feature = "rt" , feature ( global_asm ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( macro_reexport ) ) ] # ! [ cfg_attr ( feature = "rt" , feature ( used ) ) ] # ! [ doc = "Peripheral access API for NRF51 microcontrollers (generated using svd2rust v0.12.0)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.12.0/svd2rust/#peripheral-api" ] # ! [ allow ( private_no_mangle_statics ) ] # ! [ deny ( missing_docs ) ] # ! [ deny ( warnings ) ] # ! [ allow ( non_camel_case_types ) ] # ! [ feature ( const_fn ) ] # ! [ no_std ]extern crate cortex_m ;
#[macro_reexport(default_handler, exception)]
#[cfg(feature = "rt")]
extern crate cortex_m_rt ;
extern crate bare_metal ;
extern crate vcell ;
use core::ops::Deref;
use core::marker::PhantomData;
#[doc = r" Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
pub use interrupt::Interrupt;
#[doc(hidden)]
pub mod interrupt {
    use bare_metal::Nr;
    #[cfg(feature = "rt")]
    extern "C" {
        fn DEFAULT_HANDLER();
    }
    #[cfg(feature = "rt")]
    #[allow(non_snake_case)]
    #[no_mangle]
    pub unsafe extern "C" fn DH_TRAMPOLINE() {
        DEFAULT_HANDLER();
    }
    #[cfg(feature = "rt")]
    global_asm!(
        "\n.weak POWER_CLOCK\nPOWER_CLOCK = DH_TRAMPOLINE\n.weak RADIO\nRADIO = DH_TRAMPOLINE\n.weak UART0\nUART0 = DH_TRAMPOLINE\n.weak SPI0_TWI0\nSPI0_TWI0 = DH_TRAMPOLINE\n.weak SPI1_TWI1\nSPI1_TWI1 = DH_TRAMPOLINE\n.weak GPIOTE\nGPIOTE = DH_TRAMPOLINE\n.weak ADC\nADC = DH_TRAMPOLINE\n.weak TIMER0\nTIMER0 = DH_TRAMPOLINE\n.weak TIMER1\nTIMER1 = DH_TRAMPOLINE\n.weak TIMER2\nTIMER2 = DH_TRAMPOLINE\n.weak RTC0\nRTC0 = DH_TRAMPOLINE\n.weak TEMP\nTEMP = DH_TRAMPOLINE\n.weak RNG\nRNG = DH_TRAMPOLINE\n.weak ECB\nECB = DH_TRAMPOLINE\n.weak CCM_AAR\nCCM_AAR = DH_TRAMPOLINE\n.weak WDT\nWDT = DH_TRAMPOLINE\n.weak RTC1\nRTC1 = DH_TRAMPOLINE\n.weak QDEC\nQDEC = DH_TRAMPOLINE\n.weak LPCOMP\nLPCOMP = DH_TRAMPOLINE\n.weak SWI0\nSWI0 = DH_TRAMPOLINE\n.weak SWI1\nSWI1 = DH_TRAMPOLINE\n.weak SWI2\nSWI2 = DH_TRAMPOLINE\n.weak SWI3\nSWI3 = DH_TRAMPOLINE\n.weak SWI4\nSWI4 = DH_TRAMPOLINE\n.weak SWI5\nSWI5 = DH_TRAMPOLINE"
    );
    #[cfg(feature = "rt")]
    extern "C" {
        fn POWER_CLOCK();
        fn RADIO();
        fn UART0();
        fn SPI0_TWI0();
        fn SPI1_TWI1();
        fn GPIOTE();
        fn ADC();
        fn TIMER0();
        fn TIMER1();
        fn TIMER2();
        fn RTC0();
        fn TEMP();
        fn RNG();
        fn ECB();
        fn CCM_AAR();
        fn WDT();
        fn RTC1();
        fn QDEC();
        fn LPCOMP();
        fn SWI0();
        fn SWI1();
        fn SWI2();
        fn SWI3();
        fn SWI4();
        fn SWI5();
    }
    #[allow(private_no_mangle_statics)]
    #[cfg(feature = "rt")]
    #[doc(hidden)]
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    #[used]
    pub static INTERRUPTS: [Option<unsafe extern "C" fn()>; 26] = [
        Some(POWER_CLOCK),
        Some(RADIO),
        Some(UART0),
        Some(SPI0_TWI0),
        Some(SPI1_TWI1),
        None,
        Some(GPIOTE),
        Some(ADC),
        Some(TIMER0),
        Some(TIMER1),
        Some(TIMER2),
        Some(RTC0),
        Some(TEMP),
        Some(RNG),
        Some(ECB),
        Some(CCM_AAR),
        Some(WDT),
        Some(RTC1),
        Some(QDEC),
        Some(LPCOMP),
        Some(SWI0),
        Some(SWI1),
        Some(SWI2),
        Some(SWI3),
        Some(SWI4),
        Some(SWI5),
    ];
    #[doc = r" Enumeration of all the interrupts"]
    pub enum Interrupt {
        #[doc = "0 - POWER_CLOCK"]
        POWER_CLOCK,
        #[doc = "1 - RADIO"]
        RADIO,
        #[doc = "2 - UART0"]
        UART0,
        #[doc = "3 - SPI0_TWI0"]
        SPI0_TWI0,
        #[doc = "4 - SPI1_TWI1"]
        SPI1_TWI1,
        #[doc = "6 - GPIOTE"]
        GPIOTE,
        #[doc = "7 - ADC"]
        ADC,
        #[doc = "8 - TIMER0"]
        TIMER0,
        #[doc = "9 - TIMER1"]
        TIMER1,
        #[doc = "10 - TIMER2"]
        TIMER2,
        #[doc = "11 - RTC0"]
        RTC0,
        #[doc = "12 - TEMP"]
        TEMP,
        #[doc = "13 - RNG"]
        RNG,
        #[doc = "14 - ECB"]
        ECB,
        #[doc = "15 - CCM_AAR"]
        CCM_AAR,
        #[doc = "16 - WDT"]
        WDT,
        #[doc = "17 - RTC1"]
        RTC1,
        #[doc = "18 - QDEC"]
        QDEC,
        #[doc = "19 - LPCOMP"]
        LPCOMP,
        #[doc = "20 - SWI0"]
        SWI0,
        #[doc = "21 - SWI1"]
        SWI1,
        #[doc = "22 - SWI2"]
        SWI2,
        #[doc = "23 - SWI3"]
        SWI3,
        #[doc = "24 - SWI4"]
        SWI4,
        #[doc = "25 - SWI5"]
        SWI5,
    }
    unsafe impl Nr for Interrupt {
        #[inline]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::POWER_CLOCK => 0,
                Interrupt::RADIO => 1,
                Interrupt::UART0 => 2,
                Interrupt::SPI0_TWI0 => 3,
                Interrupt::SPI1_TWI1 => 4,
                Interrupt::GPIOTE => 6,
                Interrupt::ADC => 7,
                Interrupt::TIMER0 => 8,
                Interrupt::TIMER1 => 9,
                Interrupt::TIMER2 => 10,
                Interrupt::RTC0 => 11,
                Interrupt::TEMP => 12,
                Interrupt::RNG => 13,
                Interrupt::ECB => 14,
                Interrupt::CCM_AAR => 15,
                Interrupt::WDT => 16,
                Interrupt::RTC1 => 17,
                Interrupt::QDEC => 18,
                Interrupt::LPCOMP => 19,
                Interrupt::SWI0 => 20,
                Interrupt::SWI1 => 21,
                Interrupt::SWI2 => 22,
                Interrupt::SWI3 => 23,
                Interrupt::SWI4 => 24,
                Interrupt::SWI5 => 25,
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ty = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ] mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } }
}
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::CPUID;
pub use cortex_m::peripheral::DCB;
pub use cortex_m::peripheral::DWT;
pub use cortex_m::peripheral::MPU;
pub use cortex_m::peripheral::NVIC;
pub use cortex_m::peripheral::SCB;
pub use cortex_m::peripheral::SYST;
#[doc = "Power Control."]
pub struct POWER {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for POWER {}
impl POWER {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const power::RegisterBlock {
        0x4000_0000 as *const _
    }
}
impl Deref for POWER {
    type Target = power::RegisterBlock;
    fn deref(&self) -> &power::RegisterBlock {
        unsafe { &*POWER::ptr() }
    }
}
#[doc = "Power Control."]
pub mod power {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 120usize],
        #[doc = "0x78 - Enable constant latency mode."]
        pub tasks_constlat: TASKS_CONSTLAT,
        #[doc = "0x7c - Enable low power mode (variable latency)."]
        pub tasks_lowpwr: TASKS_LOWPWR,
        _reserved1: [u8; 136usize],
        #[doc = "0x108 - Power failure warning."]
        pub events_pofwarn: EVENTS_POFWARN,
        _reserved2: [u8; 504usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 244usize],
        #[doc = "0x400 - Reset reason."]
        pub resetreas: RESETREAS,
        _reserved4: [u8; 36usize],
        #[doc = "0x428 - Ram status register."]
        pub ramstatus: RAMSTATUS,
        _reserved5: [u8; 212usize],
        #[doc = "0x500 - System off register."]
        pub systemoff: SYSTEMOFF,
        _reserved6: [u8; 12usize],
        #[doc = "0x510 - Power failure configuration."]
        pub pofcon: POFCON,
        _reserved7: [u8; 8usize],
        #[doc = "0x51c - General purpose retention register. This register is a retained register."]
        pub gpregret: GPREGRET,
        _reserved8: [u8; 4usize],
        #[doc = "0x524 - Ram on/off."]
        pub ramon: RAMON,
        _reserved9: [u8; 28usize],
        #[doc = "0x544 - Pin reset functionality configuration register. This register is a retained register."]
        pub reset: RESET,
        _reserved10: [u8; 12usize],
        #[doc = "0x554 - Ram on/off."]
        pub ramonb: RAMONB,
        _reserved11: [u8; 32usize],
        #[doc = "0x578 - DCDC converter enable configuration register."]
        pub dcdcen: DCDCEN,
        _reserved12: [u8; 1164usize],
        #[doc = "0xa08 - DCDC power-up force register."]
        pub dcdcforce: DCDCFORCE,
    }
    #[doc = "Enable constant latency mode."]
    pub struct TASKS_CONSTLAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable constant latency mode."]
    pub mod tasks_constlat {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_CONSTLAT {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Enable low power mode (variable latency)."]
    pub struct TASKS_LOWPWR {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable low power mode (variable latency)."]
    pub mod tasks_lowpwr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_LOWPWR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Power failure warning."]
    pub struct EVENTS_POFWARN {
        register: VolatileCell<u32>,
    }
    #[doc = "Power failure warning."]
    pub mod events_pofwarn {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_POFWARN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POFWARN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POFWARNR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl POFWARNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POFWARNR::DISABLED => false,
                    POFWARNR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POFWARNR {
                match value {
                    false => POFWARNR::DISABLED,
                    true => POFWARNR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POFWARNR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POFWARNR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POFWARN`"]
        pub enum POFWARNW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl POFWARNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POFWARNW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POFWARNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POFWARNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POFWARNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(POFWARNW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Enable interrupt on POFWARN event."]
            #[inline]
            pub fn pofwarn(&self) -> POFWARNR {
                POFWARNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Enable interrupt on POFWARN event."]
            #[inline]
            pub fn pofwarn(&mut self) -> _POFWARNW {
                _POFWARNW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POFWARN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POFWARNR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl POFWARNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POFWARNR::DISABLED => false,
                    POFWARNR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POFWARNR {
                match value {
                    false => POFWARNR::DISABLED,
                    true => POFWARNR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POFWARNR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POFWARNR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POFWARN`"]
        pub enum POFWARNW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl POFWARNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POFWARNW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POFWARNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POFWARNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POFWARNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(POFWARNW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Disable interrupt on POFWARN event."]
            #[inline]
            pub fn pofwarn(&self) -> POFWARNR {
                POFWARNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Disable interrupt on POFWARN event."]
            #[inline]
            pub fn pofwarn(&mut self) -> _POFWARNW {
                _POFWARNW { w: self }
            }
        }
    }
    #[doc = "Reset reason."]
    pub struct RESETREAS {
        register: VolatileCell<u32>,
    }
    #[doc = "Reset reason."]
    pub mod resetreas {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RESETREAS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RESETPIN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESETPINR {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl RESETPINR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RESETPINR::NOTDETECTED => false,
                    RESETPINR::DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RESETPINR {
                match value {
                    false => RESETPINR::NOTDETECTED,
                    true => RESETPINR::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDETECTED`"]
            #[inline]
            pub fn is_not_detected(&self) -> bool {
                *self == RESETPINR::NOTDETECTED
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline]
            pub fn is_detected(&self) -> bool {
                *self == RESETPINR::DETECTED
            }
        }
        #[doc = "Possible values of the field `DOG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DOGR {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl DOGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DOGR::NOTDETECTED => false,
                    DOGR::DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DOGR {
                match value {
                    false => DOGR::NOTDETECTED,
                    true => DOGR::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDETECTED`"]
            #[inline]
            pub fn is_not_detected(&self) -> bool {
                *self == DOGR::NOTDETECTED
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline]
            pub fn is_detected(&self) -> bool {
                *self == DOGR::DETECTED
            }
        }
        #[doc = "Possible values of the field `SREQ`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SREQR {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl SREQR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SREQR::NOTDETECTED => false,
                    SREQR::DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SREQR {
                match value {
                    false => SREQR::NOTDETECTED,
                    true => SREQR::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDETECTED`"]
            #[inline]
            pub fn is_not_detected(&self) -> bool {
                *self == SREQR::NOTDETECTED
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline]
            pub fn is_detected(&self) -> bool {
                *self == SREQR::DETECTED
            }
        }
        #[doc = "Possible values of the field `LOCKUP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOCKUPR {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl LOCKUPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LOCKUPR::NOTDETECTED => false,
                    LOCKUPR::DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LOCKUPR {
                match value {
                    false => LOCKUPR::NOTDETECTED,
                    true => LOCKUPR::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDETECTED`"]
            #[inline]
            pub fn is_not_detected(&self) -> bool {
                *self == LOCKUPR::NOTDETECTED
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline]
            pub fn is_detected(&self) -> bool {
                *self == LOCKUPR::DETECTED
            }
        }
        #[doc = "Possible values of the field `OFF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OFFR {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl OFFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OFFR::NOTDETECTED => false,
                    OFFR::DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OFFR {
                match value {
                    false => OFFR::NOTDETECTED,
                    true => OFFR::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDETECTED`"]
            #[inline]
            pub fn is_not_detected(&self) -> bool {
                *self == OFFR::NOTDETECTED
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline]
            pub fn is_detected(&self) -> bool {
                *self == OFFR::DETECTED
            }
        }
        #[doc = "Possible values of the field `LPCOMP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LPCOMPR {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl LPCOMPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LPCOMPR::NOTDETECTED => false,
                    LPCOMPR::DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LPCOMPR {
                match value {
                    false => LPCOMPR::NOTDETECTED,
                    true => LPCOMPR::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDETECTED`"]
            #[inline]
            pub fn is_not_detected(&self) -> bool {
                *self == LPCOMPR::NOTDETECTED
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline]
            pub fn is_detected(&self) -> bool {
                *self == LPCOMPR::DETECTED
            }
        }
        #[doc = "Possible values of the field `DIF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIFR {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl DIFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DIFR::NOTDETECTED => false,
                    DIFR::DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DIFR {
                match value {
                    false => DIFR::NOTDETECTED,
                    true => DIFR::DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTDETECTED`"]
            #[inline]
            pub fn is_not_detected(&self) -> bool {
                *self == DIFR::NOTDETECTED
            }
            #[doc = "Checks if the value of the field is `DETECTED`"]
            #[inline]
            pub fn is_detected(&self) -> bool {
                *self == DIFR::DETECTED
            }
        }
        #[doc = "Values that can be written to the field `RESETPIN`"]
        pub enum RESETPINW {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl RESETPINW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RESETPINW::NOTDETECTED => false,
                    RESETPINW::DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESETPINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESETPINW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RESETPINW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset not detected."]
            #[inline]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(RESETPINW::NOTDETECTED)
            }
            #[doc = "Reset detected."]
            #[inline]
            pub fn detected(self) -> &'a mut W {
                self.variant(RESETPINW::DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DOG`"]
        pub enum DOGW {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl DOGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DOGW::NOTDETECTED => false,
                    DOGW::DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DOGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DOGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DOGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset not detected."]
            #[inline]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(DOGW::NOTDETECTED)
            }
            #[doc = "Reset detected."]
            #[inline]
            pub fn detected(self) -> &'a mut W {
                self.variant(DOGW::DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SREQ`"]
        pub enum SREQW {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl SREQW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SREQW::NOTDETECTED => false,
                    SREQW::DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SREQW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SREQW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset not detected."]
            #[inline]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(SREQW::NOTDETECTED)
            }
            #[doc = "Reset detected."]
            #[inline]
            pub fn detected(self) -> &'a mut W {
                self.variant(SREQW::DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LOCKUP`"]
        pub enum LOCKUPW {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl LOCKUPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LOCKUPW::NOTDETECTED => false,
                    LOCKUPW::DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOCKUPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOCKUPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LOCKUPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset not detected."]
            #[inline]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(LOCKUPW::NOTDETECTED)
            }
            #[doc = "Reset detected."]
            #[inline]
            pub fn detected(self) -> &'a mut W {
                self.variant(LOCKUPW::DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OFF`"]
        pub enum OFFW {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl OFFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OFFW::NOTDETECTED => false,
                    OFFW::DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OFFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset not detected."]
            #[inline]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(OFFW::NOTDETECTED)
            }
            #[doc = "Reset detected."]
            #[inline]
            pub fn detected(self) -> &'a mut W {
                self.variant(OFFW::DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LPCOMP`"]
        pub enum LPCOMPW {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl LPCOMPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LPCOMPW::NOTDETECTED => false,
                    LPCOMPW::DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LPCOMPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LPCOMPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LPCOMPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset not detected."]
            #[inline]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(LPCOMPW::NOTDETECTED)
            }
            #[doc = "Reset detected."]
            #[inline]
            pub fn detected(self) -> &'a mut W {
                self.variant(LPCOMPW::DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DIF`"]
        pub enum DIFW {
            #[doc = "Reset not detected."]
            NOTDETECTED,
            #[doc = "Reset detected."]
            DETECTED,
        }
        impl DIFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DIFW::NOTDETECTED => false,
                    DIFW::DETECTED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DIFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset not detected."]
            #[inline]
            pub fn not_detected(self) -> &'a mut W {
                self.variant(DIFW::NOTDETECTED)
            }
            #[doc = "Reset detected."]
            #[inline]
            pub fn detected(self) -> &'a mut W {
                self.variant(DIFW::DETECTED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Reset from pin-reset detected."]
            #[inline]
            pub fn resetpin(&self) -> RESETPINR {
                RESETPINR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Reset from watchdog detected."]
            #[inline]
            pub fn dog(&self) -> DOGR {
                DOGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Reset from AIRCR.SYSRESETREQ detected."]
            #[inline]
            pub fn sreq(&self) -> SREQR {
                SREQR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Reset from CPU lock-up detected."]
            #[inline]
            pub fn lockup(&self) -> LOCKUPR {
                LOCKUPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO."]
            #[inline]
            pub fn off(&self) -> OFFR {
                OFFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP."]
            #[inline]
            pub fn lpcomp(&self) -> LPCOMPR {
                LPCOMPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Reset from wake-up from OFF mode detected by entering into debug interface mode."]
            #[inline]
            pub fn dif(&self) -> DIFR {
                DIFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Reset from pin-reset detected."]
            #[inline]
            pub fn resetpin(&mut self) -> _RESETPINW {
                _RESETPINW { w: self }
            }
            #[doc = "Bit 1 - Reset from watchdog detected."]
            #[inline]
            pub fn dog(&mut self) -> _DOGW {
                _DOGW { w: self }
            }
            #[doc = "Bit 2 - Reset from AIRCR.SYSRESETREQ detected."]
            #[inline]
            pub fn sreq(&mut self) -> _SREQW {
                _SREQW { w: self }
            }
            #[doc = "Bit 3 - Reset from CPU lock-up detected."]
            #[inline]
            pub fn lockup(&mut self) -> _LOCKUPW {
                _LOCKUPW { w: self }
            }
            #[doc = "Bit 16 - Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO."]
            #[inline]
            pub fn off(&mut self) -> _OFFW {
                _OFFW { w: self }
            }
            #[doc = "Bit 17 - Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP."]
            #[inline]
            pub fn lpcomp(&mut self) -> _LPCOMPW {
                _LPCOMPW { w: self }
            }
            #[doc = "Bit 18 - Reset from wake-up from OFF mode detected by entering into debug interface mode."]
            #[inline]
            pub fn dif(&mut self) -> _DIFW {
                _DIFW { w: self }
            }
        }
    }
    #[doc = "Ram status register."]
    pub struct RAMSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Ram status register."]
    pub mod ramstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RAMSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `RAMBLOCK0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RAMBLOCK0R {
            #[doc = "RAM block 0 is off or powering up."]
            OFF,
            #[doc = "RAM block 0 is on."]
            ON,
        }
        impl RAMBLOCK0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RAMBLOCK0R::OFF => false,
                    RAMBLOCK0R::ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RAMBLOCK0R {
                match value {
                    false => RAMBLOCK0R::OFF,
                    true => RAMBLOCK0R::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == RAMBLOCK0R::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline]
            pub fn is_on(&self) -> bool {
                *self == RAMBLOCK0R::ON
            }
        }
        #[doc = "Possible values of the field `RAMBLOCK1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RAMBLOCK1R {
            #[doc = "RAM block 1 is off or powering up."]
            OFF,
            #[doc = "RAM block 1 is on."]
            ON,
        }
        impl RAMBLOCK1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RAMBLOCK1R::OFF => false,
                    RAMBLOCK1R::ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RAMBLOCK1R {
                match value {
                    false => RAMBLOCK1R::OFF,
                    true => RAMBLOCK1R::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == RAMBLOCK1R::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline]
            pub fn is_on(&self) -> bool {
                *self == RAMBLOCK1R::ON
            }
        }
        #[doc = "Possible values of the field `RAMBLOCK2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RAMBLOCK2R {
            #[doc = "RAM block 2 is off or powering up."]
            OFF,
            #[doc = "RAM block 2 is on."]
            ON,
        }
        impl RAMBLOCK2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RAMBLOCK2R::OFF => false,
                    RAMBLOCK2R::ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RAMBLOCK2R {
                match value {
                    false => RAMBLOCK2R::OFF,
                    true => RAMBLOCK2R::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == RAMBLOCK2R::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline]
            pub fn is_on(&self) -> bool {
                *self == RAMBLOCK2R::ON
            }
        }
        #[doc = "Possible values of the field `RAMBLOCK3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RAMBLOCK3R {
            #[doc = "RAM block 3 is off or powering up."]
            OFF,
            #[doc = "RAM block 3 is on."]
            ON,
        }
        impl RAMBLOCK3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RAMBLOCK3R::OFF => false,
                    RAMBLOCK3R::ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RAMBLOCK3R {
                match value {
                    false => RAMBLOCK3R::OFF,
                    true => RAMBLOCK3R::ON,
                }
            }
            #[doc = "Checks if the value of the field is `OFF`"]
            #[inline]
            pub fn is_off(&self) -> bool {
                *self == RAMBLOCK3R::OFF
            }
            #[doc = "Checks if the value of the field is `ON`"]
            #[inline]
            pub fn is_on(&self) -> bool {
                *self == RAMBLOCK3R::ON
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - RAM block 0 status."]
            #[inline]
            pub fn ramblock0(&self) -> RAMBLOCK0R {
                RAMBLOCK0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - RAM block 1 status."]
            #[inline]
            pub fn ramblock1(&self) -> RAMBLOCK1R {
                RAMBLOCK1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - RAM block 2 status."]
            #[inline]
            pub fn ramblock2(&self) -> RAMBLOCK2R {
                RAMBLOCK2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - RAM block 3 status."]
            #[inline]
            pub fn ramblock3(&self) -> RAMBLOCK3R {
                RAMBLOCK3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "System off register."]
    pub struct SYSTEMOFF {
        register: VolatileCell<u32>,
    }
    #[doc = "System off register."]
    pub mod systemoff {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSTEMOFF {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `SYSTEMOFF`"]
        pub enum SYSTEMOFFW {
            #[doc = "Enter system off mode."]
            ENTER,
        }
        impl SYSTEMOFFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSTEMOFFW::ENTER => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSTEMOFFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSTEMOFFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSTEMOFFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enter system off mode."]
            #[inline]
            pub fn enter(self) -> &'a mut W {
                self.variant(SYSTEMOFFW::ENTER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enter system off mode."]
            #[inline]
            pub fn systemoff(&mut self) -> _SYSTEMOFFW {
                _SYSTEMOFFW { w: self }
            }
        }
    }
    #[doc = "Power failure configuration."]
    pub struct POFCON {
        register: VolatileCell<u32>,
    }
    #[doc = "Power failure configuration."]
    pub mod pofcon {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POFCON {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POFR {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl POFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POFR::DISABLED => false,
                    POFR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POFR {
                match value {
                    false => POFR::DISABLED,
                    true => POFR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POFR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POFR::ENABLED
            }
        }
        #[doc = "Possible values of the field `THRESHOLD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum THRESHOLDR {
            #[doc = "Set threshold to 2.1Volts."]
            V21,
            #[doc = "Set threshold to 2.3Volts."]
            V23,
            #[doc = "Set threshold to 2.5Volts."]
            V25,
            #[doc = "Set threshold to 2.7Volts."]
            V27,
        }
        impl THRESHOLDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    THRESHOLDR::V21 => 0,
                    THRESHOLDR::V23 => 0x01,
                    THRESHOLDR::V25 => 0x02,
                    THRESHOLDR::V27 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> THRESHOLDR {
                match value {
                    0 => THRESHOLDR::V21,
                    1 => THRESHOLDR::V23,
                    2 => THRESHOLDR::V25,
                    3 => THRESHOLDR::V27,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `V21`"]
            #[inline]
            pub fn is_v21(&self) -> bool {
                *self == THRESHOLDR::V21
            }
            #[doc = "Checks if the value of the field is `V23`"]
            #[inline]
            pub fn is_v23(&self) -> bool {
                *self == THRESHOLDR::V23
            }
            #[doc = "Checks if the value of the field is `V25`"]
            #[inline]
            pub fn is_v25(&self) -> bool {
                *self == THRESHOLDR::V25
            }
            #[doc = "Checks if the value of the field is `V27`"]
            #[inline]
            pub fn is_v27(&self) -> bool {
                *self == THRESHOLDR::V27
            }
        }
        #[doc = "Values that can be written to the field `POF`"]
        pub enum POFW {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl POFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POFW::DISABLED => false,
                    POFW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POFW::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POFW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `THRESHOLD`"]
        pub enum THRESHOLDW {
            #[doc = "Set threshold to 2.1Volts."]
            V21,
            #[doc = "Set threshold to 2.3Volts."]
            V23,
            #[doc = "Set threshold to 2.5Volts."]
            V25,
            #[doc = "Set threshold to 2.7Volts."]
            V27,
        }
        impl THRESHOLDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    THRESHOLDW::V21 => 0,
                    THRESHOLDW::V23 => 1,
                    THRESHOLDW::V25 => 2,
                    THRESHOLDW::V27 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _THRESHOLDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THRESHOLDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: THRESHOLDW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Set threshold to 2.1Volts."]
            #[inline]
            pub fn v21(self) -> &'a mut W {
                self.variant(THRESHOLDW::V21)
            }
            #[doc = "Set threshold to 2.3Volts."]
            #[inline]
            pub fn v23(self) -> &'a mut W {
                self.variant(THRESHOLDW::V23)
            }
            #[doc = "Set threshold to 2.5Volts."]
            #[inline]
            pub fn v25(self) -> &'a mut W {
                self.variant(THRESHOLDW::V25)
            }
            #[doc = "Set threshold to 2.7Volts."]
            #[inline]
            pub fn v27(self) -> &'a mut W {
                self.variant(THRESHOLDW::V27)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Power failure comparator enable."]
            #[inline]
            pub fn pof(&self) -> POFR {
                POFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:2 - Set threshold level."]
            #[inline]
            pub fn threshold(&self) -> THRESHOLDR {
                THRESHOLDR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Power failure comparator enable."]
            #[inline]
            pub fn pof(&mut self) -> _POFW {
                _POFW { w: self }
            }
            #[doc = "Bits 1:2 - Set threshold level."]
            #[inline]
            pub fn threshold(&mut self) -> _THRESHOLDW {
                _THRESHOLDW { w: self }
            }
        }
    }
    #[doc = "General purpose retention register. This register is a retained register."]
    pub struct GPREGRET {
        register: VolatileCell<u32>,
    }
    #[doc = "General purpose retention register. This register is a retained register."]
    pub mod gpregret {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GPREGRET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPREGRETR {
            bits: u8,
        }
        impl GPREGRETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPREGRETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPREGRETW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - General purpose retention register."]
            #[inline]
            pub fn gpregret(&self) -> GPREGRETR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                GPREGRETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - General purpose retention register."]
            #[inline]
            pub fn gpregret(&mut self) -> _GPREGRETW {
                _GPREGRETW { w: self }
            }
        }
    }
    #[doc = "Ram on/off."]
    pub struct RAMON {
        register: VolatileCell<u32>,
    }
    #[doc = "Ram on/off."]
    pub mod ramon {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RAMON {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ONRAM0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ONRAM0R {
            #[doc = "RAM block 0 OFF in ON mode."]
            RAM0OFF,
            #[doc = "RAM block 0 ON in ON mode."]
            RAM0ON,
        }
        impl ONRAM0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ONRAM0R::RAM0OFF => false,
                    ONRAM0R::RAM0ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ONRAM0R {
                match value {
                    false => ONRAM0R::RAM0OFF,
                    true => ONRAM0R::RAM0ON,
                }
            }
            #[doc = "Checks if the value of the field is `RAM0OFF`"]
            #[inline]
            pub fn is_ram0off(&self) -> bool {
                *self == ONRAM0R::RAM0OFF
            }
            #[doc = "Checks if the value of the field is `RAM0ON`"]
            #[inline]
            pub fn is_ram0on(&self) -> bool {
                *self == ONRAM0R::RAM0ON
            }
        }
        #[doc = "Possible values of the field `ONRAM1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ONRAM1R {
            #[doc = "RAM block 1 OFF in ON mode."]
            RAM1OFF,
            #[doc = "RAM block 1 ON in ON mode."]
            RAM1ON,
        }
        impl ONRAM1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ONRAM1R::RAM1OFF => false,
                    ONRAM1R::RAM1ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ONRAM1R {
                match value {
                    false => ONRAM1R::RAM1OFF,
                    true => ONRAM1R::RAM1ON,
                }
            }
            #[doc = "Checks if the value of the field is `RAM1OFF`"]
            #[inline]
            pub fn is_ram1off(&self) -> bool {
                *self == ONRAM1R::RAM1OFF
            }
            #[doc = "Checks if the value of the field is `RAM1ON`"]
            #[inline]
            pub fn is_ram1on(&self) -> bool {
                *self == ONRAM1R::RAM1ON
            }
        }
        #[doc = "Possible values of the field `OFFRAM0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OFFRAM0R {
            #[doc = "RAM block 0 OFF in OFF mode."]
            RAM0OFF,
            #[doc = "RAM block 0 ON in OFF mode."]
            RAM0ON,
        }
        impl OFFRAM0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OFFRAM0R::RAM0OFF => false,
                    OFFRAM0R::RAM0ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OFFRAM0R {
                match value {
                    false => OFFRAM0R::RAM0OFF,
                    true => OFFRAM0R::RAM0ON,
                }
            }
            #[doc = "Checks if the value of the field is `RAM0OFF`"]
            #[inline]
            pub fn is_ram0off(&self) -> bool {
                *self == OFFRAM0R::RAM0OFF
            }
            #[doc = "Checks if the value of the field is `RAM0ON`"]
            #[inline]
            pub fn is_ram0on(&self) -> bool {
                *self == OFFRAM0R::RAM0ON
            }
        }
        #[doc = "Possible values of the field `OFFRAM1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OFFRAM1R {
            #[doc = "RAM block 1 OFF in OFF mode."]
            RAM1OFF,
            #[doc = "RAM block 1 ON in OFF mode."]
            RAM1ON,
        }
        impl OFFRAM1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OFFRAM1R::RAM1OFF => false,
                    OFFRAM1R::RAM1ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OFFRAM1R {
                match value {
                    false => OFFRAM1R::RAM1OFF,
                    true => OFFRAM1R::RAM1ON,
                }
            }
            #[doc = "Checks if the value of the field is `RAM1OFF`"]
            #[inline]
            pub fn is_ram1off(&self) -> bool {
                *self == OFFRAM1R::RAM1OFF
            }
            #[doc = "Checks if the value of the field is `RAM1ON`"]
            #[inline]
            pub fn is_ram1on(&self) -> bool {
                *self == OFFRAM1R::RAM1ON
            }
        }
        #[doc = "Values that can be written to the field `ONRAM0`"]
        pub enum ONRAM0W {
            #[doc = "RAM block 0 OFF in ON mode."]
            RAM0OFF,
            #[doc = "RAM block 0 ON in ON mode."]
            RAM0ON,
        }
        impl ONRAM0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ONRAM0W::RAM0OFF => false,
                    ONRAM0W::RAM0ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONRAM0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONRAM0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ONRAM0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RAM block 0 OFF in ON mode."]
            #[inline]
            pub fn ram0off(self) -> &'a mut W {
                self.variant(ONRAM0W::RAM0OFF)
            }
            #[doc = "RAM block 0 ON in ON mode."]
            #[inline]
            pub fn ram0on(self) -> &'a mut W {
                self.variant(ONRAM0W::RAM0ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ONRAM1`"]
        pub enum ONRAM1W {
            #[doc = "RAM block 1 OFF in ON mode."]
            RAM1OFF,
            #[doc = "RAM block 1 ON in ON mode."]
            RAM1ON,
        }
        impl ONRAM1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ONRAM1W::RAM1OFF => false,
                    ONRAM1W::RAM1ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONRAM1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONRAM1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ONRAM1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RAM block 1 OFF in ON mode."]
            #[inline]
            pub fn ram1off(self) -> &'a mut W {
                self.variant(ONRAM1W::RAM1OFF)
            }
            #[doc = "RAM block 1 ON in ON mode."]
            #[inline]
            pub fn ram1on(self) -> &'a mut W {
                self.variant(ONRAM1W::RAM1ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OFFRAM0`"]
        pub enum OFFRAM0W {
            #[doc = "RAM block 0 OFF in OFF mode."]
            RAM0OFF,
            #[doc = "RAM block 0 ON in OFF mode."]
            RAM0ON,
        }
        impl OFFRAM0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OFFRAM0W::RAM0OFF => false,
                    OFFRAM0W::RAM0ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFFRAM0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFFRAM0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OFFRAM0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RAM block 0 OFF in OFF mode."]
            #[inline]
            pub fn ram0off(self) -> &'a mut W {
                self.variant(OFFRAM0W::RAM0OFF)
            }
            #[doc = "RAM block 0 ON in OFF mode."]
            #[inline]
            pub fn ram0on(self) -> &'a mut W {
                self.variant(OFFRAM0W::RAM0ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OFFRAM1`"]
        pub enum OFFRAM1W {
            #[doc = "RAM block 1 OFF in OFF mode."]
            RAM1OFF,
            #[doc = "RAM block 1 ON in OFF mode."]
            RAM1ON,
        }
        impl OFFRAM1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OFFRAM1W::RAM1OFF => false,
                    OFFRAM1W::RAM1ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFFRAM1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFFRAM1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OFFRAM1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RAM block 1 OFF in OFF mode."]
            #[inline]
            pub fn ram1off(self) -> &'a mut W {
                self.variant(OFFRAM1W::RAM1OFF)
            }
            #[doc = "RAM block 1 ON in OFF mode."]
            #[inline]
            pub fn ram1on(self) -> &'a mut W {
                self.variant(OFFRAM1W::RAM1ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - RAM block 0 behaviour in ON mode."]
            #[inline]
            pub fn onram0(&self) -> ONRAM0R {
                ONRAM0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - RAM block 1 behaviour in ON mode."]
            #[inline]
            pub fn onram1(&self) -> ONRAM1R {
                ONRAM1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - RAM block 0 behaviour in OFF mode."]
            #[inline]
            pub fn offram0(&self) -> OFFRAM0R {
                OFFRAM0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - RAM block 1 behaviour in OFF mode."]
            #[inline]
            pub fn offram1(&self) -> OFFRAM1R {
                OFFRAM1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x03 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - RAM block 0 behaviour in ON mode."]
            #[inline]
            pub fn onram0(&mut self) -> _ONRAM0W {
                _ONRAM0W { w: self }
            }
            #[doc = "Bit 1 - RAM block 1 behaviour in ON mode."]
            #[inline]
            pub fn onram1(&mut self) -> _ONRAM1W {
                _ONRAM1W { w: self }
            }
            #[doc = "Bit 16 - RAM block 0 behaviour in OFF mode."]
            #[inline]
            pub fn offram0(&mut self) -> _OFFRAM0W {
                _OFFRAM0W { w: self }
            }
            #[doc = "Bit 17 - RAM block 1 behaviour in OFF mode."]
            #[inline]
            pub fn offram1(&mut self) -> _OFFRAM1W {
                _OFFRAM1W { w: self }
            }
        }
    }
    #[doc = "Pin reset functionality configuration register. This register is a retained register."]
    pub struct RESET {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin reset functionality configuration register. This register is a retained register."]
    pub mod reset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RESET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RESET`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESETR {
            #[doc = "Pin reset in debug interface mode disabled."]
            DISABLED,
            #[doc = "Pin reset in debug interface mode enabled."]
            ENABLED,
        }
        impl RESETR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RESETR::DISABLED => false,
                    RESETR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RESETR {
                match value {
                    false => RESETR::DISABLED,
                    true => RESETR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RESETR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RESETR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `RESET`"]
        pub enum RESETW {
            #[doc = "Pin reset in debug interface mode disabled."]
            DISABLED,
            #[doc = "Pin reset in debug interface mode enabled."]
            ENABLED,
        }
        impl RESETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RESETW::DISABLED => false,
                    RESETW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RESETW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin reset in debug interface mode disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RESETW::DISABLED)
            }
            #[doc = "Pin reset in debug interface mode enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RESETW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable or disable pin reset in debug interface mode."]
            #[inline]
            pub fn reset(&self) -> RESETR {
                RESETR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable or disable pin reset in debug interface mode."]
            #[inline]
            pub fn reset(&mut self) -> _RESETW {
                _RESETW { w: self }
            }
        }
    }
    #[doc = "Ram on/off."]
    pub struct RAMONB {
        register: VolatileCell<u32>,
    }
    #[doc = "Ram on/off."]
    pub mod ramonb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RAMONB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ONRAM2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ONRAM2R {
            #[doc = "RAM block 2 OFF in ON mode."]
            RAM2OFF,
            #[doc = "RAM block 2 ON in ON mode."]
            RAM2ON,
        }
        impl ONRAM2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ONRAM2R::RAM2OFF => false,
                    ONRAM2R::RAM2ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ONRAM2R {
                match value {
                    false => ONRAM2R::RAM2OFF,
                    true => ONRAM2R::RAM2ON,
                }
            }
            #[doc = "Checks if the value of the field is `RAM2OFF`"]
            #[inline]
            pub fn is_ram2off(&self) -> bool {
                *self == ONRAM2R::RAM2OFF
            }
            #[doc = "Checks if the value of the field is `RAM2ON`"]
            #[inline]
            pub fn is_ram2on(&self) -> bool {
                *self == ONRAM2R::RAM2ON
            }
        }
        #[doc = "Possible values of the field `ONRAM3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ONRAM3R {
            #[doc = "RAM block 33 OFF in ON mode."]
            RAM3OFF,
            #[doc = "RAM block 3 ON in ON mode."]
            RAM3ON,
        }
        impl ONRAM3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ONRAM3R::RAM3OFF => false,
                    ONRAM3R::RAM3ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ONRAM3R {
                match value {
                    false => ONRAM3R::RAM3OFF,
                    true => ONRAM3R::RAM3ON,
                }
            }
            #[doc = "Checks if the value of the field is `RAM3OFF`"]
            #[inline]
            pub fn is_ram3off(&self) -> bool {
                *self == ONRAM3R::RAM3OFF
            }
            #[doc = "Checks if the value of the field is `RAM3ON`"]
            #[inline]
            pub fn is_ram3on(&self) -> bool {
                *self == ONRAM3R::RAM3ON
            }
        }
        #[doc = "Possible values of the field `OFFRAM2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OFFRAM2R {
            #[doc = "RAM block 2 OFF in OFF mode."]
            RAM2OFF,
            #[doc = "RAM block 2 ON in OFF mode."]
            RAM2ON,
        }
        impl OFFRAM2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OFFRAM2R::RAM2OFF => false,
                    OFFRAM2R::RAM2ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OFFRAM2R {
                match value {
                    false => OFFRAM2R::RAM2OFF,
                    true => OFFRAM2R::RAM2ON,
                }
            }
            #[doc = "Checks if the value of the field is `RAM2OFF`"]
            #[inline]
            pub fn is_ram2off(&self) -> bool {
                *self == OFFRAM2R::RAM2OFF
            }
            #[doc = "Checks if the value of the field is `RAM2ON`"]
            #[inline]
            pub fn is_ram2on(&self) -> bool {
                *self == OFFRAM2R::RAM2ON
            }
        }
        #[doc = "Possible values of the field `OFFRAM3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OFFRAM3R {
            #[doc = "RAM block 3 OFF in OFF mode."]
            RAM3OFF,
            #[doc = "RAM block 3 ON in OFF mode."]
            RAM3ON,
        }
        impl OFFRAM3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OFFRAM3R::RAM3OFF => false,
                    OFFRAM3R::RAM3ON => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OFFRAM3R {
                match value {
                    false => OFFRAM3R::RAM3OFF,
                    true => OFFRAM3R::RAM3ON,
                }
            }
            #[doc = "Checks if the value of the field is `RAM3OFF`"]
            #[inline]
            pub fn is_ram3off(&self) -> bool {
                *self == OFFRAM3R::RAM3OFF
            }
            #[doc = "Checks if the value of the field is `RAM3ON`"]
            #[inline]
            pub fn is_ram3on(&self) -> bool {
                *self == OFFRAM3R::RAM3ON
            }
        }
        #[doc = "Values that can be written to the field `ONRAM2`"]
        pub enum ONRAM2W {
            #[doc = "RAM block 2 OFF in ON mode."]
            RAM2OFF,
            #[doc = "RAM block 2 ON in ON mode."]
            RAM2ON,
        }
        impl ONRAM2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ONRAM2W::RAM2OFF => false,
                    ONRAM2W::RAM2ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONRAM2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONRAM2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ONRAM2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RAM block 2 OFF in ON mode."]
            #[inline]
            pub fn ram2off(self) -> &'a mut W {
                self.variant(ONRAM2W::RAM2OFF)
            }
            #[doc = "RAM block 2 ON in ON mode."]
            #[inline]
            pub fn ram2on(self) -> &'a mut W {
                self.variant(ONRAM2W::RAM2ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ONRAM3`"]
        pub enum ONRAM3W {
            #[doc = "RAM block 33 OFF in ON mode."]
            RAM3OFF,
            #[doc = "RAM block 3 ON in ON mode."]
            RAM3ON,
        }
        impl ONRAM3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ONRAM3W::RAM3OFF => false,
                    ONRAM3W::RAM3ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ONRAM3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ONRAM3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ONRAM3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RAM block 33 OFF in ON mode."]
            #[inline]
            pub fn ram3off(self) -> &'a mut W {
                self.variant(ONRAM3W::RAM3OFF)
            }
            #[doc = "RAM block 3 ON in ON mode."]
            #[inline]
            pub fn ram3on(self) -> &'a mut W {
                self.variant(ONRAM3W::RAM3ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OFFRAM2`"]
        pub enum OFFRAM2W {
            #[doc = "RAM block 2 OFF in OFF mode."]
            RAM2OFF,
            #[doc = "RAM block 2 ON in OFF mode."]
            RAM2ON,
        }
        impl OFFRAM2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OFFRAM2W::RAM2OFF => false,
                    OFFRAM2W::RAM2ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFFRAM2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFFRAM2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OFFRAM2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RAM block 2 OFF in OFF mode."]
            #[inline]
            pub fn ram2off(self) -> &'a mut W {
                self.variant(OFFRAM2W::RAM2OFF)
            }
            #[doc = "RAM block 2 ON in OFF mode."]
            #[inline]
            pub fn ram2on(self) -> &'a mut W {
                self.variant(OFFRAM2W::RAM2ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OFFRAM3`"]
        pub enum OFFRAM3W {
            #[doc = "RAM block 3 OFF in OFF mode."]
            RAM3OFF,
            #[doc = "RAM block 3 ON in OFF mode."]
            RAM3ON,
        }
        impl OFFRAM3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OFFRAM3W::RAM3OFF => false,
                    OFFRAM3W::RAM3ON => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OFFRAM3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OFFRAM3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OFFRAM3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RAM block 3 OFF in OFF mode."]
            #[inline]
            pub fn ram3off(self) -> &'a mut W {
                self.variant(OFFRAM3W::RAM3OFF)
            }
            #[doc = "RAM block 3 ON in OFF mode."]
            #[inline]
            pub fn ram3on(self) -> &'a mut W {
                self.variant(OFFRAM3W::RAM3ON)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - RAM block 2 behaviour in ON mode."]
            #[inline]
            pub fn onram2(&self) -> ONRAM2R {
                ONRAM2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - RAM block 3 behaviour in ON mode."]
            #[inline]
            pub fn onram3(&self) -> ONRAM3R {
                ONRAM3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - RAM block 2 behaviour in OFF mode."]
            #[inline]
            pub fn offram2(&self) -> OFFRAM2R {
                OFFRAM2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - RAM block 3 behaviour in OFF mode."]
            #[inline]
            pub fn offram3(&self) -> OFFRAM3R {
                OFFRAM3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x03 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - RAM block 2 behaviour in ON mode."]
            #[inline]
            pub fn onram2(&mut self) -> _ONRAM2W {
                _ONRAM2W { w: self }
            }
            #[doc = "Bit 1 - RAM block 3 behaviour in ON mode."]
            #[inline]
            pub fn onram3(&mut self) -> _ONRAM3W {
                _ONRAM3W { w: self }
            }
            #[doc = "Bit 16 - RAM block 2 behaviour in OFF mode."]
            #[inline]
            pub fn offram2(&mut self) -> _OFFRAM2W {
                _OFFRAM2W { w: self }
            }
            #[doc = "Bit 17 - RAM block 3 behaviour in OFF mode."]
            #[inline]
            pub fn offram3(&mut self) -> _OFFRAM3W {
                _OFFRAM3W { w: self }
            }
        }
    }
    #[doc = "DCDC converter enable configuration register."]
    pub struct DCDCEN {
        register: VolatileCell<u32>,
    }
    #[doc = "DCDC converter enable configuration register."]
    pub mod dcdcen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCDCEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DCDCEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DCDCENR {
            #[doc = "DCDC converter disabled."]
            DISABLED,
            #[doc = "DCDC converter enabled."]
            ENABLED,
        }
        impl DCDCENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DCDCENR::DISABLED => false,
                    DCDCENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DCDCENR {
                match value {
                    false => DCDCENR::DISABLED,
                    true => DCDCENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DCDCENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DCDCENR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `DCDCEN`"]
        pub enum DCDCENW {
            #[doc = "DCDC converter disabled."]
            DISABLED,
            #[doc = "DCDC converter enabled."]
            ENABLED,
        }
        impl DCDCENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DCDCENW::DISABLED => false,
                    DCDCENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DCDCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DCDCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DCDCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "DCDC converter disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DCDCENW::DISABLED)
            }
            #[doc = "DCDC converter enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DCDCENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable DCDC converter."]
            #[inline]
            pub fn dcdcen(&self) -> DCDCENR {
                DCDCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable DCDC converter."]
            #[inline]
            pub fn dcdcen(&mut self) -> _DCDCENW {
                _DCDCENW { w: self }
            }
        }
    }
    #[doc = "DCDC power-up force register."]
    pub struct DCDCFORCE {
        register: VolatileCell<u32>,
    }
    #[doc = "DCDC power-up force register."]
    pub mod dcdcforce {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCDCFORCE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FORCEOFF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FORCEOFFR {
            #[doc = "No force."]
            NOFORCE,
            #[doc = "Force."]
            FORCE,
        }
        impl FORCEOFFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FORCEOFFR::NOFORCE => false,
                    FORCEOFFR::FORCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FORCEOFFR {
                match value {
                    false => FORCEOFFR::NOFORCE,
                    true => FORCEOFFR::FORCE,
                }
            }
            #[doc = "Checks if the value of the field is `NOFORCE`"]
            #[inline]
            pub fn is_no_force(&self) -> bool {
                *self == FORCEOFFR::NOFORCE
            }
            #[doc = "Checks if the value of the field is `FORCE`"]
            #[inline]
            pub fn is_force(&self) -> bool {
                *self == FORCEOFFR::FORCE
            }
        }
        #[doc = "Possible values of the field `FORCEON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FORCEONR {
            #[doc = "No force."]
            NOFORCE,
            #[doc = "Force."]
            FORCE,
        }
        impl FORCEONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FORCEONR::NOFORCE => false,
                    FORCEONR::FORCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FORCEONR {
                match value {
                    false => FORCEONR::NOFORCE,
                    true => FORCEONR::FORCE,
                }
            }
            #[doc = "Checks if the value of the field is `NOFORCE`"]
            #[inline]
            pub fn is_no_force(&self) -> bool {
                *self == FORCEONR::NOFORCE
            }
            #[doc = "Checks if the value of the field is `FORCE`"]
            #[inline]
            pub fn is_force(&self) -> bool {
                *self == FORCEONR::FORCE
            }
        }
        #[doc = "Values that can be written to the field `FORCEOFF`"]
        pub enum FORCEOFFW {
            #[doc = "No force."]
            NOFORCE,
            #[doc = "Force."]
            FORCE,
        }
        impl FORCEOFFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FORCEOFFW::NOFORCE => false,
                    FORCEOFFW::FORCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FORCEOFFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FORCEOFFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FORCEOFFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No force."]
            #[inline]
            pub fn no_force(self) -> &'a mut W {
                self.variant(FORCEOFFW::NOFORCE)
            }
            #[doc = "Force."]
            #[inline]
            pub fn force(self) -> &'a mut W {
                self.variant(FORCEOFFW::FORCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FORCEON`"]
        pub enum FORCEONW {
            #[doc = "No force."]
            NOFORCE,
            #[doc = "Force."]
            FORCE,
        }
        impl FORCEONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FORCEONW::NOFORCE => false,
                    FORCEONW::FORCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FORCEONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FORCEONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FORCEONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No force."]
            #[inline]
            pub fn no_force(self) -> &'a mut W {
                self.variant(FORCEONW::NOFORCE)
            }
            #[doc = "Force."]
            #[inline]
            pub fn force(self) -> &'a mut W {
                self.variant(FORCEONW::FORCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - DCDC power-up force off."]
            #[inline]
            pub fn forceoff(&self) -> FORCEOFFR {
                FORCEOFFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - DCDC power-up force on."]
            #[inline]
            pub fn forceon(&self) -> FORCEONR {
                FORCEONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - DCDC power-up force off."]
            #[inline]
            pub fn forceoff(&mut self) -> _FORCEOFFW {
                _FORCEOFFW { w: self }
            }
            #[doc = "Bit 1 - DCDC power-up force on."]
            #[inline]
            pub fn forceon(&mut self) -> _FORCEONW {
                _FORCEONW { w: self }
            }
        }
    }
}
#[doc = "Clock control."]
pub struct CLOCK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CLOCK {}
impl CLOCK {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const clock::RegisterBlock {
        0x4000_0000 as *const _
    }
}
impl Deref for CLOCK {
    type Target = clock::RegisterBlock;
    fn deref(&self) -> &clock::RegisterBlock {
        unsafe { &*CLOCK::ptr() }
    }
}
#[doc = "Clock control."]
pub mod clock {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start HFCLK clock source."]
        pub tasks_hfclkstart: TASKS_HFCLKSTART,
        #[doc = "0x04 - Stop HFCLK clock source."]
        pub tasks_hfclkstop: TASKS_HFCLKSTOP,
        #[doc = "0x08 - Start LFCLK clock source."]
        pub tasks_lfclkstart: TASKS_LFCLKSTART,
        #[doc = "0x0c - Stop LFCLK clock source."]
        pub tasks_lfclkstop: TASKS_LFCLKSTOP,
        #[doc = "0x10 - Start calibration of LFCLK RC oscillator."]
        pub tasks_cal: TASKS_CAL,
        #[doc = "0x14 - Start calibration timer."]
        pub tasks_ctstart: TASKS_CTSTART,
        #[doc = "0x18 - Stop calibration timer."]
        pub tasks_ctstop: TASKS_CTSTOP,
        _reserved0: [u8; 228usize],
        #[doc = "0x100 - HFCLK oscillator started."]
        pub events_hfclkstarted: EVENTS_HFCLKSTARTED,
        #[doc = "0x104 - LFCLK oscillator started."]
        pub events_lfclkstarted: EVENTS_LFCLKSTARTED,
        _reserved1: [u8; 4usize],
        #[doc = "0x10c - Calibration of LFCLK RC oscillator completed."]
        pub events_done: EVENTS_DONE,
        #[doc = "0x110 - Calibration timer timeout."]
        pub events_ctto: EVENTS_CTTO,
        _reserved2: [u8; 496usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 252usize],
        #[doc = "0x408 - Task HFCLKSTART trigger status."]
        pub hfclkrun: HFCLKRUN,
        #[doc = "0x40c - High frequency clock status."]
        pub hfclkstat: HFCLKSTAT,
        _reserved4: [u8; 4usize],
        #[doc = "0x414 - Task LFCLKSTART triggered status."]
        pub lfclkrun: LFCLKRUN,
        #[doc = "0x418 - Low frequency clock status."]
        pub lfclkstat: LFCLKSTAT,
        #[doc = "0x41c - Clock source for the LFCLK clock, set when task LKCLKSTART is triggered."]
        pub lfclksrccopy: LFCLKSRCCOPY,
        _reserved5: [u8; 248usize],
        #[doc = "0x518 - Clock source for the LFCLK clock."]
        pub lfclksrc: LFCLKSRC,
        _reserved6: [u8; 28usize],
        #[doc = "0x538 - Calibration timer interval."]
        pub ctiv: CTIV,
        _reserved7: [u8; 20usize],
        #[doc = "0x550 - Crystal frequency."]
        pub xtalfreq: XTALFREQ,
    }
    #[doc = "Start HFCLK clock source."]
    pub struct TASKS_HFCLKSTART {
        register: VolatileCell<u32>,
    }
    #[doc = "Start HFCLK clock source."]
    pub mod tasks_hfclkstart {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_HFCLKSTART {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop HFCLK clock source."]
    pub struct TASKS_HFCLKSTOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop HFCLK clock source."]
    pub mod tasks_hfclkstop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_HFCLKSTOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start LFCLK clock source."]
    pub struct TASKS_LFCLKSTART {
        register: VolatileCell<u32>,
    }
    #[doc = "Start LFCLK clock source."]
    pub mod tasks_lfclkstart {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_LFCLKSTART {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop LFCLK clock source."]
    pub struct TASKS_LFCLKSTOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop LFCLK clock source."]
    pub mod tasks_lfclkstop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_LFCLKSTOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start calibration of LFCLK RC oscillator."]
    pub struct TASKS_CAL {
        register: VolatileCell<u32>,
    }
    #[doc = "Start calibration of LFCLK RC oscillator."]
    pub mod tasks_cal {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_CAL {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start calibration timer."]
    pub struct TASKS_CTSTART {
        register: VolatileCell<u32>,
    }
    #[doc = "Start calibration timer."]
    pub mod tasks_ctstart {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_CTSTART {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop calibration timer."]
    pub struct TASKS_CTSTOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop calibration timer."]
    pub mod tasks_ctstop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_CTSTOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "HFCLK oscillator started."]
    pub struct EVENTS_HFCLKSTARTED {
        register: VolatileCell<u32>,
    }
    #[doc = "HFCLK oscillator started."]
    pub mod events_hfclkstarted {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_HFCLKSTARTED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "LFCLK oscillator started."]
    pub struct EVENTS_LFCLKSTARTED {
        register: VolatileCell<u32>,
    }
    #[doc = "LFCLK oscillator started."]
    pub mod events_lfclkstarted {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_LFCLKSTARTED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Calibration of LFCLK RC oscillator completed."]
    pub struct EVENTS_DONE {
        register: VolatileCell<u32>,
    }
    #[doc = "Calibration of LFCLK RC oscillator completed."]
    pub mod events_done {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_DONE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Calibration timer timeout."]
    pub struct EVENTS_CTTO {
        register: VolatileCell<u32>,
    }
    #[doc = "Calibration timer timeout."]
    pub mod events_ctto {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_CTTO {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `HFCLKSTARTED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HFCLKSTARTEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl HFCLKSTARTEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HFCLKSTARTEDR::DISABLED => false,
                    HFCLKSTARTEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HFCLKSTARTEDR {
                match value {
                    false => HFCLKSTARTEDR::DISABLED,
                    true => HFCLKSTARTEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == HFCLKSTARTEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == HFCLKSTARTEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `LFCLKSTARTED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LFCLKSTARTEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl LFCLKSTARTEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LFCLKSTARTEDR::DISABLED => false,
                    LFCLKSTARTEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LFCLKSTARTEDR {
                match value {
                    false => LFCLKSTARTEDR::DISABLED,
                    true => LFCLKSTARTEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == LFCLKSTARTEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == LFCLKSTARTEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DONE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DONER {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DONER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DONER::DISABLED => false,
                    DONER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DONER {
                match value {
                    false => DONER::DISABLED,
                    true => DONER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DONER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DONER::ENABLED
            }
        }
        #[doc = "Possible values of the field `CTTO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTTOR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl CTTOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CTTOR::DISABLED => false,
                    CTTOR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CTTOR {
                match value {
                    false => CTTOR::DISABLED,
                    true => CTTOR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CTTOR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CTTOR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `HFCLKSTARTED`"]
        pub enum HFCLKSTARTEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl HFCLKSTARTEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HFCLKSTARTEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HFCLKSTARTEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HFCLKSTARTEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HFCLKSTARTEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(HFCLKSTARTEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LFCLKSTARTED`"]
        pub enum LFCLKSTARTEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl LFCLKSTARTEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LFCLKSTARTEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LFCLKSTARTEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LFCLKSTARTEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LFCLKSTARTEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(LFCLKSTARTEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DONE`"]
        pub enum DONEW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl DONEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DONEW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DONEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DONEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(DONEW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTTO`"]
        pub enum CTTOW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl CTTOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTTOW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTTOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTTOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTTOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CTTOW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on HFCLKSTARTED event."]
            #[inline]
            pub fn hfclkstarted(&self) -> HFCLKSTARTEDR {
                HFCLKSTARTEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on LFCLKSTARTED event."]
            #[inline]
            pub fn lfclkstarted(&self) -> LFCLKSTARTEDR {
                LFCLKSTARTEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable interrupt on DONE event."]
            #[inline]
            pub fn done(&self) -> DONER {
                DONER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enable interrupt on CTTO event."]
            #[inline]
            pub fn ctto(&self) -> CTTOR {
                CTTOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on HFCLKSTARTED event."]
            #[inline]
            pub fn hfclkstarted(&mut self) -> _HFCLKSTARTEDW {
                _HFCLKSTARTEDW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on LFCLKSTARTED event."]
            #[inline]
            pub fn lfclkstarted(&mut self) -> _LFCLKSTARTEDW {
                _LFCLKSTARTEDW { w: self }
            }
            #[doc = "Bit 3 - Enable interrupt on DONE event."]
            #[inline]
            pub fn done(&mut self) -> _DONEW {
                _DONEW { w: self }
            }
            #[doc = "Bit 4 - Enable interrupt on CTTO event."]
            #[inline]
            pub fn ctto(&mut self) -> _CTTOW {
                _CTTOW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `HFCLKSTARTED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HFCLKSTARTEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl HFCLKSTARTEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HFCLKSTARTEDR::DISABLED => false,
                    HFCLKSTARTEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HFCLKSTARTEDR {
                match value {
                    false => HFCLKSTARTEDR::DISABLED,
                    true => HFCLKSTARTEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == HFCLKSTARTEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == HFCLKSTARTEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `LFCLKSTARTED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LFCLKSTARTEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl LFCLKSTARTEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LFCLKSTARTEDR::DISABLED => false,
                    LFCLKSTARTEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LFCLKSTARTEDR {
                match value {
                    false => LFCLKSTARTEDR::DISABLED,
                    true => LFCLKSTARTEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == LFCLKSTARTEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == LFCLKSTARTEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DONE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DONER {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DONER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DONER::DISABLED => false,
                    DONER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DONER {
                match value {
                    false => DONER::DISABLED,
                    true => DONER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DONER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DONER::ENABLED
            }
        }
        #[doc = "Possible values of the field `CTTO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTTOR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl CTTOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CTTOR::DISABLED => false,
                    CTTOR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CTTOR {
                match value {
                    false => CTTOR::DISABLED,
                    true => CTTOR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CTTOR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CTTOR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `HFCLKSTARTED`"]
        pub enum HFCLKSTARTEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl HFCLKSTARTEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HFCLKSTARTEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HFCLKSTARTEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HFCLKSTARTEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HFCLKSTARTEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(HFCLKSTARTEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `LFCLKSTARTED`"]
        pub enum LFCLKSTARTEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl LFCLKSTARTEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LFCLKSTARTEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LFCLKSTARTEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LFCLKSTARTEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LFCLKSTARTEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(LFCLKSTARTEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DONE`"]
        pub enum DONEW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl DONEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DONEW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DONEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DONEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(DONEW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTTO`"]
        pub enum CTTOW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl CTTOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTTOW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTTOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTTOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTTOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTTOW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on HFCLKSTARTED event."]
            #[inline]
            pub fn hfclkstarted(&self) -> HFCLKSTARTEDR {
                HFCLKSTARTEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on LFCLKSTARTED event."]
            #[inline]
            pub fn lfclkstarted(&self) -> LFCLKSTARTEDR {
                LFCLKSTARTEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Disable interrupt on DONE event."]
            #[inline]
            pub fn done(&self) -> DONER {
                DONER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Disable interrupt on CTTO event."]
            #[inline]
            pub fn ctto(&self) -> CTTOR {
                CTTOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on HFCLKSTARTED event."]
            #[inline]
            pub fn hfclkstarted(&mut self) -> _HFCLKSTARTEDW {
                _HFCLKSTARTEDW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on LFCLKSTARTED event."]
            #[inline]
            pub fn lfclkstarted(&mut self) -> _LFCLKSTARTEDW {
                _LFCLKSTARTEDW { w: self }
            }
            #[doc = "Bit 3 - Disable interrupt on DONE event."]
            #[inline]
            pub fn done(&mut self) -> _DONEW {
                _DONEW { w: self }
            }
            #[doc = "Bit 4 - Disable interrupt on CTTO event."]
            #[inline]
            pub fn ctto(&mut self) -> _CTTOW {
                _CTTOW { w: self }
            }
        }
    }
    #[doc = "Task HFCLKSTART trigger status."]
    pub struct HFCLKRUN {
        register: VolatileCell<u32>,
    }
    #[doc = "Task HFCLKSTART trigger status."]
    pub mod hfclkrun {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::HFCLKRUN {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `STATUS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATUSR {
            #[doc = "Task HFCLKSTART has not been triggered."]
            NOTTRIGGERED,
            #[doc = "Task HFCLKSTART has been triggered."]
            TRIGGERED,
        }
        impl STATUSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STATUSR::NOTTRIGGERED => false,
                    STATUSR::TRIGGERED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STATUSR {
                match value {
                    false => STATUSR::NOTTRIGGERED,
                    true => STATUSR::TRIGGERED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTTRIGGERED`"]
            #[inline]
            pub fn is_not_triggered(&self) -> bool {
                *self == STATUSR::NOTTRIGGERED
            }
            #[doc = "Checks if the value of the field is `TRIGGERED`"]
            #[inline]
            pub fn is_triggered(&self) -> bool {
                *self == STATUSR::TRIGGERED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Task HFCLKSTART trigger status."]
            #[inline]
            pub fn status(&self) -> STATUSR {
                STATUSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "High frequency clock status."]
    pub struct HFCLKSTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "High frequency clock status."]
    pub mod hfclkstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::HFCLKSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `SRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCR {
            #[doc = "Internal 16MHz RC oscillator running and generating the HFCLK clock."]
            RC,
            #[doc = "External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock."]
            XTAL,
        }
        impl SRCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SRCR::RC => false,
                    SRCR::XTAL => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SRCR {
                match value {
                    false => SRCR::RC,
                    true => SRCR::XTAL,
                }
            }
            #[doc = "Checks if the value of the field is `RC`"]
            #[inline]
            pub fn is_rc(&self) -> bool {
                *self == SRCR::RC
            }
            #[doc = "Checks if the value of the field is `XTAL`"]
            #[inline]
            pub fn is_xtal(&self) -> bool {
                *self == SRCR::XTAL
            }
        }
        #[doc = "Possible values of the field `STATE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATER {
            #[doc = "HFCLK clock not running."]
            NOTRUNNING,
            #[doc = "HFCLK clock running."]
            RUNNING,
        }
        impl STATER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STATER::NOTRUNNING => false,
                    STATER::RUNNING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STATER {
                match value {
                    false => STATER::NOTRUNNING,
                    true => STATER::RUNNING,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRUNNING`"]
            #[inline]
            pub fn is_not_running(&self) -> bool {
                *self == STATER::NOTRUNNING
            }
            #[doc = "Checks if the value of the field is `RUNNING`"]
            #[inline]
            pub fn is_running(&self) -> bool {
                *self == STATER::RUNNING
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Active clock source for the HF clock."]
            #[inline]
            pub fn src(&self) -> SRCR {
                SRCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - State for the HFCLK."]
            #[inline]
            pub fn state(&self) -> STATER {
                STATER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Task LFCLKSTART triggered status."]
    pub struct LFCLKRUN {
        register: VolatileCell<u32>,
    }
    #[doc = "Task LFCLKSTART triggered status."]
    pub mod lfclkrun {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::LFCLKRUN {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `STATUS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATUSR {
            #[doc = "Task LFCLKSTART has not been triggered."]
            NOTTRIGGERED,
            #[doc = "Task LFCLKSTART has been triggered."]
            TRIGGERED,
        }
        impl STATUSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STATUSR::NOTTRIGGERED => false,
                    STATUSR::TRIGGERED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STATUSR {
                match value {
                    false => STATUSR::NOTTRIGGERED,
                    true => STATUSR::TRIGGERED,
                }
            }
            #[doc = "Checks if the value of the field is `NOTTRIGGERED`"]
            #[inline]
            pub fn is_not_triggered(&self) -> bool {
                *self == STATUSR::NOTTRIGGERED
            }
            #[doc = "Checks if the value of the field is `TRIGGERED`"]
            #[inline]
            pub fn is_triggered(&self) -> bool {
                *self == STATUSR::TRIGGERED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Task LFCLKSTART triggered status."]
            #[inline]
            pub fn status(&self) -> STATUSR {
                STATUSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Low frequency clock status."]
    pub struct LFCLKSTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Low frequency clock status."]
    pub mod lfclkstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::LFCLKSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `SRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCR {
            #[doc = "Internal 32KiHz RC oscillator running and generating the LFCLK clock."]
            RC,
            #[doc = "External 32KiHz crystal oscillator running and generating the LFCLK clock."]
            XTAL,
            #[doc = "Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock."]
            SYNTH,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRCR::RC => 0,
                    SRCR::XTAL => 0x01,
                    SRCR::SYNTH => 0x02,
                    SRCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRCR {
                match value {
                    0 => SRCR::RC,
                    1 => SRCR::XTAL,
                    2 => SRCR::SYNTH,
                    i => SRCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RC`"]
            #[inline]
            pub fn is_rc(&self) -> bool {
                *self == SRCR::RC
            }
            #[doc = "Checks if the value of the field is `XTAL`"]
            #[inline]
            pub fn is_xtal(&self) -> bool {
                *self == SRCR::XTAL
            }
            #[doc = "Checks if the value of the field is `SYNTH`"]
            #[inline]
            pub fn is_synth(&self) -> bool {
                *self == SRCR::SYNTH
            }
        }
        #[doc = "Possible values of the field `STATE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATER {
            #[doc = "LFCLK clock not running."]
            NOTRUNNING,
            #[doc = "LFCLK clock running."]
            RUNNING,
        }
        impl STATER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STATER::NOTRUNNING => false,
                    STATER::RUNNING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STATER {
                match value {
                    false => STATER::NOTRUNNING,
                    true => STATER::RUNNING,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRUNNING`"]
            #[inline]
            pub fn is_not_running(&self) -> bool {
                *self == STATER::NOTRUNNING
            }
            #[doc = "Checks if the value of the field is `RUNNING`"]
            #[inline]
            pub fn is_running(&self) -> bool {
                *self == STATER::RUNNING
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Active clock source for the LF clock."]
            #[inline]
            pub fn src(&self) -> SRCR {
                SRCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 16 - State for the LF clock."]
            #[inline]
            pub fn state(&self) -> STATER {
                STATER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Clock source for the LFCLK clock, set when task LKCLKSTART is triggered."]
    pub struct LFCLKSRCCOPY {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock source for the LFCLK clock, set when task LKCLKSTART is triggered."]
    pub mod lfclksrccopy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::LFCLKSRCCOPY {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `SRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCR {
            #[doc = "Internal 32KiHz RC oscillator."]
            RC,
            #[doc = "External 32KiHz crystal."]
            XTAL,
            #[doc = "Internal 32KiHz synthesizer from HFCLK system clock."]
            SYNTH,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRCR::RC => 0,
                    SRCR::XTAL => 0x01,
                    SRCR::SYNTH => 0x02,
                    SRCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRCR {
                match value {
                    0 => SRCR::RC,
                    1 => SRCR::XTAL,
                    2 => SRCR::SYNTH,
                    i => SRCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RC`"]
            #[inline]
            pub fn is_rc(&self) -> bool {
                *self == SRCR::RC
            }
            #[doc = "Checks if the value of the field is `XTAL`"]
            #[inline]
            pub fn is_xtal(&self) -> bool {
                *self == SRCR::XTAL
            }
            #[doc = "Checks if the value of the field is `SYNTH`"]
            #[inline]
            pub fn is_synth(&self) -> bool {
                *self == SRCR::SYNTH
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Clock source for the LFCLK clock, set when task LKCLKSTART is triggered."]
            #[inline]
            pub fn src(&self) -> SRCR {
                SRCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
    }
    #[doc = "Clock source for the LFCLK clock."]
    pub struct LFCLKSRC {
        register: VolatileCell<u32>,
    }
    #[doc = "Clock source for the LFCLK clock."]
    pub mod lfclksrc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LFCLKSRC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SRC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SRCR {
            #[doc = "Internal 32KiHz RC oscillator."]
            RC,
            #[doc = "External 32KiHz crystal."]
            XTAL,
            #[doc = "Internal 32KiHz synthesizer from HFCLK system clock."]
            SYNTH,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SRCR::RC => 0,
                    SRCR::XTAL => 0x01,
                    SRCR::SYNTH => 0x02,
                    SRCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SRCR {
                match value {
                    0 => SRCR::RC,
                    1 => SRCR::XTAL,
                    2 => SRCR::SYNTH,
                    i => SRCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RC`"]
            #[inline]
            pub fn is_rc(&self) -> bool {
                *self == SRCR::RC
            }
            #[doc = "Checks if the value of the field is `XTAL`"]
            #[inline]
            pub fn is_xtal(&self) -> bool {
                *self == SRCR::XTAL
            }
            #[doc = "Checks if the value of the field is `SYNTH`"]
            #[inline]
            pub fn is_synth(&self) -> bool {
                *self == SRCR::SYNTH
            }
        }
        #[doc = "Values that can be written to the field `SRC`"]
        pub enum SRCW {
            #[doc = "Internal 32KiHz RC oscillator."]
            RC,
            #[doc = "External 32KiHz crystal."]
            XTAL,
            #[doc = "Internal 32KiHz synthesizer from HFCLK system clock."]
            SYNTH,
        }
        impl SRCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SRCW::RC => 0,
                    SRCW::XTAL => 1,
                    SRCW::SYNTH => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SRCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SRCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SRCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Internal 32KiHz RC oscillator."]
            #[inline]
            pub fn rc(self) -> &'a mut W {
                self.variant(SRCW::RC)
            }
            #[doc = "External 32KiHz crystal."]
            #[inline]
            pub fn xtal(self) -> &'a mut W {
                self.variant(SRCW::XTAL)
            }
            #[doc = "Internal 32KiHz synthesizer from HFCLK system clock."]
            #[inline]
            pub fn synth(self) -> &'a mut W {
                self.variant(SRCW::SYNTH)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Clock source."]
            #[inline]
            pub fn src(&self) -> SRCR {
                SRCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Clock source."]
            #[inline]
            pub fn src(&mut self) -> _SRCW {
                _SRCW { w: self }
            }
        }
    }
    #[doc = "Calibration timer interval."]
    pub struct CTIV {
        register: VolatileCell<u32>,
    }
    #[doc = "Calibration timer interval."]
    pub mod ctiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTIVR {
            bits: u8,
        }
        impl CTIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - Calibration timer interval in 0.25s resolution."]
            #[inline]
            pub fn ctiv(&self) -> CTIVR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CTIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - Calibration timer interval in 0.25s resolution."]
            #[inline]
            pub fn ctiv(&mut self) -> _CTIVW {
                _CTIVW { w: self }
            }
        }
    }
    #[doc = "Crystal frequency."]
    pub struct XTALFREQ {
        register: VolatileCell<u32>,
    }
    #[doc = "Crystal frequency."]
    pub mod xtalfreq {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XTALFREQ {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `XTALFREQ`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XTALFREQR {
            #[doc = "16MHz xtal is used as source for the HFCLK oscillator."]
            _16MHZ,
            #[doc = "32MHz xtal is used as source for the HFCLK oscillator."]
            _32MHZ,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl XTALFREQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    XTALFREQR::_16MHZ => 0xff,
                    XTALFREQR::_32MHZ => 0,
                    XTALFREQR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> XTALFREQR {
                match value {
                    255 => XTALFREQR::_16MHZ,
                    0 => XTALFREQR::_32MHZ,
                    i => XTALFREQR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_16MHZ`"]
            #[inline]
            pub fn is_16mhz(&self) -> bool {
                *self == XTALFREQR::_16MHZ
            }
            #[doc = "Checks if the value of the field is `_32MHZ`"]
            #[inline]
            pub fn is_32mhz(&self) -> bool {
                *self == XTALFREQR::_32MHZ
            }
        }
        #[doc = "Values that can be written to the field `XTALFREQ`"]
        pub enum XTALFREQW {
            #[doc = "16MHz xtal is used as source for the HFCLK oscillator."]
            _16MHZ,
            #[doc = "32MHz xtal is used as source for the HFCLK oscillator."]
            _32MHZ,
        }
        impl XTALFREQW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    XTALFREQW::_16MHZ => 255,
                    XTALFREQW::_32MHZ => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALFREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALFREQW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: XTALFREQW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "16MHz xtal is used as source for the HFCLK oscillator."]
            #[inline]
            pub fn _16mhz(self) -> &'a mut W {
                self.variant(XTALFREQW::_16MHZ)
            }
            #[doc = "32MHz xtal is used as source for the HFCLK oscillator."]
            #[inline]
            pub fn _32mhz(self) -> &'a mut W {
                self.variant(XTALFREQW::_32MHZ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - External Xtal frequency selection."]
            #[inline]
            pub fn xtalfreq(&self) -> XTALFREQR {
                XTALFREQR::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - External Xtal frequency selection."]
            #[inline]
            pub fn xtalfreq(&mut self) -> _XTALFREQW {
                _XTALFREQW { w: self }
            }
        }
    }
}
#[doc = "The radio."]
pub struct RADIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RADIO {}
impl RADIO {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const radio::RegisterBlock {
        0x4000_1000 as *const _
    }
}
impl Deref for RADIO {
    type Target = radio::RegisterBlock;
    fn deref(&self) -> &radio::RegisterBlock {
        unsafe { &*RADIO::ptr() }
    }
}
#[doc = "The radio."]
pub mod radio {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Enable radio in TX mode."]
        pub tasks_txen: TASKS_TXEN,
        #[doc = "0x04 - Enable radio in RX mode."]
        pub tasks_rxen: TASKS_RXEN,
        #[doc = "0x08 - Start radio."]
        pub tasks_start: TASKS_START,
        #[doc = "0x0c - Stop radio."]
        pub tasks_stop: TASKS_STOP,
        #[doc = "0x10 - Disable radio."]
        pub tasks_disable: TASKS_DISABLE,
        #[doc = "0x14 - Start the RSSI and take one sample of the receive signal strength."]
        pub tasks_rssistart: TASKS_RSSISTART,
        #[doc = "0x18 - Stop the RSSI measurement."]
        pub tasks_rssistop: TASKS_RSSISTOP,
        #[doc = "0x1c - Start the bit counter."]
        pub tasks_bcstart: TASKS_BCSTART,
        #[doc = "0x20 - Stop the bit counter."]
        pub tasks_bcstop: TASKS_BCSTOP,
        _reserved0: [u8; 220usize],
        #[doc = "0x100 - Ready event."]
        pub events_ready: EVENTS_READY,
        #[doc = "0x104 - Address event."]
        pub events_address: EVENTS_ADDRESS,
        #[doc = "0x108 - Payload event."]
        pub events_payload: EVENTS_PAYLOAD,
        #[doc = "0x10c - End event."]
        pub events_end: EVENTS_END,
        #[doc = "0x110 - Disable event."]
        pub events_disabled: EVENTS_DISABLED,
        #[doc = "0x114 - A device address match occurred on the last received packet."]
        pub events_devmatch: EVENTS_DEVMATCH,
        #[doc = "0x118 - No device address match occurred on the last received packet."]
        pub events_devmiss: EVENTS_DEVMISS,
        #[doc = "0x11c - Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register."]
        pub events_rssiend: EVENTS_RSSIEND,
        _reserved1: [u8; 8usize],
        #[doc = "0x128 - Bit counter reached bit count value specified in BCC register."]
        pub events_bcmatch: EVENTS_BCMATCH,
        _reserved2: [u8; 212usize],
        #[doc = "0x200 - Shortcuts for the radio."]
        pub shorts: SHORTS,
        _reserved3: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved4: [u8; 244usize],
        #[doc = "0x400 - CRC status of received packet."]
        pub crcstatus: CRCSTATUS,
        _reserved5: [u8; 4usize],
        #[doc = "0x408 - Received address."]
        pub rxmatch: RXMATCH,
        #[doc = "0x40c - Received CRC."]
        pub rxcrc: RXCRC,
        #[doc = "0x410 - Device address match index."]
        pub dai: DAI,
        _reserved6: [u8; 240usize],
        #[doc = "0x504 - Packet pointer. Decision point: START task."]
        pub packetptr: PACKETPTR,
        #[doc = "0x508 - Frequency."]
        pub frequency: FREQUENCY,
        #[doc = "0x50c - Output power."]
        pub txpower: TXPOWER,
        #[doc = "0x510 - Data rate and modulation."]
        pub mode: MODE,
        #[doc = "0x514 - Packet configuration 0."]
        pub pcnf0: PCNF0,
        #[doc = "0x518 - Packet configuration 1."]
        pub pcnf1: PCNF1,
        #[doc = "0x51c - Radio base address 0. Decision point: START task."]
        pub base0: BASE0,
        #[doc = "0x520 - Radio base address 1. Decision point: START task."]
        pub base1: BASE1,
        #[doc = "0x524 - Prefixes bytes for logical addresses 0 to 3."]
        pub prefix0: PREFIX0,
        #[doc = "0x528 - Prefixes bytes for logical addresses 4 to 7."]
        pub prefix1: PREFIX1,
        #[doc = "0x52c - Transmit address select."]
        pub txaddress: TXADDRESS,
        #[doc = "0x530 - Receive address select."]
        pub rxaddresses: RXADDRESSES,
        #[doc = "0x534 - CRC configuration."]
        pub crccnf: CRCCNF,
        #[doc = "0x538 - CRC polynomial."]
        pub crcpoly: CRCPOLY,
        #[doc = "0x53c - CRC initial value."]
        pub crcinit: CRCINIT,
        #[doc = "0x540 - Test features enable register."]
        pub test: TEST,
        #[doc = "0x544 - Inter Frame Spacing in microseconds."]
        pub tifs: TIFS,
        #[doc = "0x548 - RSSI sample."]
        pub rssisample: RSSISAMPLE,
        _reserved7: [u8; 4usize],
        #[doc = "0x550 - Current radio state."]
        pub state: STATE,
        #[doc = "0x554 - Data whitening initial value."]
        pub datawhiteiv: DATAWHITEIV,
        _reserved8: [u8; 8usize],
        #[doc = "0x560 - Bit counter compare."]
        pub bcc: BCC,
        _reserved9: [u8; 156usize],
        #[doc = "0x600 - Device address base segment."]
        pub dab: [DAB; 8],
        #[doc = "0x620 - Device address prefix."]
        pub dap: [DAP; 8],
        #[doc = "0x640 - Device address match configuration."]
        pub dacnf: DACNF,
        _reserved10: [u8; 224usize],
        #[doc = "0x724 - Trim value override register 0."]
        pub override0: OVERRIDE0,
        #[doc = "0x728 - Trim value override register 1."]
        pub override1: OVERRIDE1,
        #[doc = "0x72c - Trim value override register 2."]
        pub override2: OVERRIDE2,
        #[doc = "0x730 - Trim value override register 3."]
        pub override3: OVERRIDE3,
        #[doc = "0x734 - Trim value override register 4."]
        pub override4: OVERRIDE4,
        _reserved11: [u8; 2244usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Enable radio in TX mode."]
    pub struct TASKS_TXEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable radio in TX mode."]
    pub mod tasks_txen {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_TXEN {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Enable radio in RX mode."]
    pub struct TASKS_RXEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable radio in RX mode."]
    pub mod tasks_rxen {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_RXEN {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start radio."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start radio."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop radio."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop radio."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Disable radio."]
    pub struct TASKS_DISABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Disable radio."]
    pub mod tasks_disable {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_DISABLE {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start the RSSI and take one sample of the receive signal strength."]
    pub struct TASKS_RSSISTART {
        register: VolatileCell<u32>,
    }
    #[doc = "Start the RSSI and take one sample of the receive signal strength."]
    pub mod tasks_rssistart {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_RSSISTART {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop the RSSI measurement."]
    pub struct TASKS_RSSISTOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop the RSSI measurement."]
    pub mod tasks_rssistop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_RSSISTOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start the bit counter."]
    pub struct TASKS_BCSTART {
        register: VolatileCell<u32>,
    }
    #[doc = "Start the bit counter."]
    pub mod tasks_bcstart {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_BCSTART {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop the bit counter."]
    pub struct TASKS_BCSTOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop the bit counter."]
    pub mod tasks_bcstop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_BCSTOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Ready event."]
    pub struct EVENTS_READY {
        register: VolatileCell<u32>,
    }
    #[doc = "Ready event."]
    pub mod events_ready {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_READY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Address event."]
    pub struct EVENTS_ADDRESS {
        register: VolatileCell<u32>,
    }
    #[doc = "Address event."]
    pub mod events_address {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ADDRESS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Payload event."]
    pub struct EVENTS_PAYLOAD {
        register: VolatileCell<u32>,
    }
    #[doc = "Payload event."]
    pub mod events_payload {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_PAYLOAD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "End event."]
    pub struct EVENTS_END {
        register: VolatileCell<u32>,
    }
    #[doc = "End event."]
    pub mod events_end {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_END {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Disable event."]
    pub struct EVENTS_DISABLED {
        register: VolatileCell<u32>,
    }
    #[doc = "Disable event."]
    pub mod events_disabled {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_DISABLED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "A device address match occurred on the last received packet."]
    pub struct EVENTS_DEVMATCH {
        register: VolatileCell<u32>,
    }
    #[doc = "A device address match occurred on the last received packet."]
    pub mod events_devmatch {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_DEVMATCH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "No device address match occurred on the last received packet."]
    pub struct EVENTS_DEVMISS {
        register: VolatileCell<u32>,
    }
    #[doc = "No device address match occurred on the last received packet."]
    pub mod events_devmiss {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_DEVMISS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register."]
    pub struct EVENTS_RSSIEND {
        register: VolatileCell<u32>,
    }
    #[doc = "Sampling of the receive signal strength complete. A new RSSI sample is ready for readout at the RSSISAMPLE register."]
    pub mod events_rssiend {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_RSSIEND {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Bit counter reached bit count value specified in BCC register."]
    pub struct EVENTS_BCMATCH {
        register: VolatileCell<u32>,
    }
    #[doc = "Bit counter reached bit count value specified in BCC register."]
    pub mod events_bcmatch {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_BCMATCH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for the radio."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for the radio."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `READY_START`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READY_STARTR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl READY_STARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READY_STARTR::DISABLED => false,
                    READY_STARTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READY_STARTR {
                match value {
                    false => READY_STARTR::DISABLED,
                    true => READY_STARTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READY_STARTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READY_STARTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `END_DISABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum END_DISABLER {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl END_DISABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    END_DISABLER::DISABLED => false,
                    END_DISABLER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> END_DISABLER {
                match value {
                    false => END_DISABLER::DISABLED,
                    true => END_DISABLER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == END_DISABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == END_DISABLER::ENABLED
            }
        }
        #[doc = "Possible values of the field `DISABLED_TXEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISABLED_TXENR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl DISABLED_TXENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DISABLED_TXENR::DISABLED => false,
                    DISABLED_TXENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DISABLED_TXENR {
                match value {
                    false => DISABLED_TXENR::DISABLED,
                    true => DISABLED_TXENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DISABLED_TXENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DISABLED_TXENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DISABLED_RXEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISABLED_RXENR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl DISABLED_RXENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DISABLED_RXENR::DISABLED => false,
                    DISABLED_RXENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DISABLED_RXENR {
                match value {
                    false => DISABLED_RXENR::DISABLED,
                    true => DISABLED_RXENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DISABLED_RXENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DISABLED_RXENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDRESS_RSSISTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRESS_RSSISTARTR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl ADDRESS_RSSISTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDRESS_RSSISTARTR::DISABLED => false,
                    ADDRESS_RSSISTARTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDRESS_RSSISTARTR {
                match value {
                    false => ADDRESS_RSSISTARTR::DISABLED,
                    true => ADDRESS_RSSISTARTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDRESS_RSSISTARTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDRESS_RSSISTARTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `END_START`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum END_STARTR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl END_STARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    END_STARTR::DISABLED => false,
                    END_STARTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> END_STARTR {
                match value {
                    false => END_STARTR::DISABLED,
                    true => END_STARTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == END_STARTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == END_STARTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDRESS_BCSTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRESS_BCSTARTR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl ADDRESS_BCSTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDRESS_BCSTARTR::DISABLED => false,
                    ADDRESS_BCSTARTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDRESS_BCSTARTR {
                match value {
                    false => ADDRESS_BCSTARTR::DISABLED,
                    true => ADDRESS_BCSTARTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDRESS_BCSTARTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDRESS_BCSTARTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DISABLED_RSSISTOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISABLED_RSSISTOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl DISABLED_RSSISTOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DISABLED_RSSISTOPR::DISABLED => false,
                    DISABLED_RSSISTOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DISABLED_RSSISTOPR {
                match value {
                    false => DISABLED_RSSISTOPR::DISABLED,
                    true => DISABLED_RSSISTOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DISABLED_RSSISTOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DISABLED_RSSISTOPR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `READY_START`"]
        pub enum READY_STARTW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl READY_STARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READY_STARTW::DISABLED => false,
                    READY_STARTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READY_STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READY_STARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READY_STARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(READY_STARTW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(READY_STARTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `END_DISABLE`"]
        pub enum END_DISABLEW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl END_DISABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    END_DISABLEW::DISABLED => false,
                    END_DISABLEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _END_DISABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _END_DISABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: END_DISABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(END_DISABLEW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(END_DISABLEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DISABLED_TXEN`"]
        pub enum DISABLED_TXENW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl DISABLED_TXENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DISABLED_TXENW::DISABLED => false,
                    DISABLED_TXENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISABLED_TXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISABLED_TXENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DISABLED_TXENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DISABLED_TXENW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DISABLED_TXENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DISABLED_RXEN`"]
        pub enum DISABLED_RXENW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl DISABLED_RXENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DISABLED_RXENW::DISABLED => false,
                    DISABLED_RXENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISABLED_RXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISABLED_RXENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DISABLED_RXENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DISABLED_RXENW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DISABLED_RXENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDRESS_RSSISTART`"]
        pub enum ADDRESS_RSSISTARTW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl ADDRESS_RSSISTARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDRESS_RSSISTARTW::DISABLED => false,
                    ADDRESS_RSSISTARTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESS_RSSISTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESS_RSSISTARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDRESS_RSSISTARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDRESS_RSSISTARTW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDRESS_RSSISTARTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `END_START`"]
        pub enum END_STARTW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl END_STARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    END_STARTW::DISABLED => false,
                    END_STARTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _END_STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _END_STARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: END_STARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(END_STARTW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(END_STARTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDRESS_BCSTART`"]
        pub enum ADDRESS_BCSTARTW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl ADDRESS_BCSTARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDRESS_BCSTARTW::DISABLED => false,
                    ADDRESS_BCSTARTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESS_BCSTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESS_BCSTARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDRESS_BCSTARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDRESS_BCSTARTW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDRESS_BCSTARTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DISABLED_RSSISTOP`"]
        pub enum DISABLED_RSSISTOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl DISABLED_RSSISTOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DISABLED_RSSISTOPW::DISABLED => false,
                    DISABLED_RSSISTOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISABLED_RSSISTOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISABLED_RSSISTOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DISABLED_RSSISTOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DISABLED_RSSISTOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DISABLED_RSSISTOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Shortcut between READY event and START task."]
            #[inline]
            pub fn ready_start(&self) -> READY_STARTR {
                READY_STARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Shortcut between END event and DISABLE task."]
            #[inline]
            pub fn end_disable(&self) -> END_DISABLER {
                END_DISABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Shortcut between DISABLED event and TXEN task."]
            #[inline]
            pub fn disabled_txen(&self) -> DISABLED_TXENR {
                DISABLED_TXENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Shortcut between DISABLED event and RXEN task."]
            #[inline]
            pub fn disabled_rxen(&self) -> DISABLED_RXENR {
                DISABLED_RXENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Shortcut between ADDRESS event and RSSISTART task."]
            #[inline]
            pub fn address_rssistart(&self) -> ADDRESS_RSSISTARTR {
                ADDRESS_RSSISTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Shortcut between END event and START task."]
            #[inline]
            pub fn end_start(&self) -> END_STARTR {
                END_STARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Shortcut between ADDRESS event and BCSTART task."]
            #[inline]
            pub fn address_bcstart(&self) -> ADDRESS_BCSTARTR {
                ADDRESS_BCSTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Shortcut between DISABLED event and RSSISTOP task."]
            #[inline]
            pub fn disabled_rssistop(&self) -> DISABLED_RSSISTOPR {
                DISABLED_RSSISTOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Shortcut between READY event and START task."]
            #[inline]
            pub fn ready_start(&mut self) -> _READY_STARTW {
                _READY_STARTW { w: self }
            }
            #[doc = "Bit 1 - Shortcut between END event and DISABLE task."]
            #[inline]
            pub fn end_disable(&mut self) -> _END_DISABLEW {
                _END_DISABLEW { w: self }
            }
            #[doc = "Bit 2 - Shortcut between DISABLED event and TXEN task."]
            #[inline]
            pub fn disabled_txen(&mut self) -> _DISABLED_TXENW {
                _DISABLED_TXENW { w: self }
            }
            #[doc = "Bit 3 - Shortcut between DISABLED event and RXEN task."]
            #[inline]
            pub fn disabled_rxen(&mut self) -> _DISABLED_RXENW {
                _DISABLED_RXENW { w: self }
            }
            #[doc = "Bit 4 - Shortcut between ADDRESS event and RSSISTART task."]
            #[inline]
            pub fn address_rssistart(&mut self) -> _ADDRESS_RSSISTARTW {
                _ADDRESS_RSSISTARTW { w: self }
            }
            #[doc = "Bit 5 - Shortcut between END event and START task."]
            #[inline]
            pub fn end_start(&mut self) -> _END_STARTW {
                _END_STARTW { w: self }
            }
            #[doc = "Bit 6 - Shortcut between ADDRESS event and BCSTART task."]
            #[inline]
            pub fn address_bcstart(&mut self) -> _ADDRESS_BCSTARTW {
                _ADDRESS_BCSTARTW { w: self }
            }
            #[doc = "Bit 8 - Shortcut between DISABLED event and RSSISTOP task."]
            #[inline]
            pub fn disabled_rssistop(&mut self) -> _DISABLED_RSSISTOPW {
                _DISABLED_RSSISTOPW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `READY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl READYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READYR::DISABLED => false,
                    READYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READYR {
                match value {
                    false => READYR::DISABLED,
                    true => READYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDRESS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRESSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ADDRESSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDRESSR::DISABLED => false,
                    ADDRESSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDRESSR {
                match value {
                    false => ADDRESSR::DISABLED,
                    true => ADDRESSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDRESSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDRESSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `PAYLOAD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PAYLOADR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl PAYLOADR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PAYLOADR::DISABLED => false,
                    PAYLOADR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PAYLOADR {
                match value {
                    false => PAYLOADR::DISABLED,
                    true => PAYLOADR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PAYLOADR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PAYLOADR::ENABLED
            }
        }
        #[doc = "Possible values of the field `END`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDR::DISABLED => false,
                    ENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDR {
                match value {
                    false => ENDR::DISABLED,
                    true => ENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DISABLED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISABLEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DISABLEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DISABLEDR::DISABLED => false,
                    DISABLEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DISABLEDR {
                match value {
                    false => DISABLEDR::DISABLED,
                    true => DISABLEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DISABLEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DISABLEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DEVMATCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEVMATCHR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DEVMATCHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DEVMATCHR::DISABLED => false,
                    DEVMATCHR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DEVMATCHR {
                match value {
                    false => DEVMATCHR::DISABLED,
                    true => DEVMATCHR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DEVMATCHR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DEVMATCHR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DEVMISS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEVMISSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DEVMISSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DEVMISSR::DISABLED => false,
                    DEVMISSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DEVMISSR {
                match value {
                    false => DEVMISSR::DISABLED,
                    true => DEVMISSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DEVMISSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DEVMISSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RSSIEND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSSIENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RSSIENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RSSIENDR::DISABLED => false,
                    RSSIENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RSSIENDR {
                match value {
                    false => RSSIENDR::DISABLED,
                    true => RSSIENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RSSIENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RSSIENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `BCMATCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BCMATCHR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl BCMATCHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BCMATCHR::DISABLED => false,
                    BCMATCHR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BCMATCHR {
                match value {
                    false => BCMATCHR::DISABLED,
                    true => BCMATCHR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BCMATCHR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BCMATCHR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `READY`"]
        pub enum READYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl READYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(READYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDRESS`"]
        pub enum ADDRESSW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ADDRESSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDRESSW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDRESSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ADDRESSW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PAYLOAD`"]
        pub enum PAYLOADW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl PAYLOADW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PAYLOADW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAYLOADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAYLOADW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PAYLOADW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PAYLOADW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `END`"]
        pub enum ENDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DISABLED`"]
        pub enum DISABLEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl DISABLEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DISABLEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISABLEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISABLEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DISABLEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(DISABLEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DEVMATCH`"]
        pub enum DEVMATCHW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl DEVMATCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DEVMATCHW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEVMATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEVMATCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DEVMATCHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(DEVMATCHW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DEVMISS`"]
        pub enum DEVMISSW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl DEVMISSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DEVMISSW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEVMISSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEVMISSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DEVMISSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(DEVMISSW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RSSIEND`"]
        pub enum RSSIENDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl RSSIENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RSSIENDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSSIENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSSIENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RSSIENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(RSSIENDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BCMATCH`"]
        pub enum BCMATCHW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl BCMATCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BCMATCHW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BCMATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BCMATCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BCMATCHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BCMATCHW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on READY event."]
            #[inline]
            pub fn ready(&self) -> READYR {
                READYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on ADDRESS event."]
            #[inline]
            pub fn address(&self) -> ADDRESSR {
                ADDRESSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable interrupt on PAYLOAD event."]
            #[inline]
            pub fn payload(&self) -> PAYLOADR {
                PAYLOADR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable interrupt on END event."]
            #[inline]
            pub fn end(&self) -> ENDR {
                ENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enable interrupt on DISABLED event."]
            #[inline]
            pub fn disabled(&self) -> DISABLEDR {
                DISABLEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enable interrupt on DEVMATCH event."]
            #[inline]
            pub fn devmatch(&self) -> DEVMATCHR {
                DEVMATCHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enable interrupt on DEVMISS event."]
            #[inline]
            pub fn devmiss(&self) -> DEVMISSR {
                DEVMISSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enable interrupt on RSSIEND event."]
            #[inline]
            pub fn rssiend(&self) -> RSSIENDR {
                RSSIENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Enable interrupt on BCMATCH event."]
            #[inline]
            pub fn bcmatch(&self) -> BCMATCHR {
                BCMATCHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on READY event."]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on ADDRESS event."]
            #[inline]
            pub fn address(&mut self) -> _ADDRESSW {
                _ADDRESSW { w: self }
            }
            #[doc = "Bit 2 - Enable interrupt on PAYLOAD event."]
            #[inline]
            pub fn payload(&mut self) -> _PAYLOADW {
                _PAYLOADW { w: self }
            }
            #[doc = "Bit 3 - Enable interrupt on END event."]
            #[inline]
            pub fn end(&mut self) -> _ENDW {
                _ENDW { w: self }
            }
            #[doc = "Bit 4 - Enable interrupt on DISABLED event."]
            #[inline]
            pub fn disabled(&mut self) -> _DISABLEDW {
                _DISABLEDW { w: self }
            }
            #[doc = "Bit 5 - Enable interrupt on DEVMATCH event."]
            #[inline]
            pub fn devmatch(&mut self) -> _DEVMATCHW {
                _DEVMATCHW { w: self }
            }
            #[doc = "Bit 6 - Enable interrupt on DEVMISS event."]
            #[inline]
            pub fn devmiss(&mut self) -> _DEVMISSW {
                _DEVMISSW { w: self }
            }
            #[doc = "Bit 7 - Enable interrupt on RSSIEND event."]
            #[inline]
            pub fn rssiend(&mut self) -> _RSSIENDW {
                _RSSIENDW { w: self }
            }
            #[doc = "Bit 10 - Enable interrupt on BCMATCH event."]
            #[inline]
            pub fn bcmatch(&mut self) -> _BCMATCHW {
                _BCMATCHW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `READY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl READYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READYR::DISABLED => false,
                    READYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READYR {
                match value {
                    false => READYR::DISABLED,
                    true => READYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDRESS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDRESSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ADDRESSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDRESSR::DISABLED => false,
                    ADDRESSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDRESSR {
                match value {
                    false => ADDRESSR::DISABLED,
                    true => ADDRESSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDRESSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDRESSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `PAYLOAD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PAYLOADR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl PAYLOADR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PAYLOADR::DISABLED => false,
                    PAYLOADR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PAYLOADR {
                match value {
                    false => PAYLOADR::DISABLED,
                    true => PAYLOADR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PAYLOADR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PAYLOADR::ENABLED
            }
        }
        #[doc = "Possible values of the field `END`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDR::DISABLED => false,
                    ENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDR {
                match value {
                    false => ENDR::DISABLED,
                    true => ENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DISABLED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISABLEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DISABLEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DISABLEDR::DISABLED => false,
                    DISABLEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DISABLEDR {
                match value {
                    false => DISABLEDR::DISABLED,
                    true => DISABLEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DISABLEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DISABLEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DEVMATCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEVMATCHR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DEVMATCHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DEVMATCHR::DISABLED => false,
                    DEVMATCHR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DEVMATCHR {
                match value {
                    false => DEVMATCHR::DISABLED,
                    true => DEVMATCHR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DEVMATCHR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DEVMATCHR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DEVMISS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEVMISSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DEVMISSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DEVMISSR::DISABLED => false,
                    DEVMISSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DEVMISSR {
                match value {
                    false => DEVMISSR::DISABLED,
                    true => DEVMISSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DEVMISSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DEVMISSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RSSIEND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSSIENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RSSIENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RSSIENDR::DISABLED => false,
                    RSSIENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RSSIENDR {
                match value {
                    false => RSSIENDR::DISABLED,
                    true => RSSIENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RSSIENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RSSIENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `BCMATCH`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BCMATCHR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl BCMATCHR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BCMATCHR::DISABLED => false,
                    BCMATCHR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BCMATCHR {
                match value {
                    false => BCMATCHR::DISABLED,
                    true => BCMATCHR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BCMATCHR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BCMATCHR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `READY`"]
        pub enum READYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl READYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(READYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDRESS`"]
        pub enum ADDRESSW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ADDRESSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDRESSW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDRESSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ADDRESSW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PAYLOAD`"]
        pub enum PAYLOADW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl PAYLOADW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PAYLOADW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PAYLOADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PAYLOADW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PAYLOADW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PAYLOADW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `END`"]
        pub enum ENDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DISABLED`"]
        pub enum DISABLEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl DISABLEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DISABLEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DISABLEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DISABLEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DISABLEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(DISABLEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DEVMATCH`"]
        pub enum DEVMATCHW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl DEVMATCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DEVMATCHW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEVMATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEVMATCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DEVMATCHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(DEVMATCHW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DEVMISS`"]
        pub enum DEVMISSW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl DEVMISSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DEVMISSW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEVMISSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEVMISSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DEVMISSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(DEVMISSW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RSSIEND`"]
        pub enum RSSIENDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl RSSIENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RSSIENDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSSIENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSSIENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RSSIENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(RSSIENDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BCMATCH`"]
        pub enum BCMATCHW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl BCMATCHW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BCMATCHW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BCMATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BCMATCHW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BCMATCHW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(BCMATCHW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on READY event."]
            #[inline]
            pub fn ready(&self) -> READYR {
                READYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on ADDRESS event."]
            #[inline]
            pub fn address(&self) -> ADDRESSR {
                ADDRESSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable interrupt on PAYLOAD event."]
            #[inline]
            pub fn payload(&self) -> PAYLOADR {
                PAYLOADR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Disable interrupt on END event."]
            #[inline]
            pub fn end(&self) -> ENDR {
                ENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Disable interrupt on DISABLED event."]
            #[inline]
            pub fn disabled(&self) -> DISABLEDR {
                DISABLEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Disable interrupt on DEVMATCH event."]
            #[inline]
            pub fn devmatch(&self) -> DEVMATCHR {
                DEVMATCHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Disable interrupt on DEVMISS event."]
            #[inline]
            pub fn devmiss(&self) -> DEVMISSR {
                DEVMISSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Disable interrupt on RSSIEND event."]
            #[inline]
            pub fn rssiend(&self) -> RSSIENDR {
                RSSIENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Disable interrupt on BCMATCH event."]
            #[inline]
            pub fn bcmatch(&self) -> BCMATCHR {
                BCMATCHR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on READY event."]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on ADDRESS event."]
            #[inline]
            pub fn address(&mut self) -> _ADDRESSW {
                _ADDRESSW { w: self }
            }
            #[doc = "Bit 2 - Disable interrupt on PAYLOAD event."]
            #[inline]
            pub fn payload(&mut self) -> _PAYLOADW {
                _PAYLOADW { w: self }
            }
            #[doc = "Bit 3 - Disable interrupt on END event."]
            #[inline]
            pub fn end(&mut self) -> _ENDW {
                _ENDW { w: self }
            }
            #[doc = "Bit 4 - Disable interrupt on DISABLED event."]
            #[inline]
            pub fn disabled(&mut self) -> _DISABLEDW {
                _DISABLEDW { w: self }
            }
            #[doc = "Bit 5 - Disable interrupt on DEVMATCH event."]
            #[inline]
            pub fn devmatch(&mut self) -> _DEVMATCHW {
                _DEVMATCHW { w: self }
            }
            #[doc = "Bit 6 - Disable interrupt on DEVMISS event."]
            #[inline]
            pub fn devmiss(&mut self) -> _DEVMISSW {
                _DEVMISSW { w: self }
            }
            #[doc = "Bit 7 - Disable interrupt on RSSIEND event."]
            #[inline]
            pub fn rssiend(&mut self) -> _RSSIENDW {
                _RSSIENDW { w: self }
            }
            #[doc = "Bit 10 - Disable interrupt on BCMATCH event."]
            #[inline]
            pub fn bcmatch(&mut self) -> _BCMATCHW {
                _BCMATCHW { w: self }
            }
        }
    }
    #[doc = "CRC status of received packet."]
    pub struct CRCSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC status of received packet."]
    pub mod crcstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CRCSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `CRCSTATUS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCSTATUSR {
            #[doc = "Packet received with CRC error."]
            CRCERROR,
            #[doc = "Packet received with CRC ok."]
            CRCOK,
        }
        impl CRCSTATUSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CRCSTATUSR::CRCERROR => false,
                    CRCSTATUSR::CRCOK => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CRCSTATUSR {
                match value {
                    false => CRCSTATUSR::CRCERROR,
                    true => CRCSTATUSR::CRCOK,
                }
            }
            #[doc = "Checks if the value of the field is `CRCERROR`"]
            #[inline]
            pub fn is_crcerror(&self) -> bool {
                *self == CRCSTATUSR::CRCERROR
            }
            #[doc = "Checks if the value of the field is `CRCOK`"]
            #[inline]
            pub fn is_crcok(&self) -> bool {
                *self == CRCSTATUSR::CRCOK
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CRC status of received packet."]
            #[inline]
            pub fn crcstatus(&self) -> CRCSTATUSR {
                CRCSTATUSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Received address."]
    pub struct RXMATCH {
        register: VolatileCell<u32>,
    }
    #[doc = "Received address."]
    pub mod rxmatch {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXMATCH {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXMATCHR {
            bits: u8,
        }
        impl RXMATCHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Logical address in which previous packet was received."]
            #[inline]
            pub fn rxmatch(&self) -> RXMATCHR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RXMATCHR { bits }
            }
        }
    }
    #[doc = "Received CRC."]
    pub struct RXCRC {
        register: VolatileCell<u32>,
    }
    #[doc = "Received CRC."]
    pub mod rxcrc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXCRC {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXCRCR {
            bits: u32,
        }
        impl RXCRCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - CRC field of previously received packet."]
            #[inline]
            pub fn rxcrc(&self) -> RXCRCR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                RXCRCR { bits }
            }
        }
    }
    #[doc = "Device address match index."]
    pub struct DAI {
        register: VolatileCell<u32>,
    }
    #[doc = "Device address match index."]
    pub mod dai {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DAI {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DAIR {
            bits: u8,
        }
        impl DAIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Index (n) of device address (see DAB[n] and DAP[n]) that obtained an address match."]
            #[inline]
            pub fn dai(&self) -> DAIR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DAIR { bits }
            }
        }
    }
    #[doc = "Packet pointer. Decision point: START task."]
    pub struct PACKETPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "Packet pointer. Decision point: START task."]
    pub mod packetptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PACKETPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Frequency."]
    pub struct FREQUENCY {
        register: VolatileCell<u32>,
    }
    #[doc = "Frequency."]
    pub mod frequency {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FREQUENCY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FREQUENCYR {
            bits: u8,
        }
        impl FREQUENCYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQUENCYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQUENCYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task."]
            #[inline]
            pub fn frequency(&self) -> FREQUENCYR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FREQUENCYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x02 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task."]
            #[inline]
            pub fn frequency(&mut self) -> _FREQUENCYW {
                _FREQUENCYW { w: self }
            }
        }
    }
    #[doc = "Output power."]
    pub struct TXPOWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Output power."]
    pub mod txpower {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXPOWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TXPOWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXPOWERR {
            #[doc = "+4dBm."]
            POS4DBM,
            #[doc = "0dBm."]
            _0DBM,
            #[doc = "-4dBm."]
            NEG4DBM,
            #[doc = "-8dBm."]
            NEG8DBM,
            #[doc = "-12dBm."]
            NEG12DBM,
            #[doc = "-16dBm."]
            NEG16DBM,
            #[doc = "-20dBm."]
            NEG20DBM,
            #[doc = "-30dBm."]
            NEG30DBM,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl TXPOWERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    TXPOWERR::POS4DBM => 0x04,
                    TXPOWERR::_0DBM => 0,
                    TXPOWERR::NEG4DBM => 0xfc,
                    TXPOWERR::NEG8DBM => 0xf8,
                    TXPOWERR::NEG12DBM => 0xf4,
                    TXPOWERR::NEG16DBM => 0xf0,
                    TXPOWERR::NEG20DBM => 0xec,
                    TXPOWERR::NEG30DBM => 0xd8,
                    TXPOWERR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> TXPOWERR {
                match value {
                    4 => TXPOWERR::POS4DBM,
                    0 => TXPOWERR::_0DBM,
                    252 => TXPOWERR::NEG4DBM,
                    248 => TXPOWERR::NEG8DBM,
                    244 => TXPOWERR::NEG12DBM,
                    240 => TXPOWERR::NEG16DBM,
                    236 => TXPOWERR::NEG20DBM,
                    216 => TXPOWERR::NEG30DBM,
                    i => TXPOWERR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `POS4DBM`"]
            #[inline]
            pub fn is_pos4d_bm(&self) -> bool {
                *self == TXPOWERR::POS4DBM
            }
            #[doc = "Checks if the value of the field is `_0DBM`"]
            #[inline]
            pub fn is_0d_bm(&self) -> bool {
                *self == TXPOWERR::_0DBM
            }
            #[doc = "Checks if the value of the field is `NEG4DBM`"]
            #[inline]
            pub fn is_neg4d_bm(&self) -> bool {
                *self == TXPOWERR::NEG4DBM
            }
            #[doc = "Checks if the value of the field is `NEG8DBM`"]
            #[inline]
            pub fn is_neg8d_bm(&self) -> bool {
                *self == TXPOWERR::NEG8DBM
            }
            #[doc = "Checks if the value of the field is `NEG12DBM`"]
            #[inline]
            pub fn is_neg12d_bm(&self) -> bool {
                *self == TXPOWERR::NEG12DBM
            }
            #[doc = "Checks if the value of the field is `NEG16DBM`"]
            #[inline]
            pub fn is_neg16d_bm(&self) -> bool {
                *self == TXPOWERR::NEG16DBM
            }
            #[doc = "Checks if the value of the field is `NEG20DBM`"]
            #[inline]
            pub fn is_neg20d_bm(&self) -> bool {
                *self == TXPOWERR::NEG20DBM
            }
            #[doc = "Checks if the value of the field is `NEG30DBM`"]
            #[inline]
            pub fn is_neg30d_bm(&self) -> bool {
                *self == TXPOWERR::NEG30DBM
            }
        }
        #[doc = "Values that can be written to the field `TXPOWER`"]
        pub enum TXPOWERW {
            #[doc = "+4dBm."]
            POS4DBM,
            #[doc = "0dBm."]
            _0DBM,
            #[doc = "-4dBm."]
            NEG4DBM,
            #[doc = "-8dBm."]
            NEG8DBM,
            #[doc = "-12dBm."]
            NEG12DBM,
            #[doc = "-16dBm."]
            NEG16DBM,
            #[doc = "-20dBm."]
            NEG20DBM,
            #[doc = "-30dBm."]
            NEG30DBM,
        }
        impl TXPOWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    TXPOWERW::POS4DBM => 4,
                    TXPOWERW::_0DBM => 0,
                    TXPOWERW::NEG4DBM => 252,
                    TXPOWERW::NEG8DBM => 248,
                    TXPOWERW::NEG12DBM => 244,
                    TXPOWERW::NEG16DBM => 240,
                    TXPOWERW::NEG20DBM => 236,
                    TXPOWERW::NEG30DBM => 216,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXPOWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXPOWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXPOWERW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "+4dBm."]
            #[inline]
            pub fn pos4d_bm(self) -> &'a mut W {
                self.variant(TXPOWERW::POS4DBM)
            }
            #[doc = "0dBm."]
            #[inline]
            pub fn _0d_bm(self) -> &'a mut W {
                self.variant(TXPOWERW::_0DBM)
            }
            #[doc = "-4dBm."]
            #[inline]
            pub fn neg4d_bm(self) -> &'a mut W {
                self.variant(TXPOWERW::NEG4DBM)
            }
            #[doc = "-8dBm."]
            #[inline]
            pub fn neg8d_bm(self) -> &'a mut W {
                self.variant(TXPOWERW::NEG8DBM)
            }
            #[doc = "-12dBm."]
            #[inline]
            pub fn neg12d_bm(self) -> &'a mut W {
                self.variant(TXPOWERW::NEG12DBM)
            }
            #[doc = "-16dBm."]
            #[inline]
            pub fn neg16d_bm(self) -> &'a mut W {
                self.variant(TXPOWERW::NEG16DBM)
            }
            #[doc = "-20dBm."]
            #[inline]
            pub fn neg20d_bm(self) -> &'a mut W {
                self.variant(TXPOWERW::NEG20DBM)
            }
            #[doc = "-30dBm."]
            #[inline]
            pub fn neg30d_bm(self) -> &'a mut W {
                self.variant(TXPOWERW::NEG30DBM)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Radio output power. Decision point: TXEN task."]
            #[inline]
            pub fn txpower(&self) -> TXPOWERR {
                TXPOWERR::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Radio output power. Decision point: TXEN task."]
            #[inline]
            pub fn txpower(&mut self) -> _TXPOWERW {
                _TXPOWERW { w: self }
            }
        }
    }
    #[doc = "Data rate and modulation."]
    pub struct MODE {
        register: VolatileCell<u32>,
    }
    #[doc = "Data rate and modulation."]
    pub mod mode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "1Mbit/s Nordic propietary radio mode."]
            NRF_1MBIT,
            #[doc = "2Mbit/s Nordic propietary radio mode."]
            NRF_2MBIT,
            #[doc = "250kbit/s Nordic propietary radio mode."]
            NRF_250KBIT,
            #[doc = "1Mbit/s Bluetooth Low Energy"]
            BLE_1MBIT,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::NRF_1MBIT => 0,
                    MODER::NRF_2MBIT => 0x01,
                    MODER::NRF_250KBIT => 0x02,
                    MODER::BLE_1MBIT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::NRF_1MBIT,
                    1 => MODER::NRF_2MBIT,
                    2 => MODER::NRF_250KBIT,
                    3 => MODER::BLE_1MBIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NRF_1MBIT`"]
            #[inline]
            pub fn is_nrf_1mbit(&self) -> bool {
                *self == MODER::NRF_1MBIT
            }
            #[doc = "Checks if the value of the field is `NRF_2MBIT`"]
            #[inline]
            pub fn is_nrf_2mbit(&self) -> bool {
                *self == MODER::NRF_2MBIT
            }
            #[doc = "Checks if the value of the field is `NRF_250KBIT`"]
            #[inline]
            pub fn is_nrf_250kbit(&self) -> bool {
                *self == MODER::NRF_250KBIT
            }
            #[doc = "Checks if the value of the field is `BLE_1MBIT`"]
            #[inline]
            pub fn is_ble_1mbit(&self) -> bool {
                *self == MODER::BLE_1MBIT
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "1Mbit/s Nordic propietary radio mode."]
            NRF_1MBIT,
            #[doc = "2Mbit/s Nordic propietary radio mode."]
            NRF_2MBIT,
            #[doc = "250kbit/s Nordic propietary radio mode."]
            NRF_250KBIT,
            #[doc = "1Mbit/s Bluetooth Low Energy"]
            BLE_1MBIT,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::NRF_1MBIT => 0,
                    MODEW::NRF_2MBIT => 1,
                    MODEW::NRF_250KBIT => 2,
                    MODEW::BLE_1MBIT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "1Mbit/s Nordic propietary radio mode."]
            #[inline]
            pub fn nrf_1mbit(self) -> &'a mut W {
                self.variant(MODEW::NRF_1MBIT)
            }
            #[doc = "2Mbit/s Nordic propietary radio mode."]
            #[inline]
            pub fn nrf_2mbit(self) -> &'a mut W {
                self.variant(MODEW::NRF_2MBIT)
            }
            #[doc = "250kbit/s Nordic propietary radio mode."]
            #[inline]
            pub fn nrf_250kbit(self) -> &'a mut W {
                self.variant(MODEW::NRF_250KBIT)
            }
            #[doc = "1Mbit/s Bluetooth Low Energy"]
            #[inline]
            pub fn ble_1mbit(self) -> &'a mut W {
                self.variant(MODEW::BLE_1MBIT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Radio data rate and modulation setting. Decision point: TXEN or RXEN task."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Radio data rate and modulation setting. Decision point: TXEN or RXEN task."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
        }
    }
    #[doc = "Packet configuration 0."]
    pub struct PCNF0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Packet configuration 0."]
    pub mod pcnf0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PCNF0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LFLENR {
            bits: u8,
        }
        impl LFLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct S0LENR {
            bits: bool,
        }
        impl S0LENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct S1LENR {
            bits: u8,
        }
        impl S1LENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LFLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LFLENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _S0LENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S0LENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _S1LENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _S1LENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Length of length field in number of bits. Decision point: START task."]
            #[inline]
            pub fn lflen(&self) -> LFLENR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LFLENR { bits }
            }
            #[doc = "Bit 8 - Length of S0 field in number of bytes. Decision point: START task."]
            #[inline]
            pub fn s0len(&self) -> S0LENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                S0LENR { bits }
            }
            #[doc = "Bits 16:19 - Length of S1 field in number of bits. Decision point: START task."]
            #[inline]
            pub fn s1len(&self) -> S1LENR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                S1LENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Length of length field in number of bits. Decision point: START task."]
            #[inline]
            pub fn lflen(&mut self) -> _LFLENW {
                _LFLENW { w: self }
            }
            #[doc = "Bit 8 - Length of S0 field in number of bytes. Decision point: START task."]
            #[inline]
            pub fn s0len(&mut self) -> _S0LENW {
                _S0LENW { w: self }
            }
            #[doc = "Bits 16:19 - Length of S1 field in number of bits. Decision point: START task."]
            #[inline]
            pub fn s1len(&mut self) -> _S1LENW {
                _S1LENW { w: self }
            }
        }
    }
    #[doc = "Packet configuration 1."]
    pub struct PCNF1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Packet configuration 1."]
    pub mod pcnf1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PCNF1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MAXLENR {
            bits: u8,
        }
        impl MAXLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATLENR {
            bits: u8,
        }
        impl STATLENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct BALENR {
            bits: u8,
        }
        impl BALENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ENDIAN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDIANR {
            #[doc = "Least significant bit on air first"]
            LITTLE,
            #[doc = "Most significant bit on air first"]
            BIG,
        }
        impl ENDIANR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDIANR::LITTLE => false,
                    ENDIANR::BIG => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDIANR {
                match value {
                    false => ENDIANR::LITTLE,
                    true => ENDIANR::BIG,
                }
            }
            #[doc = "Checks if the value of the field is `LITTLE`"]
            #[inline]
            pub fn is_little(&self) -> bool {
                *self == ENDIANR::LITTLE
            }
            #[doc = "Checks if the value of the field is `BIG`"]
            #[inline]
            pub fn is_big(&self) -> bool {
                *self == ENDIANR::BIG
            }
        }
        #[doc = "Possible values of the field `WHITEEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WHITEENR {
            #[doc = "Whitening disabled."]
            DISABLED,
            #[doc = "Whitening enabled."]
            ENABLED,
        }
        impl WHITEENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WHITEENR::DISABLED => false,
                    WHITEENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WHITEENR {
                match value {
                    false => WHITEENR::DISABLED,
                    true => WHITEENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WHITEENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WHITEENR::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _MAXLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MAXLENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STATLENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STATLENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _BALENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BALENW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENDIAN`"]
        pub enum ENDIANW {
            #[doc = "Least significant bit on air first"]
            LITTLE,
            #[doc = "Most significant bit on air first"]
            BIG,
        }
        impl ENDIANW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDIANW::LITTLE => false,
                    ENDIANW::BIG => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDIANW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDIANW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDIANW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Least significant bit on air first"]
            #[inline]
            pub fn little(self) -> &'a mut W {
                self.variant(ENDIANW::LITTLE)
            }
            #[doc = "Most significant bit on air first"]
            #[inline]
            pub fn big(self) -> &'a mut W {
                self.variant(ENDIANW::BIG)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WHITEEN`"]
        pub enum WHITEENW {
            #[doc = "Whitening disabled."]
            DISABLED,
            #[doc = "Whitening enabled."]
            ENABLED,
        }
        impl WHITEENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WHITEENW::DISABLED => false,
                    WHITEENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WHITEENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WHITEENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WHITEENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Whitening disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WHITEENW::DISABLED)
            }
            #[doc = "Whitening enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WHITEENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Maximum length of packet payload in number of bytes."]
            #[inline]
            pub fn maxlen(&self) -> MAXLENR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MAXLENR { bits }
            }
            #[doc = "Bits 8:15 - Static length in number of bytes. Decision point: START task."]
            #[inline]
            pub fn statlen(&self) -> STATLENR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATLENR { bits }
            }
            #[doc = "Bits 16:18 - Base address length in number of bytes. Decision point: START task."]
            #[inline]
            pub fn balen(&self) -> BALENR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                BALENR { bits }
            }
            #[doc = "Bit 24 - On air endianness of packet length field. Decision point: START task."]
            #[inline]
            pub fn endian(&self) -> ENDIANR {
                ENDIANR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Packet whitening enable."]
            #[inline]
            pub fn whiteen(&self) -> WHITEENR {
                WHITEENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Maximum length of packet payload in number of bytes."]
            #[inline]
            pub fn maxlen(&mut self) -> _MAXLENW {
                _MAXLENW { w: self }
            }
            #[doc = "Bits 8:15 - Static length in number of bytes. Decision point: START task."]
            #[inline]
            pub fn statlen(&mut self) -> _STATLENW {
                _STATLENW { w: self }
            }
            #[doc = "Bits 16:18 - Base address length in number of bytes. Decision point: START task."]
            #[inline]
            pub fn balen(&mut self) -> _BALENW {
                _BALENW { w: self }
            }
            #[doc = "Bit 24 - On air endianness of packet length field. Decision point: START task."]
            #[inline]
            pub fn endian(&mut self) -> _ENDIANW {
                _ENDIANW { w: self }
            }
            #[doc = "Bit 25 - Packet whitening enable."]
            #[inline]
            pub fn whiteen(&mut self) -> _WHITEENW {
                _WHITEENW { w: self }
            }
        }
    }
    #[doc = "Radio base address 0. Decision point: START task."]
    pub struct BASE0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Radio base address 0. Decision point: START task."]
    pub mod base0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BASE0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Radio base address 1. Decision point: START task."]
    pub struct BASE1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Radio base address 1. Decision point: START task."]
    pub mod base1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BASE1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Prefixes bytes for logical addresses 0 to 3."]
    pub struct PREFIX0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Prefixes bytes for logical addresses 0 to 3."]
    pub mod prefix0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PREFIX0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct AP0R {
            bits: u8,
        }
        impl AP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AP1R {
            bits: u8,
        }
        impl AP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AP2R {
            bits: u8,
        }
        impl AP2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AP3R {
            bits: u8,
        }
        impl AP3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _AP0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _AP0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _AP1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AP2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _AP2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AP3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _AP3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Address prefix 0. Decision point: START task."]
            #[inline]
            pub fn ap0(&self) -> AP0R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AP0R { bits }
            }
            #[doc = "Bits 8:15 - Address prefix 1. Decision point: START task."]
            #[inline]
            pub fn ap1(&self) -> AP1R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AP1R { bits }
            }
            #[doc = "Bits 16:23 - Address prefix 2. Decision point: START task."]
            #[inline]
            pub fn ap2(&self) -> AP2R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AP2R { bits }
            }
            #[doc = "Bits 24:31 - Address prefix 3. Decision point: START task."]
            #[inline]
            pub fn ap3(&self) -> AP3R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AP3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Address prefix 0. Decision point: START task."]
            #[inline]
            pub fn ap0(&mut self) -> _AP0W {
                _AP0W { w: self }
            }
            #[doc = "Bits 8:15 - Address prefix 1. Decision point: START task."]
            #[inline]
            pub fn ap1(&mut self) -> _AP1W {
                _AP1W { w: self }
            }
            #[doc = "Bits 16:23 - Address prefix 2. Decision point: START task."]
            #[inline]
            pub fn ap2(&mut self) -> _AP2W {
                _AP2W { w: self }
            }
            #[doc = "Bits 24:31 - Address prefix 3. Decision point: START task."]
            #[inline]
            pub fn ap3(&mut self) -> _AP3W {
                _AP3W { w: self }
            }
        }
    }
    #[doc = "Prefixes bytes for logical addresses 4 to 7."]
    pub struct PREFIX1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Prefixes bytes for logical addresses 4 to 7."]
    pub mod prefix1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PREFIX1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct AP4R {
            bits: u8,
        }
        impl AP4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AP5R {
            bits: u8,
        }
        impl AP5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AP6R {
            bits: u8,
        }
        impl AP6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct AP7R {
            bits: u8,
        }
        impl AP7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _AP4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _AP4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AP5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _AP5W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AP6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _AP6W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _AP7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _AP7W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Address prefix 4. Decision point: START task."]
            #[inline]
            pub fn ap4(&self) -> AP4R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AP4R { bits }
            }
            #[doc = "Bits 8:15 - Address prefix 5. Decision point: START task."]
            #[inline]
            pub fn ap5(&self) -> AP5R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AP5R { bits }
            }
            #[doc = "Bits 16:23 - Address prefix 6. Decision point: START task."]
            #[inline]
            pub fn ap6(&self) -> AP6R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AP6R { bits }
            }
            #[doc = "Bits 24:31 - Address prefix 7. Decision point: START task."]
            #[inline]
            pub fn ap7(&self) -> AP7R {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AP7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Address prefix 4. Decision point: START task."]
            #[inline]
            pub fn ap4(&mut self) -> _AP4W {
                _AP4W { w: self }
            }
            #[doc = "Bits 8:15 - Address prefix 5. Decision point: START task."]
            #[inline]
            pub fn ap5(&mut self) -> _AP5W {
                _AP5W { w: self }
            }
            #[doc = "Bits 16:23 - Address prefix 6. Decision point: START task."]
            #[inline]
            pub fn ap6(&mut self) -> _AP6W {
                _AP6W { w: self }
            }
            #[doc = "Bits 24:31 - Address prefix 7. Decision point: START task."]
            #[inline]
            pub fn ap7(&mut self) -> _AP7W {
                _AP7W { w: self }
            }
        }
    }
    #[doc = "Transmit address select."]
    pub struct TXADDRESS {
        register: VolatileCell<u32>,
    }
    #[doc = "Transmit address select."]
    pub mod txaddress {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXADDRESS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADDRESSR {
            bits: u8,
        }
        impl TXADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Logical address to be used when transmitting a packet. Decision point: START task."]
            #[inline]
            pub fn txaddress(&self) -> TXADDRESSR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TXADDRESSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Logical address to be used when transmitting a packet. Decision point: START task."]
            #[inline]
            pub fn txaddress(&mut self) -> _TXADDRESSW {
                _TXADDRESSW { w: self }
            }
        }
    }
    #[doc = "Receive address select."]
    pub struct RXADDRESSES {
        register: VolatileCell<u32>,
    }
    #[doc = "Receive address select."]
    pub mod rxaddresses {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXADDRESSES {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ADDR0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR0R {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR0R::DISABLED => false,
                    ADDR0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR0R {
                match value {
                    false => ADDR0R::DISABLED,
                    true => ADDR0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDR0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDR0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDR1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR1R {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR1R::DISABLED => false,
                    ADDR1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR1R {
                match value {
                    false => ADDR1R::DISABLED,
                    true => ADDR1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDR1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDR1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDR2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR2R {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR2R::DISABLED => false,
                    ADDR2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR2R {
                match value {
                    false => ADDR2R::DISABLED,
                    true => ADDR2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDR2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDR2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDR3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR3R {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR3R::DISABLED => false,
                    ADDR3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR3R {
                match value {
                    false => ADDR3R::DISABLED,
                    true => ADDR3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDR3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDR3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDR4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR4R {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR4R::DISABLED => false,
                    ADDR4R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR4R {
                match value {
                    false => ADDR4R::DISABLED,
                    true => ADDR4R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDR4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDR4R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDR5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR5R {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR5R::DISABLED => false,
                    ADDR5R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR5R {
                match value {
                    false => ADDR5R::DISABLED,
                    true => ADDR5R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDR5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDR5R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDR6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR6R {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR6R::DISABLED => false,
                    ADDR6R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR6R {
                match value {
                    false => ADDR6R::DISABLED,
                    true => ADDR6R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDR6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDR6R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADDR7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR7R {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADDR7R::DISABLED => false,
                    ADDR7R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADDR7R {
                match value {
                    false => ADDR7R::DISABLED,
                    true => ADDR7R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADDR7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADDR7R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ADDR0`"]
        pub enum ADDR0W {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR0W::DISABLED => false,
                    ADDR0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reception disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDR0W::DISABLED)
            }
            #[doc = "Reception enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDR0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDR1`"]
        pub enum ADDR1W {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR1W::DISABLED => false,
                    ADDR1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reception disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDR1W::DISABLED)
            }
            #[doc = "Reception enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDR1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDR2`"]
        pub enum ADDR2W {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR2W::DISABLED => false,
                    ADDR2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reception disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDR2W::DISABLED)
            }
            #[doc = "Reception enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDR2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDR3`"]
        pub enum ADDR3W {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR3W::DISABLED => false,
                    ADDR3W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reception disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDR3W::DISABLED)
            }
            #[doc = "Reception enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDR3W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDR4`"]
        pub enum ADDR4W {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR4W::DISABLED => false,
                    ADDR4W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reception disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDR4W::DISABLED)
            }
            #[doc = "Reception enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDR4W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDR5`"]
        pub enum ADDR5W {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR5W::DISABLED => false,
                    ADDR5W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reception disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDR5W::DISABLED)
            }
            #[doc = "Reception enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDR5W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDR6`"]
        pub enum ADDR6W {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR6W::DISABLED => false,
                    ADDR6W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reception disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDR6W::DISABLED)
            }
            #[doc = "Reception enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDR6W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADDR7`"]
        pub enum ADDR7W {
            #[doc = "Reception disabled."]
            DISABLED,
            #[doc = "Reception enabled."]
            ENABLED,
        }
        impl ADDR7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADDR7W::DISABLED => false,
                    ADDR7W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDR7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADDR7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reception disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADDR7W::DISABLED)
            }
            #[doc = "Reception enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADDR7W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable reception on logical address 0. Decision point: START task."]
            #[inline]
            pub fn addr0(&self) -> ADDR0R {
                ADDR0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable reception on logical address 1. Decision point: START task."]
            #[inline]
            pub fn addr1(&self) -> ADDR1R {
                ADDR1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable reception on logical address 2. Decision point: START task."]
            #[inline]
            pub fn addr2(&self) -> ADDR2R {
                ADDR2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable reception on logical address 3. Decision point: START task."]
            #[inline]
            pub fn addr3(&self) -> ADDR3R {
                ADDR3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enable reception on logical address 4. Decision point: START task."]
            #[inline]
            pub fn addr4(&self) -> ADDR4R {
                ADDR4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enable reception on logical address 5. Decision point: START task."]
            #[inline]
            pub fn addr5(&self) -> ADDR5R {
                ADDR5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enable reception on logical address 6. Decision point: START task."]
            #[inline]
            pub fn addr6(&self) -> ADDR6R {
                ADDR6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enable reception on logical address 7. Decision point: START task."]
            #[inline]
            pub fn addr7(&self) -> ADDR7R {
                ADDR7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable reception on logical address 0. Decision point: START task."]
            #[inline]
            pub fn addr0(&mut self) -> _ADDR0W {
                _ADDR0W { w: self }
            }
            #[doc = "Bit 1 - Enable reception on logical address 1. Decision point: START task."]
            #[inline]
            pub fn addr1(&mut self) -> _ADDR1W {
                _ADDR1W { w: self }
            }
            #[doc = "Bit 2 - Enable reception on logical address 2. Decision point: START task."]
            #[inline]
            pub fn addr2(&mut self) -> _ADDR2W {
                _ADDR2W { w: self }
            }
            #[doc = "Bit 3 - Enable reception on logical address 3. Decision point: START task."]
            #[inline]
            pub fn addr3(&mut self) -> _ADDR3W {
                _ADDR3W { w: self }
            }
            #[doc = "Bit 4 - Enable reception on logical address 4. Decision point: START task."]
            #[inline]
            pub fn addr4(&mut self) -> _ADDR4W {
                _ADDR4W { w: self }
            }
            #[doc = "Bit 5 - Enable reception on logical address 5. Decision point: START task."]
            #[inline]
            pub fn addr5(&mut self) -> _ADDR5W {
                _ADDR5W { w: self }
            }
            #[doc = "Bit 6 - Enable reception on logical address 6. Decision point: START task."]
            #[inline]
            pub fn addr6(&mut self) -> _ADDR6W {
                _ADDR6W { w: self }
            }
            #[doc = "Bit 7 - Enable reception on logical address 7. Decision point: START task."]
            #[inline]
            pub fn addr7(&mut self) -> _ADDR7W {
                _ADDR7W { w: self }
            }
        }
    }
    #[doc = "CRC configuration."]
    pub struct CRCCNF {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC configuration."]
    pub mod crccnf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRCCNF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LENR {
            #[doc = "CRC calculation disabled."]
            DISABLED,
            #[doc = "One byte long CRC."]
            ONE,
            #[doc = "Two bytes long CRC."]
            TWO,
            #[doc = "Three bytes long CRC."]
            THREE,
        }
        impl LENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    LENR::DISABLED => 0,
                    LENR::ONE => 0x01,
                    LENR::TWO => 0x02,
                    LENR::THREE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> LENR {
                match value {
                    0 => LENR::DISABLED,
                    1 => LENR::ONE,
                    2 => LENR::TWO,
                    3 => LENR::THREE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == LENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ONE`"]
            #[inline]
            pub fn is_one(&self) -> bool {
                *self == LENR::ONE
            }
            #[doc = "Checks if the value of the field is `TWO`"]
            #[inline]
            pub fn is_two(&self) -> bool {
                *self == LENR::TWO
            }
            #[doc = "Checks if the value of the field is `THREE`"]
            #[inline]
            pub fn is_three(&self) -> bool {
                *self == LENR::THREE
            }
        }
        #[doc = "Possible values of the field `SKIPADDR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SKIPADDRR {
            #[doc = "Include packet address in CRC calculation."]
            INCLUDE,
            #[doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address."]
            SKIP,
        }
        impl SKIPADDRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SKIPADDRR::INCLUDE => false,
                    SKIPADDRR::SKIP => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SKIPADDRR {
                match value {
                    false => SKIPADDRR::INCLUDE,
                    true => SKIPADDRR::SKIP,
                }
            }
            #[doc = "Checks if the value of the field is `INCLUDE`"]
            #[inline]
            pub fn is_include(&self) -> bool {
                *self == SKIPADDRR::INCLUDE
            }
            #[doc = "Checks if the value of the field is `SKIP`"]
            #[inline]
            pub fn is_skip(&self) -> bool {
                *self == SKIPADDRR::SKIP
            }
        }
        #[doc = "Values that can be written to the field `LEN`"]
        pub enum LENW {
            #[doc = "CRC calculation disabled."]
            DISABLED,
            #[doc = "One byte long CRC."]
            ONE,
            #[doc = "Two bytes long CRC."]
            TWO,
            #[doc = "Three bytes long CRC."]
            THREE,
        }
        impl LENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    LENW::DISABLED => 0,
                    LENW::ONE => 1,
                    LENW::TWO => 2,
                    LENW::THREE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LENW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "CRC calculation disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LENW::DISABLED)
            }
            #[doc = "One byte long CRC."]
            #[inline]
            pub fn one(self) -> &'a mut W {
                self.variant(LENW::ONE)
            }
            #[doc = "Two bytes long CRC."]
            #[inline]
            pub fn two(self) -> &'a mut W {
                self.variant(LENW::TWO)
            }
            #[doc = "Three bytes long CRC."]
            #[inline]
            pub fn three(self) -> &'a mut W {
                self.variant(LENW::THREE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SKIPADDR`"]
        pub enum SKIPADDRW {
            #[doc = "Include packet address in CRC calculation."]
            INCLUDE,
            #[doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address."]
            SKIP,
        }
        impl SKIPADDRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SKIPADDRW::INCLUDE => false,
                    SKIPADDRW::SKIP => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SKIPADDRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SKIPADDRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SKIPADDRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Include packet address in CRC calculation."]
            #[inline]
            pub fn include(self) -> &'a mut W {
                self.variant(SKIPADDRW::INCLUDE)
            }
            #[doc = "Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address."]
            #[inline]
            pub fn skip(self) -> &'a mut W {
                self.variant(SKIPADDRW::SKIP)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - CRC length. Decision point: START task."]
            #[inline]
            pub fn len(&self) -> LENR {
                LENR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 8 - Leave packet address field out of the CRC calculation. Decision point: START task."]
            #[inline]
            pub fn skipaddr(&self) -> SKIPADDRR {
                SKIPADDRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - CRC length. Decision point: START task."]
            #[inline]
            pub fn len(&mut self) -> _LENW {
                _LENW { w: self }
            }
            #[doc = "Bit 8 - Leave packet address field out of the CRC calculation. Decision point: START task."]
            #[inline]
            pub fn skipaddr(&mut self) -> _SKIPADDRW {
                _SKIPADDRW { w: self }
            }
        }
    }
    #[doc = "CRC polynomial."]
    pub struct CRCPOLY {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC polynomial."]
    pub mod crcpoly {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRCPOLY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCPOLYR {
            bits: u32,
        }
        impl CRCPOLYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCPOLYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCPOLYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - CRC polynomial. Decision point: START task."]
            #[inline]
            pub fn crcpoly(&self) -> CRCPOLYR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CRCPOLYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - CRC polynomial. Decision point: START task."]
            #[inline]
            pub fn crcpoly(&mut self) -> _CRCPOLYW {
                _CRCPOLYW { w: self }
            }
        }
    }
    #[doc = "CRC initial value."]
    pub struct CRCINIT {
        register: VolatileCell<u32>,
    }
    #[doc = "CRC initial value."]
    pub mod crcinit {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRCINIT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRCINITR {
            bits: u32,
        }
        impl CRCINITR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRCINITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRCINITW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Initial value for CRC calculation. Decision point: START task."]
            #[inline]
            pub fn crcinit(&self) -> CRCINITR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CRCINITR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Initial value for CRC calculation. Decision point: START task."]
            #[inline]
            pub fn crcinit(&mut self) -> _CRCINITW {
                _CRCINITW { w: self }
            }
        }
    }
    #[doc = "Test features enable register."]
    pub struct TEST {
        register: VolatileCell<u32>,
    }
    #[doc = "Test features enable register."]
    pub mod test {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TEST {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CONSTCARRIER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CONSTCARRIERR {
            #[doc = "Constant carrier disabled."]
            DISABLED,
            #[doc = "Constant carrier enabled."]
            ENABLED,
        }
        impl CONSTCARRIERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CONSTCARRIERR::DISABLED => false,
                    CONSTCARRIERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CONSTCARRIERR {
                match value {
                    false => CONSTCARRIERR::DISABLED,
                    true => CONSTCARRIERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CONSTCARRIERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CONSTCARRIERR::ENABLED
            }
        }
        #[doc = "Possible values of the field `PLLLOCK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLLOCKR {
            #[doc = "PLL lock disabled."]
            DISABLED,
            #[doc = "PLL lock enabled."]
            ENABLED,
        }
        impl PLLLOCKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PLLLOCKR::DISABLED => false,
                    PLLLOCKR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PLLLOCKR {
                match value {
                    false => PLLLOCKR::DISABLED,
                    true => PLLLOCKR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PLLLOCKR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PLLLOCKR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `CONSTCARRIER`"]
        pub enum CONSTCARRIERW {
            #[doc = "Constant carrier disabled."]
            DISABLED,
            #[doc = "Constant carrier enabled."]
            ENABLED,
        }
        impl CONSTCARRIERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CONSTCARRIERW::DISABLED => false,
                    CONSTCARRIERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CONSTCARRIERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CONSTCARRIERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CONSTCARRIERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Constant carrier disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CONSTCARRIERW::DISABLED)
            }
            #[doc = "Constant carrier enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CONSTCARRIERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PLLLOCK`"]
        pub enum PLLLOCKW {
            #[doc = "PLL lock disabled."]
            DISABLED,
            #[doc = "PLL lock enabled."]
            ENABLED,
        }
        impl PLLLOCKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PLLLOCKW::DISABLED => false,
                    PLLLOCKW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PLLLOCKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PLLLOCKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PLLLOCKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "PLL lock disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PLLLOCKW::DISABLED)
            }
            #[doc = "PLL lock enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PLLLOCKW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Constant carrier. Decision point: TXEN task."]
            #[inline]
            pub fn constcarrier(&self) -> CONSTCARRIERR {
                CONSTCARRIERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - PLL lock. Decision point: TXEN or RXEN task."]
            #[inline]
            pub fn plllock(&self) -> PLLLOCKR {
                PLLLOCKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Constant carrier. Decision point: TXEN task."]
            #[inline]
            pub fn constcarrier(&mut self) -> _CONSTCARRIERW {
                _CONSTCARRIERW { w: self }
            }
            #[doc = "Bit 1 - PLL lock. Decision point: TXEN or RXEN task."]
            #[inline]
            pub fn plllock(&mut self) -> _PLLLOCKW {
                _PLLLOCKW { w: self }
            }
        }
    }
    #[doc = "Inter Frame Spacing in microseconds."]
    pub struct TIFS {
        register: VolatileCell<u32>,
    }
    #[doc = "Inter Frame Spacing in microseconds."]
    pub mod tifs {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TIFS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TIFSR {
            bits: u8,
        }
        impl TIFSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIFSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIFSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Inter frame spacing in microseconds. Decision point: START rask"]
            #[inline]
            pub fn tifs(&self) -> TIFSR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TIFSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Inter frame spacing in microseconds. Decision point: START rask"]
            #[inline]
            pub fn tifs(&mut self) -> _TIFSW {
                _TIFSW { w: self }
            }
        }
    }
    #[doc = "RSSI sample."]
    pub struct RSSISAMPLE {
        register: VolatileCell<u32>,
    }
    #[doc = "RSSI sample."]
    pub mod rssisample {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RSSISAMPLE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RSSISAMPLER {
            bits: u8,
        }
        impl RSSISAMPLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm"]
            #[inline]
            pub fn rssisample(&self) -> RSSISAMPLER {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RSSISAMPLER { bits }
            }
        }
    }
    #[doc = "Current radio state."]
    pub struct STATE {
        register: VolatileCell<u32>,
    }
    #[doc = "Current radio state."]
    pub mod state {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::STATE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `STATE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STATER {
            #[doc = "Radio is in the Disabled state."]
            DISABLED,
            #[doc = "Radio is in the Rx Ramp Up state."]
            RXRU,
            #[doc = "Radio is in the Rx Idle state."]
            RXIDLE,
            #[doc = "Radio is in the Rx state."]
            RX,
            #[doc = "Radio is in the Rx Disable state."]
            RXDISABLE,
            #[doc = "Radio is in the Tx Ramp Up state."]
            TXRU,
            #[doc = "Radio is in the Tx Idle state."]
            TXIDLE,
            #[doc = "Radio is in the Tx state."]
            TX,
            #[doc = "Radio is in the Tx Disable state."]
            TXDISABLE,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl STATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    STATER::DISABLED => 0,
                    STATER::RXRU => 0x01,
                    STATER::RXIDLE => 0x02,
                    STATER::RX => 0x03,
                    STATER::RXDISABLE => 0x04,
                    STATER::TXRU => 0x09,
                    STATER::TXIDLE => 0x0a,
                    STATER::TX => 0x0b,
                    STATER::TXDISABLE => 0x0c,
                    STATER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> STATER {
                match value {
                    0 => STATER::DISABLED,
                    1 => STATER::RXRU,
                    2 => STATER::RXIDLE,
                    3 => STATER::RX,
                    4 => STATER::RXDISABLE,
                    9 => STATER::TXRU,
                    10 => STATER::TXIDLE,
                    11 => STATER::TX,
                    12 => STATER::TXDISABLE,
                    i => STATER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == STATER::DISABLED
            }
            #[doc = "Checks if the value of the field is `RXRU`"]
            #[inline]
            pub fn is_rx_ru(&self) -> bool {
                *self == STATER::RXRU
            }
            #[doc = "Checks if the value of the field is `RXIDLE`"]
            #[inline]
            pub fn is_rx_idle(&self) -> bool {
                *self == STATER::RXIDLE
            }
            #[doc = "Checks if the value of the field is `RX`"]
            #[inline]
            pub fn is_rx(&self) -> bool {
                *self == STATER::RX
            }
            #[doc = "Checks if the value of the field is `RXDISABLE`"]
            #[inline]
            pub fn is_rx_disable(&self) -> bool {
                *self == STATER::RXDISABLE
            }
            #[doc = "Checks if the value of the field is `TXRU`"]
            #[inline]
            pub fn is_tx_ru(&self) -> bool {
                *self == STATER::TXRU
            }
            #[doc = "Checks if the value of the field is `TXIDLE`"]
            #[inline]
            pub fn is_tx_idle(&self) -> bool {
                *self == STATER::TXIDLE
            }
            #[doc = "Checks if the value of the field is `TX`"]
            #[inline]
            pub fn is_tx(&self) -> bool {
                *self == STATER::TX
            }
            #[doc = "Checks if the value of the field is `TXDISABLE`"]
            #[inline]
            pub fn is_tx_disable(&self) -> bool {
                *self == STATER::TXDISABLE
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Current radio state."]
            #[inline]
            pub fn state(&self) -> STATER {
                STATER::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
    }
    #[doc = "Data whitening initial value."]
    pub struct DATAWHITEIV {
        register: VolatileCell<u32>,
    }
    #[doc = "Data whitening initial value."]
    pub mod datawhiteiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATAWHITEIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAWHITEIVR {
            bits: u8,
        }
        impl DATAWHITEIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAWHITEIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAWHITEIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task."]
            #[inline]
            pub fn datawhiteiv(&self) -> DATAWHITEIVR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAWHITEIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x40 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task."]
            #[inline]
            pub fn datawhiteiv(&mut self) -> _DATAWHITEIVW {
                _DATAWHITEIVW { w: self }
            }
        }
    }
    #[doc = "Bit counter compare."]
    pub struct BCC {
        register: VolatileCell<u32>,
    }
    #[doc = "Bit counter compare."]
    pub mod bcc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BCC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Device address base segment."]
    pub struct DAB {
        register: VolatileCell<u32>,
    }
    #[doc = "Device address base segment."]
    pub mod dab {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DAB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Device address prefix."]
    pub struct DAP {
        register: VolatileCell<u32>,
    }
    #[doc = "Device address prefix."]
    pub mod dap {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DAP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DAPR {
            bits: u16,
        }
        impl DAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DAPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Device address prefix."]
            #[inline]
            pub fn dap(&self) -> DAPR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DAPR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Device address prefix."]
            #[inline]
            pub fn dap(&mut self) -> _DAPW {
                _DAPW { w: self }
            }
        }
    }
    #[doc = "Device address match configuration."]
    pub struct DACNF {
        register: VolatileCell<u32>,
    }
    #[doc = "Device address match configuration."]
    pub mod dacnf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DACNF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA0R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA0R::DISABLED => false,
                    ENA0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA0R {
                match value {
                    false => ENA0R::DISABLED,
                    true => ENA0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENA0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENA0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENA1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA1R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA1R::DISABLED => false,
                    ENA1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA1R {
                match value {
                    false => ENA1R::DISABLED,
                    true => ENA1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENA1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENA1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENA2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA2R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA2R::DISABLED => false,
                    ENA2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA2R {
                match value {
                    false => ENA2R::DISABLED,
                    true => ENA2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENA2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENA2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENA3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA3R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA3R::DISABLED => false,
                    ENA3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA3R {
                match value {
                    false => ENA3R::DISABLED,
                    true => ENA3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENA3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENA3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENA4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA4R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA4R::DISABLED => false,
                    ENA4R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA4R {
                match value {
                    false => ENA4R::DISABLED,
                    true => ENA4R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENA4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENA4R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENA5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA5R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA5R::DISABLED => false,
                    ENA5R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA5R {
                match value {
                    false => ENA5R::DISABLED,
                    true => ENA5R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENA5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENA5R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENA6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA6R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA6R::DISABLED => false,
                    ENA6R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA6R {
                match value {
                    false => ENA6R::DISABLED,
                    true => ENA6R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENA6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENA6R::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENA7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA7R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA7R::DISABLED => false,
                    ENA7R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA7R {
                match value {
                    false => ENA7R::DISABLED,
                    true => ENA7R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENA7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENA7R::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADD0R {
            bits: bool,
        }
        impl TXADD0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADD1R {
            bits: bool,
        }
        impl TXADD1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADD2R {
            bits: bool,
        }
        impl TXADD2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADD3R {
            bits: bool,
        }
        impl TXADD3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADD4R {
            bits: bool,
        }
        impl TXADD4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADD5R {
            bits: bool,
        }
        impl TXADD5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADD6R {
            bits: bool,
        }
        impl TXADD6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXADD7R {
            bits: bool,
        }
        impl TXADD7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `ENA0`"]
        pub enum ENA0W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA0W::DISABLED => false,
                    ENA0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENA0W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENA0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA1`"]
        pub enum ENA1W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA1W::DISABLED => false,
                    ENA1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENA1W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENA1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA2`"]
        pub enum ENA2W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA2W::DISABLED => false,
                    ENA2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENA2W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENA2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA3`"]
        pub enum ENA3W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA3W::DISABLED => false,
                    ENA3W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENA3W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENA3W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA4`"]
        pub enum ENA4W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA4W::DISABLED => false,
                    ENA4W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENA4W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENA4W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA5`"]
        pub enum ENA5W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA5W::DISABLED => false,
                    ENA5W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENA5W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENA5W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA6`"]
        pub enum ENA6W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA6W::DISABLED => false,
                    ENA6W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENA6W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENA6W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA7`"]
        pub enum ENA7W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENA7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA7W::DISABLED => false,
                    ENA7W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENA7W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENA7W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADD0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADD0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADD1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADD1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADD2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADD2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADD3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADD3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADD4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADD4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADD5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADD5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADD6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADD6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXADD7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXADD7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable or disable device address matching using device address 0."]
            #[inline]
            pub fn ena0(&self) -> ENA0R {
                ENA0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable or disable device address matching using device address 1."]
            #[inline]
            pub fn ena1(&self) -> ENA1R {
                ENA1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable or disable device address matching using device address 2."]
            #[inline]
            pub fn ena2(&self) -> ENA2R {
                ENA2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable or disable device address matching using device address 3."]
            #[inline]
            pub fn ena3(&self) -> ENA3R {
                ENA3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enable or disable device address matching using device address 4."]
            #[inline]
            pub fn ena4(&self) -> ENA4R {
                ENA4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enable or disable device address matching using device address 5."]
            #[inline]
            pub fn ena5(&self) -> ENA5R {
                ENA5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enable or disable device address matching using device address 6."]
            #[inline]
            pub fn ena6(&self) -> ENA6R {
                ENA6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enable or disable device address matching using device address 7."]
            #[inline]
            pub fn ena7(&self) -> ENA7R {
                ENA7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - TxAdd for device address 0."]
            #[inline]
            pub fn txadd0(&self) -> TXADD0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXADD0R { bits }
            }
            #[doc = "Bit 9 - TxAdd for device address 1."]
            #[inline]
            pub fn txadd1(&self) -> TXADD1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXADD1R { bits }
            }
            #[doc = "Bit 10 - TxAdd for device address 2."]
            #[inline]
            pub fn txadd2(&self) -> TXADD2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXADD2R { bits }
            }
            #[doc = "Bit 11 - TxAdd for device address 3."]
            #[inline]
            pub fn txadd3(&self) -> TXADD3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXADD3R { bits }
            }
            #[doc = "Bit 12 - TxAdd for device address 4."]
            #[inline]
            pub fn txadd4(&self) -> TXADD4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXADD4R { bits }
            }
            #[doc = "Bit 13 - TxAdd for device address 5."]
            #[inline]
            pub fn txadd5(&self) -> TXADD5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXADD5R { bits }
            }
            #[doc = "Bit 14 - TxAdd for device address 6."]
            #[inline]
            pub fn txadd6(&self) -> TXADD6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXADD6R { bits }
            }
            #[doc = "Bit 15 - TxAdd for device address 7."]
            #[inline]
            pub fn txadd7(&self) -> TXADD7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXADD7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable or disable device address matching using device address 0."]
            #[inline]
            pub fn ena0(&mut self) -> _ENA0W {
                _ENA0W { w: self }
            }
            #[doc = "Bit 1 - Enable or disable device address matching using device address 1."]
            #[inline]
            pub fn ena1(&mut self) -> _ENA1W {
                _ENA1W { w: self }
            }
            #[doc = "Bit 2 - Enable or disable device address matching using device address 2."]
            #[inline]
            pub fn ena2(&mut self) -> _ENA2W {
                _ENA2W { w: self }
            }
            #[doc = "Bit 3 - Enable or disable device address matching using device address 3."]
            #[inline]
            pub fn ena3(&mut self) -> _ENA3W {
                _ENA3W { w: self }
            }
            #[doc = "Bit 4 - Enable or disable device address matching using device address 4."]
            #[inline]
            pub fn ena4(&mut self) -> _ENA4W {
                _ENA4W { w: self }
            }
            #[doc = "Bit 5 - Enable or disable device address matching using device address 5."]
            #[inline]
            pub fn ena5(&mut self) -> _ENA5W {
                _ENA5W { w: self }
            }
            #[doc = "Bit 6 - Enable or disable device address matching using device address 6."]
            #[inline]
            pub fn ena6(&mut self) -> _ENA6W {
                _ENA6W { w: self }
            }
            #[doc = "Bit 7 - Enable or disable device address matching using device address 7."]
            #[inline]
            pub fn ena7(&mut self) -> _ENA7W {
                _ENA7W { w: self }
            }
            #[doc = "Bit 8 - TxAdd for device address 0."]
            #[inline]
            pub fn txadd0(&mut self) -> _TXADD0W {
                _TXADD0W { w: self }
            }
            #[doc = "Bit 9 - TxAdd for device address 1."]
            #[inline]
            pub fn txadd1(&mut self) -> _TXADD1W {
                _TXADD1W { w: self }
            }
            #[doc = "Bit 10 - TxAdd for device address 2."]
            #[inline]
            pub fn txadd2(&mut self) -> _TXADD2W {
                _TXADD2W { w: self }
            }
            #[doc = "Bit 11 - TxAdd for device address 3."]
            #[inline]
            pub fn txadd3(&mut self) -> _TXADD3W {
                _TXADD3W { w: self }
            }
            #[doc = "Bit 12 - TxAdd for device address 4."]
            #[inline]
            pub fn txadd4(&mut self) -> _TXADD4W {
                _TXADD4W { w: self }
            }
            #[doc = "Bit 13 - TxAdd for device address 5."]
            #[inline]
            pub fn txadd5(&mut self) -> _TXADD5W {
                _TXADD5W { w: self }
            }
            #[doc = "Bit 14 - TxAdd for device address 6."]
            #[inline]
            pub fn txadd6(&mut self) -> _TXADD6W {
                _TXADD6W { w: self }
            }
            #[doc = "Bit 15 - TxAdd for device address 7."]
            #[inline]
            pub fn txadd7(&mut self) -> _TXADD7W {
                _TXADD7W { w: self }
            }
        }
    }
    #[doc = "Trim value override register 0."]
    pub struct OVERRIDE0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Trim value override register 0."]
    pub mod override0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OVERRIDE0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRIDE0R {
            bits: u32,
        }
        impl OVERRIDE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRIDE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRIDE0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Trim value override 0."]
            #[inline]
            pub fn override0(&self) -> OVERRIDE0R {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OVERRIDE0R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Trim value override 0."]
            #[inline]
            pub fn override0(&mut self) -> _OVERRIDE0W {
                _OVERRIDE0W { w: self }
            }
        }
    }
    #[doc = "Trim value override register 1."]
    pub struct OVERRIDE1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Trim value override register 1."]
    pub mod override1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OVERRIDE1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRIDE1R {
            bits: u32,
        }
        impl OVERRIDE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRIDE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRIDE1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Trim value override 1."]
            #[inline]
            pub fn override1(&self) -> OVERRIDE1R {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OVERRIDE1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Trim value override 1."]
            #[inline]
            pub fn override1(&mut self) -> _OVERRIDE1W {
                _OVERRIDE1W { w: self }
            }
        }
    }
    #[doc = "Trim value override register 2."]
    pub struct OVERRIDE2 {
        register: VolatileCell<u32>,
    }
    #[doc = "Trim value override register 2."]
    pub mod override2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OVERRIDE2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRIDE2R {
            bits: u32,
        }
        impl OVERRIDE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRIDE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRIDE2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Trim value override 2."]
            #[inline]
            pub fn override2(&self) -> OVERRIDE2R {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OVERRIDE2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Trim value override 2."]
            #[inline]
            pub fn override2(&mut self) -> _OVERRIDE2W {
                _OVERRIDE2W { w: self }
            }
        }
    }
    #[doc = "Trim value override register 3."]
    pub struct OVERRIDE3 {
        register: VolatileCell<u32>,
    }
    #[doc = "Trim value override register 3."]
    pub mod override3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OVERRIDE3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRIDE3R {
            bits: u32,
        }
        impl OVERRIDE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRIDE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRIDE3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Trim value override 3."]
            #[inline]
            pub fn override3(&self) -> OVERRIDE3R {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OVERRIDE3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Trim value override 3."]
            #[inline]
            pub fn override3(&mut self) -> _OVERRIDE3W {
                _OVERRIDE3W { w: self }
            }
        }
    }
    #[doc = "Trim value override register 4."]
    pub struct OVERRIDE4 {
        register: VolatileCell<u32>,
    }
    #[doc = "Trim value override register 4."]
    pub mod override4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OVERRIDE4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRIDE4R {
            bits: u32,
        }
        impl OVERRIDE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Override trim values disabled."]
            DISABLED,
            #[doc = "Override trim values enabled."]
            ENABLED,
        }
        impl ENABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENABLER::DISABLED => false,
                    ENABLER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENABLER {
                match value {
                    false => ENABLER::DISABLED,
                    true => ENABLER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRIDE4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRIDE4W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0fff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Override trim values disabled."]
            DISABLED,
            #[doc = "Override trim values enabled."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENABLEW::DISABLED => false,
                    ENABLEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Override trim values disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Override trim values enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:27 - Trim value override 4."]
            #[inline]
            pub fn override4(&self) -> OVERRIDE4R {
                let bits = {
                    const MASK: u32 = 0x0fff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                OVERRIDE4R { bits }
            }
            #[doc = "Bit 31 - Enable or disable override of default trim values."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:27 - Trim value override 4."]
            #[inline]
            pub fn override4(&mut self) -> _OVERRIDE4W {
                _OVERRIDE4W { w: self }
            }
            #[doc = "Bit 31 - Enable or disable override of default trim values."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter."]
pub struct UART0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART0 {}
impl UART0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uart0::RegisterBlock {
        0x4000_2000 as *const _
    }
}
impl Deref for UART0 {
    type Target = uart0::RegisterBlock;
    fn deref(&self) -> &uart0::RegisterBlock {
        unsafe { &*UART0::ptr() }
    }
}
#[doc = "Universal Asynchronous Receiver/Transmitter."]
pub mod uart0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start UART receiver."]
        pub tasks_startrx: TASKS_STARTRX,
        #[doc = "0x04 - Stop UART receiver."]
        pub tasks_stoprx: TASKS_STOPRX,
        #[doc = "0x08 - Start UART transmitter."]
        pub tasks_starttx: TASKS_STARTTX,
        #[doc = "0x0c - Stop UART transmitter."]
        pub tasks_stoptx: TASKS_STOPTX,
        _reserved0: [u8; 12usize],
        #[doc = "0x1c - Suspend UART."]
        pub tasks_suspend: TASKS_SUSPEND,
        _reserved1: [u8; 224usize],
        #[doc = "0x100 - CTS activated."]
        pub events_cts: EVENTS_CTS,
        #[doc = "0x104 - CTS deactivated."]
        pub events_ncts: EVENTS_NCTS,
        #[doc = "0x108 - Data received in RXD."]
        pub events_rxdrdy: EVENTS_RXDRDY,
        _reserved2: [u8; 16usize],
        #[doc = "0x11c - Data sent from TXD."]
        pub events_txdrdy: EVENTS_TXDRDY,
        _reserved3: [u8; 4usize],
        #[doc = "0x124 - Error detected."]
        pub events_error: EVENTS_ERROR,
        _reserved4: [u8; 28usize],
        #[doc = "0x144 - Receiver timeout."]
        pub events_rxto: EVENTS_RXTO,
        _reserved5: [u8; 184usize],
        #[doc = "0x200 - Shortcuts for UART."]
        pub shorts: SHORTS,
        _reserved6: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved7: [u8; 372usize],
        #[doc = "0x480 - Error source. Write error field to 1 to clear error."]
        pub errorsrc: ERRORSRC,
        _reserved8: [u8; 124usize],
        #[doc = "0x500 - Enable UART and acquire IOs."]
        pub enable: ENABLE,
        _reserved9: [u8; 4usize],
        #[doc = "0x508 - Pin select for RTS."]
        pub pselrts: PSELRTS,
        #[doc = "0x50c - Pin select for TXD."]
        pub pseltxd: PSELTXD,
        #[doc = "0x510 - Pin select for CTS."]
        pub pselcts: PSELCTS,
        #[doc = "0x514 - Pin select for RXD."]
        pub pselrxd: PSELRXD,
        #[doc = "0x518 - RXD register. On read action the buffer pointer is displaced. Once read the character is consumed. If read when no character available, the UART will stop working."]
        pub rxd: RXD,
        #[doc = "0x51c - TXD register."]
        pub txd: TXD,
        _reserved10: [u8; 4usize],
        #[doc = "0x524 - UART Baudrate."]
        pub baudrate: BAUDRATE,
        _reserved11: [u8; 68usize],
        #[doc = "0x56c - Configuration of parity and hardware flow control register."]
        pub config: CONFIG,
        _reserved12: [u8; 2700usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start UART receiver."]
    pub struct TASKS_STARTRX {
        register: VolatileCell<u32>,
    }
    #[doc = "Start UART receiver."]
    pub mod tasks_startrx {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STARTRX {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop UART receiver."]
    pub struct TASKS_STOPRX {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop UART receiver."]
    pub mod tasks_stoprx {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOPRX {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start UART transmitter."]
    pub struct TASKS_STARTTX {
        register: VolatileCell<u32>,
    }
    #[doc = "Start UART transmitter."]
    pub mod tasks_starttx {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STARTTX {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop UART transmitter."]
    pub struct TASKS_STOPTX {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop UART transmitter."]
    pub mod tasks_stoptx {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOPTX {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Suspend UART."]
    pub struct TASKS_SUSPEND {
        register: VolatileCell<u32>,
    }
    #[doc = "Suspend UART."]
    pub mod tasks_suspend {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_SUSPEND {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "CTS activated."]
    pub struct EVENTS_CTS {
        register: VolatileCell<u32>,
    }
    #[doc = "CTS activated."]
    pub mod events_cts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_CTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "CTS deactivated."]
    pub struct EVENTS_NCTS {
        register: VolatileCell<u32>,
    }
    #[doc = "CTS deactivated."]
    pub mod events_ncts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_NCTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Data received in RXD."]
    pub struct EVENTS_RXDRDY {
        register: VolatileCell<u32>,
    }
    #[doc = "Data received in RXD."]
    pub mod events_rxdrdy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_RXDRDY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Data sent from TXD."]
    pub struct EVENTS_TXDRDY {
        register: VolatileCell<u32>,
    }
    #[doc = "Data sent from TXD."]
    pub mod events_txdrdy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_TXDRDY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Error detected."]
    pub struct EVENTS_ERROR {
        register: VolatileCell<u32>,
    }
    #[doc = "Error detected."]
    pub mod events_error {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ERROR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Receiver timeout."]
    pub struct EVENTS_RXTO {
        register: VolatileCell<u32>,
    }
    #[doc = "Receiver timeout."]
    pub mod events_rxto {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_RXTO {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for UART."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for UART."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CTS_STARTRX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTS_STARTRXR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl CTS_STARTRXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CTS_STARTRXR::DISABLED => false,
                    CTS_STARTRXR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CTS_STARTRXR {
                match value {
                    false => CTS_STARTRXR::DISABLED,
                    true => CTS_STARTRXR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CTS_STARTRXR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CTS_STARTRXR::ENABLED
            }
        }
        #[doc = "Possible values of the field `NCTS_STOPRX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NCTS_STOPRXR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl NCTS_STOPRXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    NCTS_STOPRXR::DISABLED => false,
                    NCTS_STOPRXR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> NCTS_STOPRXR {
                match value {
                    false => NCTS_STOPRXR::DISABLED,
                    true => NCTS_STOPRXR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == NCTS_STOPRXR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == NCTS_STOPRXR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `CTS_STARTRX`"]
        pub enum CTS_STARTRXW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl CTS_STARTRXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTS_STARTRXW::DISABLED => false,
                    CTS_STARTRXW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTS_STARTRXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTS_STARTRXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTS_STARTRXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTS_STARTRXW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTS_STARTRXW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `NCTS_STOPRX`"]
        pub enum NCTS_STOPRXW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl NCTS_STOPRXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    NCTS_STOPRXW::DISABLED => false,
                    NCTS_STOPRXW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NCTS_STOPRXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NCTS_STOPRXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NCTS_STOPRXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NCTS_STOPRXW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NCTS_STOPRXW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 3 - Shortcut between CTS event and STARTRX task."]
            #[inline]
            pub fn cts_startrx(&self) -> CTS_STARTRXR {
                CTS_STARTRXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Shortcut between NCTS event and STOPRX task."]
            #[inline]
            pub fn ncts_stoprx(&self) -> NCTS_STOPRXR {
                NCTS_STOPRXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 3 - Shortcut between CTS event and STARTRX task."]
            #[inline]
            pub fn cts_startrx(&mut self) -> _CTS_STARTRXW {
                _CTS_STARTRXW { w: self }
            }
            #[doc = "Bit 4 - Shortcut between NCTS event and STOPRX task."]
            #[inline]
            pub fn ncts_stoprx(&mut self) -> _NCTS_STOPRXW {
                _NCTS_STOPRXW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CTS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl CTSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CTSR::DISABLED => false,
                    CTSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CTSR {
                match value {
                    false => CTSR::DISABLED,
                    true => CTSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CTSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CTSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `NCTS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NCTSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl NCTSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    NCTSR::DISABLED => false,
                    NCTSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> NCTSR {
                match value {
                    false => NCTSR::DISABLED,
                    true => NCTSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == NCTSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == NCTSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RXDRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDRDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RXDRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXDRDYR::DISABLED => false,
                    RXDRDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXDRDYR {
                match value {
                    false => RXDRDYR::DISABLED,
                    true => RXDRDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RXDRDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RXDRDYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `TXDRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDRDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl TXDRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXDRDYR::DISABLED => false,
                    TXDRDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXDRDYR {
                match value {
                    false => TXDRDYR::DISABLED,
                    true => TXDRDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TXDRDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TXDRDYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ERROR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRORR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ERRORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERRORR::DISABLED => false,
                    ERRORR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERRORR {
                match value {
                    false => ERRORR::DISABLED,
                    true => ERRORR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ERRORR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ERRORR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RXTO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXTOR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RXTOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXTOR::DISABLED => false,
                    RXTOR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXTOR {
                match value {
                    false => RXTOR::DISABLED,
                    true => RXTOR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RXTOR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RXTOR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `CTS`"]
        pub enum CTSW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl CTSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTSW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CTSW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `NCTS`"]
        pub enum NCTSW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl NCTSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    NCTSW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NCTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NCTSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NCTSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(NCTSW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXDRDY`"]
        pub enum RXDRDYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl RXDRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXDRDYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXDRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXDRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXDRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(RXDRDYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDRDY`"]
        pub enum TXDRDYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl TXDRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXDRDYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXDRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(TXDRDYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ERROR`"]
        pub enum ERRORW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ERRORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERRORW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERRORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ERRORW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXTO`"]
        pub enum RXTOW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl RXTOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXTOW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXTOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXTOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXTOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(RXTOW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on CTS event."]
            #[inline]
            pub fn cts(&self) -> CTSR {
                CTSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on NCTS event."]
            #[inline]
            pub fn ncts(&self) -> NCTSR {
                NCTSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable interrupt on RXRDY event."]
            #[inline]
            pub fn rxdrdy(&self) -> RXDRDYR {
                RXDRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enable interrupt on TXRDY event."]
            #[inline]
            pub fn txdrdy(&self) -> TXDRDYR {
                TXDRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Enable interrupt on ERROR event."]
            #[inline]
            pub fn error(&self) -> ERRORR {
                ERRORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Enable interrupt on RXTO event."]
            #[inline]
            pub fn rxto(&self) -> RXTOR {
                RXTOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on CTS event."]
            #[inline]
            pub fn cts(&mut self) -> _CTSW {
                _CTSW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on NCTS event."]
            #[inline]
            pub fn ncts(&mut self) -> _NCTSW {
                _NCTSW { w: self }
            }
            #[doc = "Bit 2 - Enable interrupt on RXRDY event."]
            #[inline]
            pub fn rxdrdy(&mut self) -> _RXDRDYW {
                _RXDRDYW { w: self }
            }
            #[doc = "Bit 7 - Enable interrupt on TXRDY event."]
            #[inline]
            pub fn txdrdy(&mut self) -> _TXDRDYW {
                _TXDRDYW { w: self }
            }
            #[doc = "Bit 9 - Enable interrupt on ERROR event."]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
            #[doc = "Bit 17 - Enable interrupt on RXTO event."]
            #[inline]
            pub fn rxto(&mut self) -> _RXTOW {
                _RXTOW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CTS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl CTSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CTSR::DISABLED => false,
                    CTSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CTSR {
                match value {
                    false => CTSR::DISABLED,
                    true => CTSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CTSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CTSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `NCTS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NCTSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl NCTSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    NCTSR::DISABLED => false,
                    NCTSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> NCTSR {
                match value {
                    false => NCTSR::DISABLED,
                    true => NCTSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == NCTSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == NCTSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RXDRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDRDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RXDRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXDRDYR::DISABLED => false,
                    RXDRDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXDRDYR {
                match value {
                    false => RXDRDYR::DISABLED,
                    true => RXDRDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RXDRDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RXDRDYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `TXDRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDRDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl TXDRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXDRDYR::DISABLED => false,
                    TXDRDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXDRDYR {
                match value {
                    false => TXDRDYR::DISABLED,
                    true => TXDRDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TXDRDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TXDRDYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ERROR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRORR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ERRORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERRORR::DISABLED => false,
                    ERRORR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERRORR {
                match value {
                    false => ERRORR::DISABLED,
                    true => ERRORR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ERRORR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ERRORR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RXTO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXTOR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RXTOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXTOR::DISABLED => false,
                    RXTOR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXTOR {
                match value {
                    false => RXTOR::DISABLED,
                    true => RXTOR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RXTOR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RXTOR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `CTS`"]
        pub enum CTSW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl CTSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTSW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTSW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `NCTS`"]
        pub enum NCTSW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl NCTSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    NCTSW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NCTSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NCTSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NCTSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(NCTSW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXDRDY`"]
        pub enum RXDRDYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl RXDRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXDRDYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXDRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXDRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXDRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(RXDRDYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDRDY`"]
        pub enum TXDRDYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl TXDRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXDRDYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXDRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(TXDRDYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ERROR`"]
        pub enum ERRORW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ERRORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERRORW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERRORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ERRORW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXTO`"]
        pub enum RXTOW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl RXTOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXTOW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXTOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXTOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXTOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(RXTOW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on CTS event."]
            #[inline]
            pub fn cts(&self) -> CTSR {
                CTSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on NCTS event."]
            #[inline]
            pub fn ncts(&self) -> NCTSR {
                NCTSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable interrupt on RXRDY event."]
            #[inline]
            pub fn rxdrdy(&self) -> RXDRDYR {
                RXDRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Disable interrupt on TXRDY event."]
            #[inline]
            pub fn txdrdy(&self) -> TXDRDYR {
                TXDRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Disable interrupt on ERROR event."]
            #[inline]
            pub fn error(&self) -> ERRORR {
                ERRORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Disable interrupt on RXTO event."]
            #[inline]
            pub fn rxto(&self) -> RXTOR {
                RXTOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on CTS event."]
            #[inline]
            pub fn cts(&mut self) -> _CTSW {
                _CTSW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on NCTS event."]
            #[inline]
            pub fn ncts(&mut self) -> _NCTSW {
                _NCTSW { w: self }
            }
            #[doc = "Bit 2 - Disable interrupt on RXRDY event."]
            #[inline]
            pub fn rxdrdy(&mut self) -> _RXDRDYW {
                _RXDRDYW { w: self }
            }
            #[doc = "Bit 7 - Disable interrupt on TXRDY event."]
            #[inline]
            pub fn txdrdy(&mut self) -> _TXDRDYW {
                _TXDRDYW { w: self }
            }
            #[doc = "Bit 9 - Disable interrupt on ERROR event."]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
            #[doc = "Bit 17 - Disable interrupt on RXTO event."]
            #[inline]
            pub fn rxto(&mut self) -> _RXTOW {
                _RXTOW { w: self }
            }
        }
    }
    #[doc = "Error source. Write error field to 1 to clear error."]
    pub struct ERRORSRC {
        register: VolatileCell<u32>,
    }
    #[doc = "Error source. Write error field to 1 to clear error."]
    pub mod errorsrc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ERRORSRC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `OVERRUN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVERRUNR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl OVERRUNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVERRUNR::NOTPRESENT => false,
                    OVERRUNR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVERRUNR {
                match value {
                    false => OVERRUNR::NOTPRESENT,
                    true => OVERRUNR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == OVERRUNR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == OVERRUNR::PRESENT
            }
        }
        #[doc = "Possible values of the field `PARITY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PARITYR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl PARITYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PARITYR::NOTPRESENT => false,
                    PARITYR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PARITYR {
                match value {
                    false => PARITYR::NOTPRESENT,
                    true => PARITYR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == PARITYR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == PARITYR::PRESENT
            }
        }
        #[doc = "Possible values of the field `FRAMING`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FRAMINGR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl FRAMINGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FRAMINGR::NOTPRESENT => false,
                    FRAMINGR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FRAMINGR {
                match value {
                    false => FRAMINGR::NOTPRESENT,
                    true => FRAMINGR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == FRAMINGR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == FRAMINGR::PRESENT
            }
        }
        #[doc = "Possible values of the field `BREAK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BREAKR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl BREAKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BREAKR::NOTPRESENT => false,
                    BREAKR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BREAKR {
                match value {
                    false => BREAKR::NOTPRESENT,
                    true => BREAKR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == BREAKR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == BREAKR::PRESENT
            }
        }
        #[doc = "Values that can be written to the field `OVERRUN`"]
        pub enum OVERRUNW {
            #[doc = "Clear error on write."]
            CLEAR,
        }
        impl OVERRUNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVERRUNW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVERRUNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear error on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVERRUNW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PARITY`"]
        pub enum PARITYW {
            #[doc = "Clear error on write."]
            CLEAR,
        }
        impl PARITYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PARITYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PARITYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear error on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PARITYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FRAMING`"]
        pub enum FRAMINGW {
            #[doc = "Clear error on write."]
            CLEAR,
        }
        impl FRAMINGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FRAMINGW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAMINGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAMINGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FRAMINGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear error on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(FRAMINGW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BREAK`"]
        pub enum BREAKW {
            #[doc = "Clear error on write."]
            CLEAR,
        }
        impl BREAKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BREAKW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BREAKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BREAKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BREAKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear error on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(BREAKW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - A start bit is received while the previous data still lies in RXD. (Data loss)."]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                OVERRUNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - A character with bad parity is received. Only checked if HW parity control is enabled."]
            #[inline]
            pub fn parity(&self) -> PARITYR {
                PARITYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - A valid stop bit is not detected on the serial data input after all bits in a character have been received."]
            #[inline]
            pub fn framing(&self) -> FRAMINGR {
                FRAMINGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - The serial data input is '0' for longer than the length of a data frame."]
            #[inline]
            pub fn break_(&self) -> BREAKR {
                BREAKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - A start bit is received while the previous data still lies in RXD. (Data loss)."]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 1 - A character with bad parity is received. Only checked if HW parity control is enabled."]
            #[inline]
            pub fn parity(&mut self) -> _PARITYW {
                _PARITYW { w: self }
            }
            #[doc = "Bit 2 - A valid stop bit is not detected on the serial data input after all bits in a character have been received."]
            #[inline]
            pub fn framing(&mut self) -> _FRAMINGW {
                _FRAMINGW { w: self }
            }
            #[doc = "Bit 3 - The serial data input is '0' for longer than the length of a data frame."]
            #[inline]
            pub fn break_(&mut self) -> _BREAKW {
                _BREAKW { w: self }
            }
        }
    }
    #[doc = "Enable UART and acquire IOs."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable UART and acquire IOs."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "UART disabled."]
            DISABLED,
            #[doc = "UART enabled."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x04,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    4 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "UART disabled."]
            DISABLED,
            #[doc = "UART enabled."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 4,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "UART disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "UART enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Enable or disable UART and acquire IOs."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Enable or disable UART and acquire IOs."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Pin select for RTS."]
    pub struct PSELRTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for RTS."]
    pub mod pselrts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELRTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for TXD."]
    pub struct PSELTXD {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for TXD."]
    pub mod pseltxd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELTXD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for CTS."]
    pub struct PSELCTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for CTS."]
    pub mod pselcts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELCTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for RXD."]
    pub struct PSELRXD {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for RXD."]
    pub mod pselrxd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELRXD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "RXD register. On read action the buffer pointer is displaced. Once read the character is consumed. If read when no character available, the UART will stop working."]
    pub struct RXD {
        register: VolatileCell<u32>,
    }
    #[doc = "RXD register. On read action the buffer pointer is displaced. Once read the character is consumed. If read when no character available, the UART will stop working."]
    pub mod rxd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXD {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDR {
            bits: u8,
        }
        impl RXDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - RX data from previous transfer. Double buffered."]
            #[inline]
            pub fn rxd(&self) -> RXDR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RXDR { bits }
            }
        }
    }
    #[doc = "TXD register."]
    pub struct TXD {
        register: VolatileCell<u32>,
    }
    #[doc = "TXD register."]
    pub mod txd {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXD {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - TX data for transfer."]
            #[inline]
            pub fn txd(&mut self) -> _TXDW {
                _TXDW { w: self }
            }
        }
    }
    #[doc = "UART Baudrate."]
    pub struct BAUDRATE {
        register: VolatileCell<u32>,
    }
    #[doc = "UART Baudrate."]
    pub mod baudrate {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BAUDRATE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BAUDRATE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BAUDRATER {
            #[doc = "1200 baud."]
            BAUD1200,
            #[doc = "2400 baud."]
            BAUD2400,
            #[doc = "4800 baud."]
            BAUD4800,
            #[doc = "9600 baud."]
            BAUD9600,
            #[doc = "14400 baud."]
            BAUD14400,
            #[doc = "19200 baud."]
            BAUD19200,
            #[doc = "28800 baud."]
            BAUD28800,
            #[doc = "38400 baud."]
            BAUD38400,
            #[doc = "57600 baud."]
            BAUD57600,
            #[doc = "76800 baud."]
            BAUD76800,
            #[doc = "115200 baud."]
            BAUD115200,
            #[doc = "230400 baud."]
            BAUD230400,
            #[doc = "250000 baud."]
            BAUD250000,
            #[doc = "460800 baud."]
            BAUD460800,
            #[doc = "921600 baud."]
            BAUD921600,
            #[doc = "1M baud."]
            BAUD1M,
            #[doc = r" Reserved"]
            _Reserved(u32),
        }
        impl BAUDRATER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                match *self {
                    BAUDRATER::BAUD1200 => 0x0004_f000,
                    BAUDRATER::BAUD2400 => 0x0009_d000,
                    BAUDRATER::BAUD4800 => 0x0013_b000,
                    BAUDRATER::BAUD9600 => 0x0027_5000,
                    BAUDRATER::BAUD14400 => 0x003b_0000,
                    BAUDRATER::BAUD19200 => 0x004e_a000,
                    BAUDRATER::BAUD28800 => 0x0075_f000,
                    BAUDRATER::BAUD38400 => 0x009d_5000,
                    BAUDRATER::BAUD57600 => 0x00eb_f000,
                    BAUDRATER::BAUD76800 => 0x013a_9000,
                    BAUDRATER::BAUD115200 => 0x01d7_e000,
                    BAUDRATER::BAUD230400 => 0x03af_b000,
                    BAUDRATER::BAUD250000 => 0x0400_0000,
                    BAUDRATER::BAUD460800 => 0x075f_7000,
                    BAUDRATER::BAUD921600 => 0x0ebe_d000,
                    BAUDRATER::BAUD1M => 0x1000_0000,
                    BAUDRATER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u32) -> BAUDRATER {
                match value {
                    323584 => BAUDRATER::BAUD1200,
                    643072 => BAUDRATER::BAUD2400,
                    1290240 => BAUDRATER::BAUD4800,
                    2576384 => BAUDRATER::BAUD9600,
                    3866624 => BAUDRATER::BAUD14400,
                    5152768 => BAUDRATER::BAUD19200,
                    7729152 => BAUDRATER::BAUD28800,
                    10309632 => BAUDRATER::BAUD38400,
                    15462400 => BAUDRATER::BAUD57600,
                    20615168 => BAUDRATER::BAUD76800,
                    30924800 => BAUDRATER::BAUD115200,
                    61845504 => BAUDRATER::BAUD230400,
                    67108864 => BAUDRATER::BAUD250000,
                    123695104 => BAUDRATER::BAUD460800,
                    247386112 => BAUDRATER::BAUD921600,
                    268435456 => BAUDRATER::BAUD1M,
                    i => BAUDRATER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `BAUD1200`"]
            #[inline]
            pub fn is_baud1200(&self) -> bool {
                *self == BAUDRATER::BAUD1200
            }
            #[doc = "Checks if the value of the field is `BAUD2400`"]
            #[inline]
            pub fn is_baud2400(&self) -> bool {
                *self == BAUDRATER::BAUD2400
            }
            #[doc = "Checks if the value of the field is `BAUD4800`"]
            #[inline]
            pub fn is_baud4800(&self) -> bool {
                *self == BAUDRATER::BAUD4800
            }
            #[doc = "Checks if the value of the field is `BAUD9600`"]
            #[inline]
            pub fn is_baud9600(&self) -> bool {
                *self == BAUDRATER::BAUD9600
            }
            #[doc = "Checks if the value of the field is `BAUD14400`"]
            #[inline]
            pub fn is_baud14400(&self) -> bool {
                *self == BAUDRATER::BAUD14400
            }
            #[doc = "Checks if the value of the field is `BAUD19200`"]
            #[inline]
            pub fn is_baud19200(&self) -> bool {
                *self == BAUDRATER::BAUD19200
            }
            #[doc = "Checks if the value of the field is `BAUD28800`"]
            #[inline]
            pub fn is_baud28800(&self) -> bool {
                *self == BAUDRATER::BAUD28800
            }
            #[doc = "Checks if the value of the field is `BAUD38400`"]
            #[inline]
            pub fn is_baud38400(&self) -> bool {
                *self == BAUDRATER::BAUD38400
            }
            #[doc = "Checks if the value of the field is `BAUD57600`"]
            #[inline]
            pub fn is_baud57600(&self) -> bool {
                *self == BAUDRATER::BAUD57600
            }
            #[doc = "Checks if the value of the field is `BAUD76800`"]
            #[inline]
            pub fn is_baud76800(&self) -> bool {
                *self == BAUDRATER::BAUD76800
            }
            #[doc = "Checks if the value of the field is `BAUD115200`"]
            #[inline]
            pub fn is_baud115200(&self) -> bool {
                *self == BAUDRATER::BAUD115200
            }
            #[doc = "Checks if the value of the field is `BAUD230400`"]
            #[inline]
            pub fn is_baud230400(&self) -> bool {
                *self == BAUDRATER::BAUD230400
            }
            #[doc = "Checks if the value of the field is `BAUD250000`"]
            #[inline]
            pub fn is_baud250000(&self) -> bool {
                *self == BAUDRATER::BAUD250000
            }
            #[doc = "Checks if the value of the field is `BAUD460800`"]
            #[inline]
            pub fn is_baud460800(&self) -> bool {
                *self == BAUDRATER::BAUD460800
            }
            #[doc = "Checks if the value of the field is `BAUD921600`"]
            #[inline]
            pub fn is_baud921600(&self) -> bool {
                *self == BAUDRATER::BAUD921600
            }
            #[doc = "Checks if the value of the field is `BAUD1M`"]
            #[inline]
            pub fn is_baud1m(&self) -> bool {
                *self == BAUDRATER::BAUD1M
            }
        }
        #[doc = "Values that can be written to the field `BAUDRATE`"]
        pub enum BAUDRATEW {
            #[doc = "1200 baud."]
            BAUD1200,
            #[doc = "2400 baud."]
            BAUD2400,
            #[doc = "4800 baud."]
            BAUD4800,
            #[doc = "9600 baud."]
            BAUD9600,
            #[doc = "14400 baud."]
            BAUD14400,
            #[doc = "19200 baud."]
            BAUD19200,
            #[doc = "28800 baud."]
            BAUD28800,
            #[doc = "38400 baud."]
            BAUD38400,
            #[doc = "57600 baud."]
            BAUD57600,
            #[doc = "76800 baud."]
            BAUD76800,
            #[doc = "115200 baud."]
            BAUD115200,
            #[doc = "230400 baud."]
            BAUD230400,
            #[doc = "250000 baud."]
            BAUD250000,
            #[doc = "460800 baud."]
            BAUD460800,
            #[doc = "921600 baud."]
            BAUD921600,
            #[doc = "1M baud."]
            BAUD1M,
        }
        impl BAUDRATEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u32 {
                match *self {
                    BAUDRATEW::BAUD1200 => 323584,
                    BAUDRATEW::BAUD2400 => 643072,
                    BAUDRATEW::BAUD4800 => 1290240,
                    BAUDRATEW::BAUD9600 => 2576384,
                    BAUDRATEW::BAUD14400 => 3866624,
                    BAUDRATEW::BAUD19200 => 5152768,
                    BAUDRATEW::BAUD28800 => 7729152,
                    BAUDRATEW::BAUD38400 => 10309632,
                    BAUDRATEW::BAUD57600 => 15462400,
                    BAUDRATEW::BAUD76800 => 20615168,
                    BAUDRATEW::BAUD115200 => 30924800,
                    BAUDRATEW::BAUD230400 => 61845504,
                    BAUDRATEW::BAUD250000 => 67108864,
                    BAUDRATEW::BAUD460800 => 123695104,
                    BAUDRATEW::BAUD921600 => 247386112,
                    BAUDRATEW::BAUD1M => 268435456,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BAUDRATEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BAUDRATEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BAUDRATEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "1200 baud."]
            #[inline]
            pub fn baud1200(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD1200)
            }
            #[doc = "2400 baud."]
            #[inline]
            pub fn baud2400(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD2400)
            }
            #[doc = "4800 baud."]
            #[inline]
            pub fn baud4800(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD4800)
            }
            #[doc = "9600 baud."]
            #[inline]
            pub fn baud9600(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD9600)
            }
            #[doc = "14400 baud."]
            #[inline]
            pub fn baud14400(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD14400)
            }
            #[doc = "19200 baud."]
            #[inline]
            pub fn baud19200(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD19200)
            }
            #[doc = "28800 baud."]
            #[inline]
            pub fn baud28800(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD28800)
            }
            #[doc = "38400 baud."]
            #[inline]
            pub fn baud38400(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD38400)
            }
            #[doc = "57600 baud."]
            #[inline]
            pub fn baud57600(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD57600)
            }
            #[doc = "76800 baud."]
            #[inline]
            pub fn baud76800(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD76800)
            }
            #[doc = "115200 baud."]
            #[inline]
            pub fn baud115200(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD115200)
            }
            #[doc = "230400 baud."]
            #[inline]
            pub fn baud230400(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD230400)
            }
            #[doc = "250000 baud."]
            #[inline]
            pub fn baud250000(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD250000)
            }
            #[doc = "460800 baud."]
            #[inline]
            pub fn baud460800(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD460800)
            }
            #[doc = "921600 baud."]
            #[inline]
            pub fn baud921600(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD921600)
            }
            #[doc = "1M baud."]
            #[inline]
            pub fn baud1m(self) -> &'a mut W {
                self.variant(BAUDRATEW::BAUD1M)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - UART baudrate."]
            #[inline]
            pub fn baudrate(&self) -> BAUDRATER {
                BAUDRATER::_from({
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - UART baudrate."]
            #[inline]
            pub fn baudrate(&mut self) -> _BAUDRATEW {
                _BAUDRATEW { w: self }
            }
        }
    }
    #[doc = "Configuration of parity and hardware flow control register."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration of parity and hardware flow control register."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `HWFC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HWFCR {
            #[doc = "Hardware flow control disabled."]
            DISABLED,
            #[doc = "Hardware flow control enabled."]
            ENABLED,
        }
        impl HWFCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HWFCR::DISABLED => false,
                    HWFCR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HWFCR {
                match value {
                    false => HWFCR::DISABLED,
                    true => HWFCR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == HWFCR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == HWFCR::ENABLED
            }
        }
        #[doc = "Possible values of the field `PARITY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PARITYR {
            #[doc = "Parity bit excluded."]
            EXCLUDED,
            #[doc = "Parity bit included."]
            INCLUDED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PARITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PARITYR::EXCLUDED => 0,
                    PARITYR::INCLUDED => 0x07,
                    PARITYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PARITYR {
                match value {
                    0 => PARITYR::EXCLUDED,
                    7 => PARITYR::INCLUDED,
                    i => PARITYR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == PARITYR::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == PARITYR::INCLUDED
            }
        }
        #[doc = "Values that can be written to the field `HWFC`"]
        pub enum HWFCW {
            #[doc = "Hardware flow control disabled."]
            DISABLED,
            #[doc = "Hardware flow control enabled."]
            ENABLED,
        }
        impl HWFCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HWFCW::DISABLED => false,
                    HWFCW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HWFCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HWFCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HWFCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Hardware flow control disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(HWFCW::DISABLED)
            }
            #[doc = "Hardware flow control enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(HWFCW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PARITY`"]
        pub enum PARITYW {
            #[doc = "Parity bit excluded."]
            EXCLUDED,
            #[doc = "Parity bit included."]
            INCLUDED,
        }
        impl PARITYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PARITYW::EXCLUDED => 0,
                    PARITYW::INCLUDED => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PARITYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PARITYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PARITYW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Parity bit excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(PARITYW::EXCLUDED)
            }
            #[doc = "Parity bit included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(PARITYW::INCLUDED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Hardware flow control."]
            #[inline]
            pub fn hwfc(&self) -> HWFCR {
                HWFCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:3 - Include parity bit."]
            #[inline]
            pub fn parity(&self) -> PARITYR {
                PARITYR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Hardware flow control."]
            #[inline]
            pub fn hwfc(&mut self) -> _HWFCW {
                _HWFCW { w: self }
            }
            #[doc = "Bits 1:3 - Include parity bit."]
            #[inline]
            pub fn parity(&mut self) -> _PARITYW {
                _PARITYW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "SPI master 0."]
pub struct SPI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI0 {}
impl SPI0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi0::RegisterBlock {
        0x4000_3000 as *const _
    }
}
impl Deref for SPI0 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        unsafe { &*SPI0::ptr() }
    }
}
#[doc = "SPI master 0."]
pub mod spi0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 264usize],
        #[doc = "0x108 - TXD byte sent and RXD byte received."]
        pub events_ready: EVENTS_READY,
        _reserved1: [u8; 504usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved2: [u8; 500usize],
        #[doc = "0x500 - Enable SPI."]
        pub enable: ENABLE,
        _reserved3: [u8; 4usize],
        #[doc = "0x508 - Pin select for SCK."]
        pub pselsck: PSELSCK,
        #[doc = "0x50c - Pin select for MOSI."]
        pub pselmosi: PSELMOSI,
        #[doc = "0x510 - Pin select for MISO."]
        pub pselmiso: PSELMISO,
        _reserved4: [u8; 4usize],
        #[doc = "0x518 - RX data."]
        pub rxd: RXD,
        #[doc = "0x51c - TX data."]
        pub txd: TXD,
        _reserved5: [u8; 4usize],
        #[doc = "0x524 - SPI frequency"]
        pub frequency: FREQUENCY,
        _reserved6: [u8; 44usize],
        #[doc = "0x554 - Configuration register."]
        pub config: CONFIG,
        _reserved7: [u8; 2724usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "TXD byte sent and RXD byte received."]
    pub struct EVENTS_READY {
        register: VolatileCell<u32>,
    }
    #[doc = "TXD byte sent and RXD byte received."]
    pub mod events_ready {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_READY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `READY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl READYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READYR::DISABLED => false,
                    READYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READYR {
                match value {
                    false => READYR::DISABLED,
                    true => READYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READYR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `READY`"]
        pub enum READYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl READYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(READYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Enable interrupt on READY event."]
            #[inline]
            pub fn ready(&self) -> READYR {
                READYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Enable interrupt on READY event."]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `READY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl READYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READYR::DISABLED => false,
                    READYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READYR {
                match value {
                    false => READYR::DISABLED,
                    true => READYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READYR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `READY`"]
        pub enum READYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl READYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(READYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Disable interrupt on READY event."]
            #[inline]
            pub fn ready(&self) -> READYR {
                READYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Disable interrupt on READY event."]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
        }
    }
    #[doc = "Enable SPI."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable SPI."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled SPI."]
            DISABLED,
            #[doc = "Enable SPI."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x01,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    1 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled SPI."]
            DISABLED,
            #[doc = "Enable SPI."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled SPI."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enable SPI."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Enable or disable SPI."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Enable or disable SPI."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Pin select for SCK."]
    pub struct PSELSCK {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for SCK."]
    pub mod pselsck {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELSCK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for MOSI."]
    pub struct PSELMOSI {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for MOSI."]
    pub mod pselmosi {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELMOSI {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for MISO."]
    pub struct PSELMISO {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for MISO."]
    pub mod pselmiso {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELMISO {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "RX data."]
    pub struct RXD {
        register: VolatileCell<u32>,
    }
    #[doc = "RX data."]
    pub mod rxd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXD {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDR {
            bits: u8,
        }
        impl RXDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - RX data from last transfer."]
            #[inline]
            pub fn rxd(&self) -> RXDR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RXDR { bits }
            }
        }
    }
    #[doc = "TX data."]
    pub struct TXD {
        register: VolatileCell<u32>,
    }
    #[doc = "TX data."]
    pub mod txd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDR {
            bits: u8,
        }
        impl TXDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - TX data for next transfer."]
            #[inline]
            pub fn txd(&self) -> TXDR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TXDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - TX data for next transfer."]
            #[inline]
            pub fn txd(&mut self) -> _TXDW {
                _TXDW { w: self }
            }
        }
    }
    #[doc = "SPI frequency"]
    pub struct FREQUENCY {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI frequency"]
    pub mod frequency {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FREQUENCY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FREQUENCY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQUENCYR {
            #[doc = "125kbps."]
            K125,
            #[doc = "250kbps."]
            K250,
            #[doc = "500kbps."]
            K500,
            #[doc = "1Mbps."]
            M1,
            #[doc = "2Mbps."]
            M2,
            #[doc = "4Mbps."]
            M4,
            #[doc = "8Mbps."]
            M8,
            #[doc = r" Reserved"]
            _Reserved(u32),
        }
        impl FREQUENCYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                match *self {
                    FREQUENCYR::K125 => 0x0200_0000,
                    FREQUENCYR::K250 => 0x0400_0000,
                    FREQUENCYR::K500 => 0x0800_0000,
                    FREQUENCYR::M1 => 0x1000_0000,
                    FREQUENCYR::M2 => 0x2000_0000,
                    FREQUENCYR::M4 => 0x4000_0000,
                    FREQUENCYR::M8 => 0x8000_0000,
                    FREQUENCYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u32) -> FREQUENCYR {
                match value {
                    33554432 => FREQUENCYR::K125,
                    67108864 => FREQUENCYR::K250,
                    134217728 => FREQUENCYR::K500,
                    268435456 => FREQUENCYR::M1,
                    536870912 => FREQUENCYR::M2,
                    1073741824 => FREQUENCYR::M4,
                    2147483648 => FREQUENCYR::M8,
                    i => FREQUENCYR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `K125`"]
            #[inline]
            pub fn is_k125(&self) -> bool {
                *self == FREQUENCYR::K125
            }
            #[doc = "Checks if the value of the field is `K250`"]
            #[inline]
            pub fn is_k250(&self) -> bool {
                *self == FREQUENCYR::K250
            }
            #[doc = "Checks if the value of the field is `K500`"]
            #[inline]
            pub fn is_k500(&self) -> bool {
                *self == FREQUENCYR::K500
            }
            #[doc = "Checks if the value of the field is `M1`"]
            #[inline]
            pub fn is_m1(&self) -> bool {
                *self == FREQUENCYR::M1
            }
            #[doc = "Checks if the value of the field is `M2`"]
            #[inline]
            pub fn is_m2(&self) -> bool {
                *self == FREQUENCYR::M2
            }
            #[doc = "Checks if the value of the field is `M4`"]
            #[inline]
            pub fn is_m4(&self) -> bool {
                *self == FREQUENCYR::M4
            }
            #[doc = "Checks if the value of the field is `M8`"]
            #[inline]
            pub fn is_m8(&self) -> bool {
                *self == FREQUENCYR::M8
            }
        }
        #[doc = "Values that can be written to the field `FREQUENCY`"]
        pub enum FREQUENCYW {
            #[doc = "125kbps."]
            K125,
            #[doc = "250kbps."]
            K250,
            #[doc = "500kbps."]
            K500,
            #[doc = "1Mbps."]
            M1,
            #[doc = "2Mbps."]
            M2,
            #[doc = "4Mbps."]
            M4,
            #[doc = "8Mbps."]
            M8,
        }
        impl FREQUENCYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u32 {
                match *self {
                    FREQUENCYW::K125 => 33554432,
                    FREQUENCYW::K250 => 67108864,
                    FREQUENCYW::K500 => 134217728,
                    FREQUENCYW::M1 => 268435456,
                    FREQUENCYW::M2 => 536870912,
                    FREQUENCYW::M4 => 1073741824,
                    FREQUENCYW::M8 => 2147483648,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQUENCYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQUENCYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FREQUENCYW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "125kbps."]
            #[inline]
            pub fn k125(self) -> &'a mut W {
                self.variant(FREQUENCYW::K125)
            }
            #[doc = "250kbps."]
            #[inline]
            pub fn k250(self) -> &'a mut W {
                self.variant(FREQUENCYW::K250)
            }
            #[doc = "500kbps."]
            #[inline]
            pub fn k500(self) -> &'a mut W {
                self.variant(FREQUENCYW::K500)
            }
            #[doc = "1Mbps."]
            #[inline]
            pub fn m1(self) -> &'a mut W {
                self.variant(FREQUENCYW::M1)
            }
            #[doc = "2Mbps."]
            #[inline]
            pub fn m2(self) -> &'a mut W {
                self.variant(FREQUENCYW::M2)
            }
            #[doc = "4Mbps."]
            #[inline]
            pub fn m4(self) -> &'a mut W {
                self.variant(FREQUENCYW::M4)
            }
            #[doc = "8Mbps."]
            #[inline]
            pub fn m8(self) -> &'a mut W {
                self.variant(FREQUENCYW::M8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - SPI data rate."]
            #[inline]
            pub fn frequency(&self) -> FREQUENCYR {
                FREQUENCYR::_from({
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0400_0000 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - SPI data rate."]
            #[inline]
            pub fn frequency(&mut self) -> _FREQUENCYW {
                _FREQUENCYW { w: self }
            }
        }
    }
    #[doc = "Configuration register."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration register."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ORDER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ORDERR {
            #[doc = "Most significant bit transmitted out first."]
            MSBFIRST,
            #[doc = "Least significant bit transmitted out first."]
            LSBFIRST,
        }
        impl ORDERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ORDERR::MSBFIRST => false,
                    ORDERR::LSBFIRST => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ORDERR {
                match value {
                    false => ORDERR::MSBFIRST,
                    true => ORDERR::LSBFIRST,
                }
            }
            #[doc = "Checks if the value of the field is `MSBFIRST`"]
            #[inline]
            pub fn is_msb_first(&self) -> bool {
                *self == ORDERR::MSBFIRST
            }
            #[doc = "Checks if the value of the field is `LSBFIRST`"]
            #[inline]
            pub fn is_lsb_first(&self) -> bool {
                *self == ORDERR::LSBFIRST
            }
        }
        #[doc = "Possible values of the field `CPHA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHAR {
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            LEADING,
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            TRAILING,
        }
        impl CPHAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPHAR::LEADING => false,
                    CPHAR::TRAILING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPHAR {
                match value {
                    false => CPHAR::LEADING,
                    true => CPHAR::TRAILING,
                }
            }
            #[doc = "Checks if the value of the field is `LEADING`"]
            #[inline]
            pub fn is_leading(&self) -> bool {
                *self == CPHAR::LEADING
            }
            #[doc = "Checks if the value of the field is `TRAILING`"]
            #[inline]
            pub fn is_trailing(&self) -> bool {
                *self == CPHAR::TRAILING
            }
        }
        #[doc = "Possible values of the field `CPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOLR {
            #[doc = "Active high."]
            ACTIVEHIGH,
            #[doc = "Active low."]
            ACTIVELOW,
        }
        impl CPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPOLR::ACTIVEHIGH => false,
                    CPOLR::ACTIVELOW => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPOLR {
                match value {
                    false => CPOLR::ACTIVEHIGH,
                    true => CPOLR::ACTIVELOW,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVEHIGH`"]
            #[inline]
            pub fn is_active_high(&self) -> bool {
                *self == CPOLR::ACTIVEHIGH
            }
            #[doc = "Checks if the value of the field is `ACTIVELOW`"]
            #[inline]
            pub fn is_active_low(&self) -> bool {
                *self == CPOLR::ACTIVELOW
            }
        }
        #[doc = "Values that can be written to the field `ORDER`"]
        pub enum ORDERW {
            #[doc = "Most significant bit transmitted out first."]
            MSBFIRST,
            #[doc = "Least significant bit transmitted out first."]
            LSBFIRST,
        }
        impl ORDERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ORDERW::MSBFIRST => false,
                    ORDERW::LSBFIRST => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ORDERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ORDERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ORDERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Most significant bit transmitted out first."]
            #[inline]
            pub fn msb_first(self) -> &'a mut W {
                self.variant(ORDERW::MSBFIRST)
            }
            #[doc = "Least significant bit transmitted out first."]
            #[inline]
            pub fn lsb_first(self) -> &'a mut W {
                self.variant(ORDERW::LSBFIRST)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPHA`"]
        pub enum CPHAW {
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            LEADING,
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            TRAILING,
        }
        impl CPHAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPHAW::LEADING => false,
                    CPHAW::TRAILING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPHAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPHAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPHAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            #[inline]
            pub fn leading(self) -> &'a mut W {
                self.variant(CPHAW::LEADING)
            }
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            #[inline]
            pub fn trailing(self) -> &'a mut W {
                self.variant(CPHAW::TRAILING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPOL`"]
        pub enum CPOLW {
            #[doc = "Active high."]
            ACTIVEHIGH,
            #[doc = "Active low."]
            ACTIVELOW,
        }
        impl CPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPOLW::ACTIVEHIGH => false,
                    CPOLW::ACTIVELOW => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Active high."]
            #[inline]
            pub fn active_high(self) -> &'a mut W {
                self.variant(CPOLW::ACTIVEHIGH)
            }
            #[doc = "Active low."]
            #[inline]
            pub fn active_low(self) -> &'a mut W {
                self.variant(CPOLW::ACTIVELOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Bit order."]
            #[inline]
            pub fn order(&self) -> ORDERR {
                ORDERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Serial clock (SCK) phase."]
            #[inline]
            pub fn cpha(&self) -> CPHAR {
                CPHAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Serial clock (SCK) polarity."]
            #[inline]
            pub fn cpol(&self) -> CPOLR {
                CPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Bit order."]
            #[inline]
            pub fn order(&mut self) -> _ORDERW {
                _ORDERW { w: self }
            }
            #[doc = "Bit 1 - Serial clock (SCK) phase."]
            #[inline]
            pub fn cpha(&mut self) -> _CPHAW {
                _CPHAW { w: self }
            }
            #[doc = "Bit 2 - Serial clock (SCK) polarity."]
            #[inline]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Two-wire interface master 0."]
pub struct TWI0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TWI0 {}
impl TWI0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const twi0::RegisterBlock {
        0x4000_3000 as *const _
    }
}
impl Deref for TWI0 {
    type Target = twi0::RegisterBlock;
    fn deref(&self) -> &twi0::RegisterBlock {
        unsafe { &*TWI0::ptr() }
    }
}
#[doc = "Two-wire interface master 0."]
pub mod twi0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start 2-Wire master receive sequence."]
        pub tasks_startrx: TASKS_STARTRX,
        _reserved0: [u8; 4usize],
        #[doc = "0x08 - Start 2-Wire master transmit sequence."]
        pub tasks_starttx: TASKS_STARTTX,
        _reserved1: [u8; 8usize],
        #[doc = "0x14 - Stop 2-Wire transaction."]
        pub tasks_stop: TASKS_STOP,
        _reserved2: [u8; 4usize],
        #[doc = "0x1c - Suspend 2-Wire transaction."]
        pub tasks_suspend: TASKS_SUSPEND,
        #[doc = "0x20 - Resume 2-Wire transaction."]
        pub tasks_resume: TASKS_RESUME,
        _reserved3: [u8; 224usize],
        #[doc = "0x104 - Two-wire stopped."]
        pub events_stopped: EVENTS_STOPPED,
        #[doc = "0x108 - Two-wire ready to deliver new RXD byte received."]
        pub events_rxdready: EVENTS_RXDREADY,
        _reserved4: [u8; 16usize],
        #[doc = "0x11c - Two-wire finished sending last TXD byte."]
        pub events_txdsent: EVENTS_TXDSENT,
        _reserved5: [u8; 4usize],
        #[doc = "0x124 - Two-wire error detected."]
        pub events_error: EVENTS_ERROR,
        _reserved6: [u8; 16usize],
        #[doc = "0x138 - Two-wire byte boundary."]
        pub events_bb: EVENTS_BB,
        _reserved7: [u8; 12usize],
        #[doc = "0x148 - Two-wire suspended."]
        pub events_suspended: EVENTS_SUSPENDED,
        _reserved8: [u8; 180usize],
        #[doc = "0x200 - Shortcuts for TWI."]
        pub shorts: SHORTS,
        _reserved9: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved10: [u8; 440usize],
        #[doc = "0x4c4 - Two-wire error source. Write error field to 1 to clear error."]
        pub errorsrc: ERRORSRC,
        _reserved11: [u8; 56usize],
        #[doc = "0x500 - Enable two-wire master."]
        pub enable: ENABLE,
        _reserved12: [u8; 4usize],
        #[doc = "0x508 - Pin select for SCL."]
        pub pselscl: PSELSCL,
        #[doc = "0x50c - Pin select for SDA."]
        pub pselsda: PSELSDA,
        _reserved13: [u8; 8usize],
        #[doc = "0x518 - RX data register."]
        pub rxd: RXD,
        #[doc = "0x51c - TX data register."]
        pub txd: TXD,
        _reserved14: [u8; 4usize],
        #[doc = "0x524 - Two-wire frequency."]
        pub frequency: FREQUENCY,
        _reserved15: [u8; 96usize],
        #[doc = "0x588 - Address used in the two-wire transfer."]
        pub address: ADDRESS,
        _reserved16: [u8; 2672usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start 2-Wire master receive sequence."]
    pub struct TASKS_STARTRX {
        register: VolatileCell<u32>,
    }
    #[doc = "Start 2-Wire master receive sequence."]
    pub mod tasks_startrx {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STARTRX {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start 2-Wire master transmit sequence."]
    pub struct TASKS_STARTTX {
        register: VolatileCell<u32>,
    }
    #[doc = "Start 2-Wire master transmit sequence."]
    pub mod tasks_starttx {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STARTTX {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop 2-Wire transaction."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop 2-Wire transaction."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Suspend 2-Wire transaction."]
    pub struct TASKS_SUSPEND {
        register: VolatileCell<u32>,
    }
    #[doc = "Suspend 2-Wire transaction."]
    pub mod tasks_suspend {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_SUSPEND {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Resume 2-Wire transaction."]
    pub struct TASKS_RESUME {
        register: VolatileCell<u32>,
    }
    #[doc = "Resume 2-Wire transaction."]
    pub mod tasks_resume {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_RESUME {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Two-wire stopped."]
    pub struct EVENTS_STOPPED {
        register: VolatileCell<u32>,
    }
    #[doc = "Two-wire stopped."]
    pub mod events_stopped {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_STOPPED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Two-wire ready to deliver new RXD byte received."]
    pub struct EVENTS_RXDREADY {
        register: VolatileCell<u32>,
    }
    #[doc = "Two-wire ready to deliver new RXD byte received."]
    pub mod events_rxdready {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_RXDREADY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Two-wire finished sending last TXD byte."]
    pub struct EVENTS_TXDSENT {
        register: VolatileCell<u32>,
    }
    #[doc = "Two-wire finished sending last TXD byte."]
    pub mod events_txdsent {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_TXDSENT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Two-wire error detected."]
    pub struct EVENTS_ERROR {
        register: VolatileCell<u32>,
    }
    #[doc = "Two-wire error detected."]
    pub mod events_error {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ERROR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Two-wire byte boundary."]
    pub struct EVENTS_BB {
        register: VolatileCell<u32>,
    }
    #[doc = "Two-wire byte boundary."]
    pub mod events_bb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_BB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Two-wire suspended."]
    pub struct EVENTS_SUSPENDED {
        register: VolatileCell<u32>,
    }
    #[doc = "Two-wire suspended."]
    pub mod events_suspended {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_SUSPENDED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for TWI."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for TWI."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BB_SUSPEND`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BB_SUSPENDR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl BB_SUSPENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BB_SUSPENDR::DISABLED => false,
                    BB_SUSPENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BB_SUSPENDR {
                match value {
                    false => BB_SUSPENDR::DISABLED,
                    true => BB_SUSPENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BB_SUSPENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BB_SUSPENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `BB_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BB_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl BB_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BB_STOPR::DISABLED => false,
                    BB_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BB_STOPR {
                match value {
                    false => BB_STOPR::DISABLED,
                    true => BB_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BB_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BB_STOPR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `BB_SUSPEND`"]
        pub enum BB_SUSPENDW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl BB_SUSPENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BB_SUSPENDW::DISABLED => false,
                    BB_SUSPENDW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BB_SUSPENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BB_SUSPENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BB_SUSPENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BB_SUSPENDW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BB_SUSPENDW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BB_STOP`"]
        pub enum BB_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl BB_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BB_STOPW::DISABLED => false,
                    BB_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BB_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BB_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BB_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BB_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BB_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Shortcut between BB event and the SUSPEND task."]
            #[inline]
            pub fn bb_suspend(&self) -> BB_SUSPENDR {
                BB_SUSPENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Shortcut between BB event and the STOP task."]
            #[inline]
            pub fn bb_stop(&self) -> BB_STOPR {
                BB_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Shortcut between BB event and the SUSPEND task."]
            #[inline]
            pub fn bb_suspend(&mut self) -> _BB_SUSPENDW {
                _BB_SUSPENDW { w: self }
            }
            #[doc = "Bit 1 - Shortcut between BB event and the STOP task."]
            #[inline]
            pub fn bb_stop(&mut self) -> _BB_STOPW {
                _BB_STOPW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `STOPPED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPPEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl STOPPEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STOPPEDR::DISABLED => false,
                    STOPPEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STOPPEDR {
                match value {
                    false => STOPPEDR::DISABLED,
                    true => STOPPEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == STOPPEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == STOPPEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RXDREADY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDREADYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RXDREADYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXDREADYR::DISABLED => false,
                    RXDREADYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXDREADYR {
                match value {
                    false => RXDREADYR::DISABLED,
                    true => RXDREADYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RXDREADYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RXDREADYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `TXDSENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDSENTR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl TXDSENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXDSENTR::DISABLED => false,
                    TXDSENTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXDSENTR {
                match value {
                    false => TXDSENTR::DISABLED,
                    true => TXDSENTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TXDSENTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TXDSENTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ERROR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRORR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ERRORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERRORR::DISABLED => false,
                    ERRORR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERRORR {
                match value {
                    false => ERRORR::DISABLED,
                    true => ERRORR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ERRORR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ERRORR::ENABLED
            }
        }
        #[doc = "Possible values of the field `BB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BBR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl BBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BBR::DISABLED => false,
                    BBR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BBR {
                match value {
                    false => BBR::DISABLED,
                    true => BBR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BBR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BBR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SUSPENDED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SUSPENDEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl SUSPENDEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SUSPENDEDR::DISABLED => false,
                    SUSPENDEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SUSPENDEDR {
                match value {
                    false => SUSPENDEDR::DISABLED,
                    true => SUSPENDEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SUSPENDEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SUSPENDEDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `STOPPED`"]
        pub enum STOPPEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl STOPPEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STOPPEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPPEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPPEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STOPPEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(STOPPEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXDREADY`"]
        pub enum RXDREADYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl RXDREADYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXDREADYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXDREADYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXDREADYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXDREADYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(RXDREADYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDSENT`"]
        pub enum TXDSENTW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl TXDSENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXDSENTW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDSENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDSENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXDSENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(TXDSENTW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ERROR`"]
        pub enum ERRORW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ERRORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERRORW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERRORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ERRORW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BB`"]
        pub enum BBW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl BBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BBW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(BBW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SUSPENDED`"]
        pub enum SUSPENDEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl SUSPENDEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SUSPENDEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SUSPENDEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SUSPENDEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SUSPENDEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(SUSPENDEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Enable interrupt on STOPPED event."]
            #[inline]
            pub fn stopped(&self) -> STOPPEDR {
                STOPPEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable interrupt on READY event."]
            #[inline]
            pub fn rxdready(&self) -> RXDREADYR {
                RXDREADYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enable interrupt on TXDSENT event."]
            #[inline]
            pub fn txdsent(&self) -> TXDSENTR {
                TXDSENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Enable interrupt on ERROR event."]
            #[inline]
            pub fn error(&self) -> ERRORR {
                ERRORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Enable interrupt on BB event."]
            #[inline]
            pub fn bb(&self) -> BBR {
                BBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Enable interrupt on SUSPENDED event."]
            #[inline]
            pub fn suspended(&self) -> SUSPENDEDR {
                SUSPENDEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable interrupt on STOPPED event."]
            #[inline]
            pub fn stopped(&mut self) -> _STOPPEDW {
                _STOPPEDW { w: self }
            }
            #[doc = "Bit 2 - Enable interrupt on READY event."]
            #[inline]
            pub fn rxdready(&mut self) -> _RXDREADYW {
                _RXDREADYW { w: self }
            }
            #[doc = "Bit 7 - Enable interrupt on TXDSENT event."]
            #[inline]
            pub fn txdsent(&mut self) -> _TXDSENTW {
                _TXDSENTW { w: self }
            }
            #[doc = "Bit 9 - Enable interrupt on ERROR event."]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
            #[doc = "Bit 14 - Enable interrupt on BB event."]
            #[inline]
            pub fn bb(&mut self) -> _BBW {
                _BBW { w: self }
            }
            #[doc = "Bit 18 - Enable interrupt on SUSPENDED event."]
            #[inline]
            pub fn suspended(&mut self) -> _SUSPENDEDW {
                _SUSPENDEDW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `STOPPED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPPEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl STOPPEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STOPPEDR::DISABLED => false,
                    STOPPEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STOPPEDR {
                match value {
                    false => STOPPEDR::DISABLED,
                    true => STOPPEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == STOPPEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == STOPPEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RXDREADY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDREADYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RXDREADYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXDREADYR::DISABLED => false,
                    RXDREADYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXDREADYR {
                match value {
                    false => RXDREADYR::DISABLED,
                    true => RXDREADYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RXDREADYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RXDREADYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `TXDSENT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDSENTR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl TXDSENTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TXDSENTR::DISABLED => false,
                    TXDSENTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TXDSENTR {
                match value {
                    false => TXDSENTR::DISABLED,
                    true => TXDSENTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TXDSENTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TXDSENTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ERROR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRORR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ERRORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERRORR::DISABLED => false,
                    ERRORR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERRORR {
                match value {
                    false => ERRORR::DISABLED,
                    true => ERRORR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ERRORR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ERRORR::ENABLED
            }
        }
        #[doc = "Possible values of the field `BB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BBR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl BBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BBR::DISABLED => false,
                    BBR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BBR {
                match value {
                    false => BBR::DISABLED,
                    true => BBR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == BBR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == BBR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SUSPENDED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SUSPENDEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl SUSPENDEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SUSPENDEDR::DISABLED => false,
                    SUSPENDEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SUSPENDEDR {
                match value {
                    false => SUSPENDEDR::DISABLED,
                    true => SUSPENDEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SUSPENDEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SUSPENDEDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `STOPPED`"]
        pub enum STOPPEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl STOPPEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STOPPEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPPEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPPEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STOPPEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(STOPPEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXDREADY`"]
        pub enum RXDREADYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl RXDREADYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXDREADYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXDREADYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXDREADYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXDREADYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(RXDREADYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXDSENT`"]
        pub enum TXDSENTW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl TXDSENTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXDSENTW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDSENTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDSENTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXDSENTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(TXDSENTW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ERROR`"]
        pub enum ERRORW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ERRORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERRORW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERRORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ERRORW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BB`"]
        pub enum BBW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl BBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BBW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(BBW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SUSPENDED`"]
        pub enum SUSPENDEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl SUSPENDEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SUSPENDEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SUSPENDEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SUSPENDEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SUSPENDEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(SUSPENDEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Disable interrupt on STOPPED event."]
            #[inline]
            pub fn stopped(&self) -> STOPPEDR {
                STOPPEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable interrupt on RXDREADY event."]
            #[inline]
            pub fn rxdready(&self) -> RXDREADYR {
                RXDREADYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Disable interrupt on TXDSENT event."]
            #[inline]
            pub fn txdsent(&self) -> TXDSENTR {
                TXDSENTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Disable interrupt on ERROR event."]
            #[inline]
            pub fn error(&self) -> ERRORR {
                ERRORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Disable interrupt on BB event."]
            #[inline]
            pub fn bb(&self) -> BBR {
                BBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Disable interrupt on SUSPENDED event."]
            #[inline]
            pub fn suspended(&self) -> SUSPENDEDR {
                SUSPENDEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Disable interrupt on STOPPED event."]
            #[inline]
            pub fn stopped(&mut self) -> _STOPPEDW {
                _STOPPEDW { w: self }
            }
            #[doc = "Bit 2 - Disable interrupt on RXDREADY event."]
            #[inline]
            pub fn rxdready(&mut self) -> _RXDREADYW {
                _RXDREADYW { w: self }
            }
            #[doc = "Bit 7 - Disable interrupt on TXDSENT event."]
            #[inline]
            pub fn txdsent(&mut self) -> _TXDSENTW {
                _TXDSENTW { w: self }
            }
            #[doc = "Bit 9 - Disable interrupt on ERROR event."]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
            #[doc = "Bit 14 - Disable interrupt on BB event."]
            #[inline]
            pub fn bb(&mut self) -> _BBW {
                _BBW { w: self }
            }
            #[doc = "Bit 18 - Disable interrupt on SUSPENDED event."]
            #[inline]
            pub fn suspended(&mut self) -> _SUSPENDEDW {
                _SUSPENDEDW { w: self }
            }
        }
    }
    #[doc = "Two-wire error source. Write error field to 1 to clear error."]
    pub struct ERRORSRC {
        register: VolatileCell<u32>,
    }
    #[doc = "Two-wire error source. Write error field to 1 to clear error."]
    pub mod errorsrc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ERRORSRC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `OVERRUN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVERRUNR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl OVERRUNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVERRUNR::NOTPRESENT => false,
                    OVERRUNR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVERRUNR {
                match value {
                    false => OVERRUNR::NOTPRESENT,
                    true => OVERRUNR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == OVERRUNR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == OVERRUNR::PRESENT
            }
        }
        #[doc = "Possible values of the field `ANACK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ANACKR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl ANACKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ANACKR::NOTPRESENT => false,
                    ANACKR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ANACKR {
                match value {
                    false => ANACKR::NOTPRESENT,
                    true => ANACKR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == ANACKR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == ANACKR::PRESENT
            }
        }
        #[doc = "Possible values of the field `DNACK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DNACKR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl DNACKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DNACKR::NOTPRESENT => false,
                    DNACKR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DNACKR {
                match value {
                    false => DNACKR::NOTPRESENT,
                    true => DNACKR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == DNACKR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == DNACKR::PRESENT
            }
        }
        #[doc = "Values that can be written to the field `OVERRUN`"]
        pub enum OVERRUNW {
            #[doc = "Clear error on write."]
            CLEAR,
        }
        impl OVERRUNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVERRUNW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVERRUNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear error on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVERRUNW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ANACK`"]
        pub enum ANACKW {
            #[doc = "Clear error on write."]
            CLEAR,
        }
        impl ANACKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ANACKW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ANACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ANACKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ANACKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear error on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ANACKW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DNACK`"]
        pub enum DNACKW {
            #[doc = "Clear error on write."]
            CLEAR,
        }
        impl DNACKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DNACKW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DNACKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DNACKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DNACKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear error on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(DNACKW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Byte received in RXD register before read of the last received byte (data loss)."]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                OVERRUNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - NACK received after sending the address."]
            #[inline]
            pub fn anack(&self) -> ANACKR {
                ANACKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - NACK received after sending a data byte."]
            #[inline]
            pub fn dnack(&self) -> DNACKR {
                DNACKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Byte received in RXD register before read of the last received byte (data loss)."]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 1 - NACK received after sending the address."]
            #[inline]
            pub fn anack(&mut self) -> _ANACKW {
                _ANACKW { w: self }
            }
            #[doc = "Bit 2 - NACK received after sending a data byte."]
            #[inline]
            pub fn dnack(&mut self) -> _DNACKW {
                _DNACKW { w: self }
            }
        }
    }
    #[doc = "Enable two-wire master."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable two-wire master."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x05,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    5 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Enable or disable W2M"]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Enable or disable W2M"]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Pin select for SCL."]
    pub struct PSELSCL {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for SCL."]
    pub mod pselscl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELSCL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for SDA."]
    pub struct PSELSDA {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for SDA."]
    pub mod pselsda {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELSDA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "RX data register."]
    pub struct RXD {
        register: VolatileCell<u32>,
    }
    #[doc = "RX data register."]
    pub mod rxd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXD {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXDR {
            bits: u8,
        }
        impl RXDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - RX data from last transfer."]
            #[inline]
            pub fn rxd(&self) -> RXDR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RXDR { bits }
            }
        }
    }
    #[doc = "TX data register."]
    pub struct TXD {
        register: VolatileCell<u32>,
    }
    #[doc = "TX data register."]
    pub mod txd {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXDR {
            bits: u8,
        }
        impl TXDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - TX data for next transfer."]
            #[inline]
            pub fn txd(&self) -> TXDR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TXDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - TX data for next transfer."]
            #[inline]
            pub fn txd(&mut self) -> _TXDW {
                _TXDW { w: self }
            }
        }
    }
    #[doc = "Two-wire frequency."]
    pub struct FREQUENCY {
        register: VolatileCell<u32>,
    }
    #[doc = "Two-wire frequency."]
    pub mod frequency {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FREQUENCY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FREQUENCY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQUENCYR {
            #[doc = "100 kbps."]
            K100,
            #[doc = "250 kbps."]
            K250,
            #[doc = "400 kbps."]
            K400,
            #[doc = r" Reserved"]
            _Reserved(u32),
        }
        impl FREQUENCYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                match *self {
                    FREQUENCYR::K100 => 0x0198_0000,
                    FREQUENCYR::K250 => 0x0400_0000,
                    FREQUENCYR::K400 => 0x0668_0000,
                    FREQUENCYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u32) -> FREQUENCYR {
                match value {
                    26738688 => FREQUENCYR::K100,
                    67108864 => FREQUENCYR::K250,
                    107479040 => FREQUENCYR::K400,
                    i => FREQUENCYR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `K100`"]
            #[inline]
            pub fn is_k100(&self) -> bool {
                *self == FREQUENCYR::K100
            }
            #[doc = "Checks if the value of the field is `K250`"]
            #[inline]
            pub fn is_k250(&self) -> bool {
                *self == FREQUENCYR::K250
            }
            #[doc = "Checks if the value of the field is `K400`"]
            #[inline]
            pub fn is_k400(&self) -> bool {
                *self == FREQUENCYR::K400
            }
        }
        #[doc = "Values that can be written to the field `FREQUENCY`"]
        pub enum FREQUENCYW {
            #[doc = "100 kbps."]
            K100,
            #[doc = "250 kbps."]
            K250,
            #[doc = "400 kbps."]
            K400,
        }
        impl FREQUENCYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u32 {
                match *self {
                    FREQUENCYW::K100 => 26738688,
                    FREQUENCYW::K250 => 67108864,
                    FREQUENCYW::K400 => 107479040,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQUENCYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQUENCYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FREQUENCYW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "100 kbps."]
            #[inline]
            pub fn k100(self) -> &'a mut W {
                self.variant(FREQUENCYW::K100)
            }
            #[doc = "250 kbps."]
            #[inline]
            pub fn k250(self) -> &'a mut W {
                self.variant(FREQUENCYW::K250)
            }
            #[doc = "400 kbps."]
            #[inline]
            pub fn k400(self) -> &'a mut W {
                self.variant(FREQUENCYW::K400)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Two-wire master clock frequency."]
            #[inline]
            pub fn frequency(&self) -> FREQUENCYR {
                FREQUENCYR::_from({
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0400_0000 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Two-wire master clock frequency."]
            #[inline]
            pub fn frequency(&mut self) -> _FREQUENCYW {
                _FREQUENCYW { w: self }
            }
        }
    }
    #[doc = "Address used in the two-wire transfer."]
    pub struct ADDRESS {
        register: VolatileCell<u32>,
    }
    #[doc = "Address used in the two-wire transfer."]
    pub mod address {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADDRESS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRESSR {
            bits: u8,
        }
        impl ADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:6 - Two-wire address."]
            #[inline]
            pub fn address(&self) -> ADDRESSR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDRESSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:6 - Two-wire address."]
            #[inline]
            pub fn address(&mut self) -> _ADDRESSW {
                _ADDRESSW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "SPI master 1."]
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spi0::RegisterBlock {
        0x4000_4000 as *const _
    }
}
impl Deref for SPI1 {
    type Target = spi0::RegisterBlock;
    fn deref(&self) -> &spi0::RegisterBlock {
        unsafe { &*SPI1::ptr() }
    }
}
#[doc = "Two-wire interface master 1."]
pub struct TWI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TWI1 {}
impl TWI1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const twi0::RegisterBlock {
        0x4000_4000 as *const _
    }
}
impl Deref for TWI1 {
    type Target = twi0::RegisterBlock;
    fn deref(&self) -> &twi0::RegisterBlock {
        unsafe { &*TWI1::ptr() }
    }
}
#[doc = "SPI slave 1."]
pub struct SPIS1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPIS1 {}
impl SPIS1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spis1::RegisterBlock {
        0x4000_4000 as *const _
    }
}
impl Deref for SPIS1 {
    type Target = spis1::RegisterBlock;
    fn deref(&self) -> &spis1::RegisterBlock {
        unsafe { &*SPIS1::ptr() }
    }
}
#[doc = "SPI slave 1."]
pub mod spis1 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 36usize],
        #[doc = "0x24 - Acquire SPI semaphore."]
        pub tasks_acquire: TASKS_ACQUIRE,
        #[doc = "0x28 - Release SPI semaphore."]
        pub tasks_release: TASKS_RELEASE,
        _reserved1: [u8; 216usize],
        #[doc = "0x104 - Granted transaction completed."]
        pub events_end: EVENTS_END,
        _reserved2: [u8; 32usize],
        #[doc = "0x128 - Semaphore acquired."]
        pub events_acquired: EVENTS_ACQUIRED,
        _reserved3: [u8; 212usize],
        #[doc = "0x200 - Shortcuts for SPIS."]
        pub shorts: SHORTS,
        _reserved4: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved5: [u8; 244usize],
        #[doc = "0x400 - Semaphore status."]
        pub semstat: SEMSTAT,
        _reserved6: [u8; 60usize],
        #[doc = "0x440 - Status from last transaction."]
        pub status: STATUS,
        _reserved7: [u8; 188usize],
        #[doc = "0x500 - Enable SPIS."]
        pub enable: ENABLE,
        _reserved8: [u8; 4usize],
        #[doc = "0x508 - Pin select for SCK."]
        pub pselsck: PSELSCK,
        #[doc = "0x50c - Pin select for MISO."]
        pub pselmiso: PSELMISO,
        #[doc = "0x510 - Pin select for MOSI."]
        pub pselmosi: PSELMOSI,
        #[doc = "0x514 - Pin select for CSN."]
        pub pselcsn: PSELCSN,
        _reserved9: [u8; 28usize],
        #[doc = "0x534 - RX data pointer."]
        pub rxdptr: RXDPTR,
        #[doc = "0x538 - Maximum number of bytes in the receive buffer."]
        pub maxrx: MAXRX,
        #[doc = "0x53c - Number of bytes received in last granted transaction."]
        pub amountrx: AMOUNTRX,
        _reserved10: [u8; 4usize],
        #[doc = "0x544 - TX data pointer."]
        pub txdptr: TXDPTR,
        #[doc = "0x548 - Maximum number of bytes in the transmit buffer."]
        pub maxtx: MAXTX,
        #[doc = "0x54c - Number of bytes transmitted in last granted transaction."]
        pub amounttx: AMOUNTTX,
        _reserved11: [u8; 4usize],
        #[doc = "0x554 - Configuration register."]
        pub config: CONFIG,
        _reserved12: [u8; 4usize],
        #[doc = "0x55c - Default character."]
        pub def: DEF,
        _reserved13: [u8; 96usize],
        #[doc = "0x5c0 - Over-read character."]
        pub orc: ORC,
        _reserved14: [u8; 2616usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Acquire SPI semaphore."]
    pub struct TASKS_ACQUIRE {
        register: VolatileCell<u32>,
    }
    #[doc = "Acquire SPI semaphore."]
    pub mod tasks_acquire {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_ACQUIRE {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Release SPI semaphore."]
    pub struct TASKS_RELEASE {
        register: VolatileCell<u32>,
    }
    #[doc = "Release SPI semaphore."]
    pub mod tasks_release {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_RELEASE {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Granted transaction completed."]
    pub struct EVENTS_END {
        register: VolatileCell<u32>,
    }
    #[doc = "Granted transaction completed."]
    pub mod events_end {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_END {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Semaphore acquired."]
    pub struct EVENTS_ACQUIRED {
        register: VolatileCell<u32>,
    }
    #[doc = "Semaphore acquired."]
    pub mod events_acquired {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ACQUIRED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for SPIS."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for SPIS."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `END_ACQUIRE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum END_ACQUIRER {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl END_ACQUIRER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    END_ACQUIRER::DISABLED => false,
                    END_ACQUIRER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> END_ACQUIRER {
                match value {
                    false => END_ACQUIRER::DISABLED,
                    true => END_ACQUIRER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == END_ACQUIRER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == END_ACQUIRER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `END_ACQUIRE`"]
        pub enum END_ACQUIREW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl END_ACQUIREW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    END_ACQUIREW::DISABLED => false,
                    END_ACQUIREW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _END_ACQUIREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _END_ACQUIREW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: END_ACQUIREW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(END_ACQUIREW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(END_ACQUIREW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Shortcut between END event and the ACQUIRE task."]
            #[inline]
            pub fn end_acquire(&self) -> END_ACQUIRER {
                END_ACQUIRER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Shortcut between END event and the ACQUIRE task."]
            #[inline]
            pub fn end_acquire(&mut self) -> _END_ACQUIREW {
                _END_ACQUIREW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `END`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDR::DISABLED => false,
                    ENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDR {
                match value {
                    false => ENDR::DISABLED,
                    true => ENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ACQUIRED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACQUIREDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ACQUIREDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACQUIREDR::DISABLED => false,
                    ACQUIREDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACQUIREDR {
                match value {
                    false => ACQUIREDR::DISABLED,
                    true => ACQUIREDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ACQUIREDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ACQUIREDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `END`"]
        pub enum ENDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACQUIRED`"]
        pub enum ACQUIREDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ACQUIREDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACQUIREDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACQUIREDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACQUIREDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACQUIREDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ACQUIREDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Enable interrupt on END event."]
            #[inline]
            pub fn end(&self) -> ENDR {
                ENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Enable interrupt on ACQUIRED event."]
            #[inline]
            pub fn acquired(&self) -> ACQUIREDR {
                ACQUIREDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable interrupt on END event."]
            #[inline]
            pub fn end(&mut self) -> _ENDW {
                _ENDW { w: self }
            }
            #[doc = "Bit 10 - Enable interrupt on ACQUIRED event."]
            #[inline]
            pub fn acquired(&mut self) -> _ACQUIREDW {
                _ACQUIREDW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `END`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDR::DISABLED => false,
                    ENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDR {
                match value {
                    false => ENDR::DISABLED,
                    true => ENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ACQUIRED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACQUIREDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ACQUIREDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACQUIREDR::DISABLED => false,
                    ACQUIREDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACQUIREDR {
                match value {
                    false => ACQUIREDR::DISABLED,
                    true => ACQUIREDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ACQUIREDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ACQUIREDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `END`"]
        pub enum ENDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACQUIRED`"]
        pub enum ACQUIREDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ACQUIREDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACQUIREDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACQUIREDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACQUIREDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACQUIREDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ACQUIREDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Disable interrupt on END event."]
            #[inline]
            pub fn end(&self) -> ENDR {
                ENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Disable interrupt on ACQUIRED event."]
            #[inline]
            pub fn acquired(&self) -> ACQUIREDR {
                ACQUIREDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Disable interrupt on END event."]
            #[inline]
            pub fn end(&mut self) -> _ENDW {
                _ENDW { w: self }
            }
            #[doc = "Bit 10 - Disable interrupt on ACQUIRED event."]
            #[inline]
            pub fn acquired(&mut self) -> _ACQUIREDW {
                _ACQUIREDW { w: self }
            }
        }
    }
    #[doc = "Semaphore status."]
    pub struct SEMSTAT {
        register: VolatileCell<u32>,
    }
    #[doc = "Semaphore status."]
    pub mod semstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SEMSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `SEMSTAT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SEMSTATR {
            #[doc = "Semaphore is free."]
            FREE,
            #[doc = "Semaphore is assigned to the CPU."]
            CPU,
            #[doc = "Semaphore is assigned to the SPIS."]
            SPIS,
            #[doc = "Semaphore is assigned to the SPIS, but a handover to the CPU is pending."]
            CPUPENDING,
        }
        impl SEMSTATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SEMSTATR::FREE => 0,
                    SEMSTATR::CPU => 0x01,
                    SEMSTATR::SPIS => 0x02,
                    SEMSTATR::CPUPENDING => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SEMSTATR {
                match value {
                    0 => SEMSTATR::FREE,
                    1 => SEMSTATR::CPU,
                    2 => SEMSTATR::SPIS,
                    3 => SEMSTATR::CPUPENDING,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `FREE`"]
            #[inline]
            pub fn is_free(&self) -> bool {
                *self == SEMSTATR::FREE
            }
            #[doc = "Checks if the value of the field is `CPU`"]
            #[inline]
            pub fn is_cpu(&self) -> bool {
                *self == SEMSTATR::CPU
            }
            #[doc = "Checks if the value of the field is `SPIS`"]
            #[inline]
            pub fn is_spis(&self) -> bool {
                *self == SEMSTATR::SPIS
            }
            #[doc = "Checks if the value of the field is `CPUPENDING`"]
            #[inline]
            pub fn is_cpupending(&self) -> bool {
                *self == SEMSTATR::CPUPENDING
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Semaphore status."]
            #[inline]
            pub fn semstat(&self) -> SEMSTATR {
                SEMSTATR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
    }
    #[doc = "Status from last transaction."]
    pub struct STATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Status from last transaction."]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STATUS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `OVERREAD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVERREADR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl OVERREADR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVERREADR::NOTPRESENT => false,
                    OVERREADR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVERREADR {
                match value {
                    false => OVERREADR::NOTPRESENT,
                    true => OVERREADR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == OVERREADR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == OVERREADR::PRESENT
            }
        }
        #[doc = "Possible values of the field `OVERFLOW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVERFLOWR {
            #[doc = "Error not present."]
            NOTPRESENT,
            #[doc = "Error present."]
            PRESENT,
        }
        impl OVERFLOWR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVERFLOWR::NOTPRESENT => false,
                    OVERFLOWR::PRESENT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVERFLOWR {
                match value {
                    false => OVERFLOWR::NOTPRESENT,
                    true => OVERFLOWR::PRESENT,
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == OVERFLOWR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == OVERFLOWR::PRESENT
            }
        }
        #[doc = "Values that can be written to the field `OVERREAD`"]
        pub enum OVERREADW {
            #[doc = "Clear on write."]
            CLEAR,
        }
        impl OVERREADW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVERREADW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERREADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERREADW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVERREADW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVERREADW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OVERFLOW`"]
        pub enum OVERFLOWW {
            #[doc = "Clear on write."]
            CLEAR,
        }
        impl OVERFLOWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVERFLOWW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERFLOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERFLOWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVERFLOWW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Clear on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVERFLOWW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - TX buffer overread detected, and prevented."]
            #[inline]
            pub fn overread(&self) -> OVERREADR {
                OVERREADR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - RX buffer overflow detected, and prevented."]
            #[inline]
            pub fn overflow(&self) -> OVERFLOWR {
                OVERFLOWR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - TX buffer overread detected, and prevented."]
            #[inline]
            pub fn overread(&mut self) -> _OVERREADW {
                _OVERREADW { w: self }
            }
            #[doc = "Bit 1 - RX buffer overflow detected, and prevented."]
            #[inline]
            pub fn overflow(&mut self) -> _OVERFLOWW {
                _OVERFLOWW { w: self }
            }
        }
    }
    #[doc = "Enable SPIS."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable SPIS."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled SPIS."]
            DISABLED,
            #[doc = "Enable SPIS."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x02,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    2 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled SPIS."]
            DISABLED,
            #[doc = "Enable SPIS."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled SPIS."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enable SPIS."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Enable or disable SPIS."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Enable or disable SPIS."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Pin select for SCK."]
    pub struct PSELSCK {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for SCK."]
    pub mod pselsck {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELSCK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for MISO."]
    pub struct PSELMISO {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for MISO."]
    pub mod pselmiso {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELMISO {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for MOSI."]
    pub struct PSELMOSI {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for MOSI."]
    pub mod pselmosi {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELMOSI {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for CSN."]
    pub struct PSELCSN {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for CSN."]
    pub mod pselcsn {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELCSN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "RX data pointer."]
    pub struct RXDPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "RX data pointer."]
    pub mod rxdptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RXDPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Maximum number of bytes in the receive buffer."]
    pub struct MAXRX {
        register: VolatileCell<u32>,
    }
    #[doc = "Maximum number of bytes in the receive buffer."]
    pub mod maxrx {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAXRX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MAXRXR {
            bits: u8,
        }
        impl MAXRXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MAXRXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MAXRXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Maximum number of bytes in the receive buffer."]
            #[inline]
            pub fn maxrx(&self) -> MAXRXR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MAXRXR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Maximum number of bytes in the receive buffer."]
            #[inline]
            pub fn maxrx(&mut self) -> _MAXRXW {
                _MAXRXW { w: self }
            }
        }
    }
    #[doc = "Number of bytes received in last granted transaction."]
    pub struct AMOUNTRX {
        register: VolatileCell<u32>,
    }
    #[doc = "Number of bytes received in last granted transaction."]
    pub mod amountrx {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::AMOUNTRX {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct AMOUNTRXR {
            bits: u8,
        }
        impl AMOUNTRXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Number of bytes received in last granted transaction."]
            #[inline]
            pub fn amountrx(&self) -> AMOUNTRXR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AMOUNTRXR { bits }
            }
        }
    }
    #[doc = "TX data pointer."]
    pub struct TXDPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "TX data pointer."]
    pub mod txdptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Maximum number of bytes in the transmit buffer."]
    pub struct MAXTX {
        register: VolatileCell<u32>,
    }
    #[doc = "Maximum number of bytes in the transmit buffer."]
    pub mod maxtx {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAXTX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MAXTXR {
            bits: u8,
        }
        impl MAXTXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MAXTXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MAXTXW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Maximum number of bytes in the transmit buffer."]
            #[inline]
            pub fn maxtx(&self) -> MAXTXR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MAXTXR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Maximum number of bytes in the transmit buffer."]
            #[inline]
            pub fn maxtx(&mut self) -> _MAXTXW {
                _MAXTXW { w: self }
            }
        }
    }
    #[doc = "Number of bytes transmitted in last granted transaction."]
    pub struct AMOUNTTX {
        register: VolatileCell<u32>,
    }
    #[doc = "Number of bytes transmitted in last granted transaction."]
    pub mod amounttx {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::AMOUNTTX {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct AMOUNTTXR {
            bits: u8,
        }
        impl AMOUNTTXR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Number of bytes transmitted in last granted transaction."]
            #[inline]
            pub fn amounttx(&self) -> AMOUNTTXR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                AMOUNTTXR { bits }
            }
        }
    }
    #[doc = "Configuration register."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration register."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ORDER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ORDERR {
            #[doc = "Most significant bit transmitted out first."]
            MSBFIRST,
            #[doc = "Least significant bit transmitted out first."]
            LSBFIRST,
        }
        impl ORDERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ORDERR::MSBFIRST => false,
                    ORDERR::LSBFIRST => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ORDERR {
                match value {
                    false => ORDERR::MSBFIRST,
                    true => ORDERR::LSBFIRST,
                }
            }
            #[doc = "Checks if the value of the field is `MSBFIRST`"]
            #[inline]
            pub fn is_msb_first(&self) -> bool {
                *self == ORDERR::MSBFIRST
            }
            #[doc = "Checks if the value of the field is `LSBFIRST`"]
            #[inline]
            pub fn is_lsb_first(&self) -> bool {
                *self == ORDERR::LSBFIRST
            }
        }
        #[doc = "Possible values of the field `CPHA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHAR {
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            LEADING,
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            TRAILING,
        }
        impl CPHAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPHAR::LEADING => false,
                    CPHAR::TRAILING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPHAR {
                match value {
                    false => CPHAR::LEADING,
                    true => CPHAR::TRAILING,
                }
            }
            #[doc = "Checks if the value of the field is `LEADING`"]
            #[inline]
            pub fn is_leading(&self) -> bool {
                *self == CPHAR::LEADING
            }
            #[doc = "Checks if the value of the field is `TRAILING`"]
            #[inline]
            pub fn is_trailing(&self) -> bool {
                *self == CPHAR::TRAILING
            }
        }
        #[doc = "Possible values of the field `CPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOLR {
            #[doc = "Active high."]
            ACTIVEHIGH,
            #[doc = "Active low."]
            ACTIVELOW,
        }
        impl CPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPOLR::ACTIVEHIGH => false,
                    CPOLR::ACTIVELOW => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPOLR {
                match value {
                    false => CPOLR::ACTIVEHIGH,
                    true => CPOLR::ACTIVELOW,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVEHIGH`"]
            #[inline]
            pub fn is_active_high(&self) -> bool {
                *self == CPOLR::ACTIVEHIGH
            }
            #[doc = "Checks if the value of the field is `ACTIVELOW`"]
            #[inline]
            pub fn is_active_low(&self) -> bool {
                *self == CPOLR::ACTIVELOW
            }
        }
        #[doc = "Values that can be written to the field `ORDER`"]
        pub enum ORDERW {
            #[doc = "Most significant bit transmitted out first."]
            MSBFIRST,
            #[doc = "Least significant bit transmitted out first."]
            LSBFIRST,
        }
        impl ORDERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ORDERW::MSBFIRST => false,
                    ORDERW::LSBFIRST => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ORDERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ORDERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ORDERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Most significant bit transmitted out first."]
            #[inline]
            pub fn msb_first(self) -> &'a mut W {
                self.variant(ORDERW::MSBFIRST)
            }
            #[doc = "Least significant bit transmitted out first."]
            #[inline]
            pub fn lsb_first(self) -> &'a mut W {
                self.variant(ORDERW::LSBFIRST)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPHA`"]
        pub enum CPHAW {
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            LEADING,
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            TRAILING,
        }
        impl CPHAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPHAW::LEADING => false,
                    CPHAW::TRAILING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPHAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPHAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPHAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            #[inline]
            pub fn leading(self) -> &'a mut W {
                self.variant(CPHAW::LEADING)
            }
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            #[inline]
            pub fn trailing(self) -> &'a mut W {
                self.variant(CPHAW::TRAILING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPOL`"]
        pub enum CPOLW {
            #[doc = "Active high."]
            ACTIVEHIGH,
            #[doc = "Active low."]
            ACTIVELOW,
        }
        impl CPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPOLW::ACTIVEHIGH => false,
                    CPOLW::ACTIVELOW => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Active high."]
            #[inline]
            pub fn active_high(self) -> &'a mut W {
                self.variant(CPOLW::ACTIVEHIGH)
            }
            #[doc = "Active low."]
            #[inline]
            pub fn active_low(self) -> &'a mut W {
                self.variant(CPOLW::ACTIVELOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Bit order."]
            #[inline]
            pub fn order(&self) -> ORDERR {
                ORDERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Serial clock (SCK) phase."]
            #[inline]
            pub fn cpha(&self) -> CPHAR {
                CPHAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Serial clock (SCK) polarity."]
            #[inline]
            pub fn cpol(&self) -> CPOLR {
                CPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Bit order."]
            #[inline]
            pub fn order(&mut self) -> _ORDERW {
                _ORDERW { w: self }
            }
            #[doc = "Bit 1 - Serial clock (SCK) phase."]
            #[inline]
            pub fn cpha(&mut self) -> _CPHAW {
                _CPHAW { w: self }
            }
            #[doc = "Bit 2 - Serial clock (SCK) polarity."]
            #[inline]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
        }
    }
    #[doc = "Default character."]
    pub struct DEF {
        register: VolatileCell<u32>,
    }
    #[doc = "Default character."]
    pub mod def {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DEF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEFR {
            bits: u8,
        }
        impl DEFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Default character."]
            #[inline]
            pub fn def(&self) -> DEFR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DEFR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Default character."]
            #[inline]
            pub fn def(&mut self) -> _DEFW {
                _DEFW { w: self }
            }
        }
    }
    #[doc = "Over-read character."]
    pub struct ORC {
        register: VolatileCell<u32>,
    }
    #[doc = "Over-read character."]
    pub mod orc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ORC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ORCR {
            bits: u8,
        }
        impl ORCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ORCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ORCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Over-read character."]
            #[inline]
            pub fn orc(&self) -> ORCR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ORCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Over-read character."]
            #[inline]
            pub fn orc(&mut self) -> _ORCW {
                _ORCW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "SPI master with easyDMA 1."]
pub struct SPIM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPIM1 {}
impl SPIM1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const spim1::RegisterBlock {
        0x4000_4000 as *const _
    }
}
impl Deref for SPIM1 {
    type Target = spim1::RegisterBlock;
    fn deref(&self) -> &spim1::RegisterBlock {
        unsafe { &*SPIM1::ptr() }
    }
}
#[doc = "SPI master with easyDMA 1."]
pub mod spim1 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 16usize],
        #[doc = "0x10 - Start SPI transaction."]
        pub tasks_start: TASKS_START,
        #[doc = "0x14 - Stop SPI transaction."]
        pub tasks_stop: TASKS_STOP,
        _reserved1: [u8; 4usize],
        #[doc = "0x1c - Suspend SPI transaction."]
        pub tasks_suspend: TASKS_SUSPEND,
        #[doc = "0x20 - Resume SPI transaction."]
        pub tasks_resume: TASKS_RESUME,
        _reserved2: [u8; 224usize],
        #[doc = "0x104 - SPI transaction has stopped."]
        pub events_stopped: EVENTS_STOPPED,
        _reserved3: [u8; 8usize],
        #[doc = "0x110 - End of RXD buffer reached."]
        pub events_endrx: EVENTS_ENDRX,
        _reserved4: [u8; 12usize],
        #[doc = "0x120 - End of TXD buffer reached."]
        pub events_endtx: EVENTS_ENDTX,
        _reserved5: [u8; 40usize],
        #[doc = "0x14c - Transaction started."]
        pub events_started: EVENTS_STARTED,
        _reserved6: [u8; 436usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved7: [u8; 500usize],
        #[doc = "0x500 - Enable SPIM."]
        pub enable: ENABLE,
        _reserved8: [u8; 32usize],
        #[doc = "0x524 - SPI frequency."]
        pub frequency: FREQUENCY,
        _reserved9: [u8; 44usize],
        #[doc = "0x554 - Configuration register."]
        pub config: CONFIG,
        _reserved10: [u8; 104usize],
        #[doc = "0x5c0 - Over-read character."]
        pub orc: ORC,
        _reserved11: [u8; 2616usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start SPI transaction."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start SPI transaction."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop SPI transaction."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop SPI transaction."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Suspend SPI transaction."]
    pub struct TASKS_SUSPEND {
        register: VolatileCell<u32>,
    }
    #[doc = "Suspend SPI transaction."]
    pub mod tasks_suspend {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_SUSPEND {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Resume SPI transaction."]
    pub struct TASKS_RESUME {
        register: VolatileCell<u32>,
    }
    #[doc = "Resume SPI transaction."]
    pub mod tasks_resume {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_RESUME {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "SPI transaction has stopped."]
    pub struct EVENTS_STOPPED {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI transaction has stopped."]
    pub mod events_stopped {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_STOPPED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "End of RXD buffer reached."]
    pub struct EVENTS_ENDRX {
        register: VolatileCell<u32>,
    }
    #[doc = "End of RXD buffer reached."]
    pub mod events_endrx {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ENDRX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "End of TXD buffer reached."]
    pub struct EVENTS_ENDTX {
        register: VolatileCell<u32>,
    }
    #[doc = "End of TXD buffer reached."]
    pub mod events_endtx {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ENDTX {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transaction started."]
    pub struct EVENTS_STARTED {
        register: VolatileCell<u32>,
    }
    #[doc = "Transaction started."]
    pub mod events_started {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_STARTED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `STOPPED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPPEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl STOPPEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STOPPEDR::DISABLED => false,
                    STOPPEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STOPPEDR {
                match value {
                    false => STOPPEDR::DISABLED,
                    true => STOPPEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == STOPPEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == STOPPEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENDRX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDRXR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDRXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDRXR::DISABLED => false,
                    ENDRXR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDRXR {
                match value {
                    false => ENDRXR::DISABLED,
                    true => ENDRXR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDRXR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDRXR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENDTX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDTXR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDTXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDTXR::DISABLED => false,
                    ENDTXR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDTXR {
                match value {
                    false => ENDTXR::DISABLED,
                    true => ENDTXR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDTXR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDTXR::ENABLED
            }
        }
        #[doc = "Possible values of the field `STARTED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STARTEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl STARTEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STARTEDR::DISABLED => false,
                    STARTEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STARTEDR {
                match value {
                    false => STARTEDR::DISABLED,
                    true => STARTEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == STARTEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == STARTEDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `STOPPED`"]
        pub enum STOPPEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl STOPPEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STOPPEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPPEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPPEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STOPPEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(STOPPEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENDRX`"]
        pub enum ENDRXW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDRXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDRXW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDRXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDRXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDRXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDRXW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENDTX`"]
        pub enum ENDTXW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDTXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDTXW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDTXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDTXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDTXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDTXW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STARTED`"]
        pub enum STARTEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl STARTEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STARTEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STARTEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(STARTEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Enable interrupt on STOPPED event."]
            #[inline]
            pub fn stopped(&self) -> STOPPEDR {
                STOPPEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enable interrupt on ENDRX event."]
            #[inline]
            pub fn endrx(&self) -> ENDRXR {
                ENDRXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Enable interrupt on ENDTX event."]
            #[inline]
            pub fn endtx(&self) -> ENDTXR {
                ENDTXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Enable interrupt on STARTED event."]
            #[inline]
            pub fn started(&self) -> STARTEDR {
                STARTEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Enable interrupt on STOPPED event."]
            #[inline]
            pub fn stopped(&mut self) -> _STOPPEDW {
                _STOPPEDW { w: self }
            }
            #[doc = "Bit 4 - Enable interrupt on ENDRX event."]
            #[inline]
            pub fn endrx(&mut self) -> _ENDRXW {
                _ENDRXW { w: self }
            }
            #[doc = "Bit 8 - Enable interrupt on ENDTX event."]
            #[inline]
            pub fn endtx(&mut self) -> _ENDTXW {
                _ENDTXW { w: self }
            }
            #[doc = "Bit 19 - Enable interrupt on STARTED event."]
            #[inline]
            pub fn started(&mut self) -> _STARTEDW {
                _STARTEDW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `STOPPED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPPEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl STOPPEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STOPPEDR::DISABLED => false,
                    STOPPEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STOPPEDR {
                match value {
                    false => STOPPEDR::DISABLED,
                    true => STOPPEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == STOPPEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == STOPPEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENDRX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDRXR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDRXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDRXR::DISABLED => false,
                    ENDRXR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDRXR {
                match value {
                    false => ENDRXR::DISABLED,
                    true => ENDRXR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDRXR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDRXR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENDTX`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDTXR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDTXR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDTXR::DISABLED => false,
                    ENDTXR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDTXR {
                match value {
                    false => ENDTXR::DISABLED,
                    true => ENDTXR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDTXR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDTXR::ENABLED
            }
        }
        #[doc = "Possible values of the field `STARTED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STARTEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl STARTEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STARTEDR::DISABLED => false,
                    STARTEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STARTEDR {
                match value {
                    false => STARTEDR::DISABLED,
                    true => STARTEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == STARTEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == STARTEDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `STOPPED`"]
        pub enum STOPPEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl STOPPEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STOPPEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPPEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPPEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STOPPEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(STOPPEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENDRX`"]
        pub enum ENDRXW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDRXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDRXW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDRXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDRXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDRXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDRXW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENDTX`"]
        pub enum ENDTXW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDTXW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDTXW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDTXW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDTXW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDTXW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDTXW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `STARTED`"]
        pub enum STARTEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl STARTEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STARTEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STARTEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(STARTEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Disable interrupt on STOPPED event."]
            #[inline]
            pub fn stopped(&self) -> STOPPEDR {
                STOPPEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Disable interrupt on ENDRX event."]
            #[inline]
            pub fn endrx(&self) -> ENDRXR {
                ENDRXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Disable interrupt on ENDTX event."]
            #[inline]
            pub fn endtx(&self) -> ENDTXR {
                ENDTXR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Disable interrupt on STARTED event."]
            #[inline]
            pub fn started(&self) -> STARTEDR {
                STARTEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Disable interrupt on STOPPED event."]
            #[inline]
            pub fn stopped(&mut self) -> _STOPPEDW {
                _STOPPEDW { w: self }
            }
            #[doc = "Bit 4 - Disable interrupt on ENDRX event."]
            #[inline]
            pub fn endrx(&mut self) -> _ENDRXW {
                _ENDRXW { w: self }
            }
            #[doc = "Bit 8 - Disable interrupt on ENDTX event."]
            #[inline]
            pub fn endtx(&mut self) -> _ENDTXW {
                _ENDTXW { w: self }
            }
            #[doc = "Bit 19 - Disable interrupt on STARTED event."]
            #[inline]
            pub fn started(&mut self) -> _STARTEDW {
                _STARTEDW { w: self }
            }
        }
    }
    #[doc = "Enable SPIM."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable SPIM."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled SPIM."]
            DISABLED,
            #[doc = "Enable SPIM."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x07,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    7 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled SPIM."]
            DISABLED,
            #[doc = "Enable SPIM."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled SPIM."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enable SPIM."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Enable or disable SPIM."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Enable or disable SPIM."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "SPI frequency."]
    pub struct FREQUENCY {
        register: VolatileCell<u32>,
    }
    #[doc = "SPI frequency."]
    pub mod frequency {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FREQUENCY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FREQUENCY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQUENCYR {
            #[doc = "125 kbps."]
            K125,
            #[doc = "250 kbps."]
            K250,
            #[doc = "500 kbps."]
            K500,
            #[doc = "1 Mbps."]
            M1,
            #[doc = "2 Mbps."]
            M2,
            #[doc = "4 Mbps."]
            M4,
            #[doc = "8 Mbps."]
            M8,
            #[doc = r" Reserved"]
            _Reserved(u32),
        }
        impl FREQUENCYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                match *self {
                    FREQUENCYR::K125 => 0x0200_0000,
                    FREQUENCYR::K250 => 0x0400_0000,
                    FREQUENCYR::K500 => 0x0800_0000,
                    FREQUENCYR::M1 => 0x1000_0000,
                    FREQUENCYR::M2 => 0x2000_0000,
                    FREQUENCYR::M4 => 0x4000_0000,
                    FREQUENCYR::M8 => 0x8000_0000,
                    FREQUENCYR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u32) -> FREQUENCYR {
                match value {
                    33554432 => FREQUENCYR::K125,
                    67108864 => FREQUENCYR::K250,
                    134217728 => FREQUENCYR::K500,
                    268435456 => FREQUENCYR::M1,
                    536870912 => FREQUENCYR::M2,
                    1073741824 => FREQUENCYR::M4,
                    2147483648 => FREQUENCYR::M8,
                    i => FREQUENCYR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `K125`"]
            #[inline]
            pub fn is_k125(&self) -> bool {
                *self == FREQUENCYR::K125
            }
            #[doc = "Checks if the value of the field is `K250`"]
            #[inline]
            pub fn is_k250(&self) -> bool {
                *self == FREQUENCYR::K250
            }
            #[doc = "Checks if the value of the field is `K500`"]
            #[inline]
            pub fn is_k500(&self) -> bool {
                *self == FREQUENCYR::K500
            }
            #[doc = "Checks if the value of the field is `M1`"]
            #[inline]
            pub fn is_m1(&self) -> bool {
                *self == FREQUENCYR::M1
            }
            #[doc = "Checks if the value of the field is `M2`"]
            #[inline]
            pub fn is_m2(&self) -> bool {
                *self == FREQUENCYR::M2
            }
            #[doc = "Checks if the value of the field is `M4`"]
            #[inline]
            pub fn is_m4(&self) -> bool {
                *self == FREQUENCYR::M4
            }
            #[doc = "Checks if the value of the field is `M8`"]
            #[inline]
            pub fn is_m8(&self) -> bool {
                *self == FREQUENCYR::M8
            }
        }
        #[doc = "Values that can be written to the field `FREQUENCY`"]
        pub enum FREQUENCYW {
            #[doc = "125 kbps."]
            K125,
            #[doc = "250 kbps."]
            K250,
            #[doc = "500 kbps."]
            K500,
            #[doc = "1 Mbps."]
            M1,
            #[doc = "2 Mbps."]
            M2,
            #[doc = "4 Mbps."]
            M4,
            #[doc = "8 Mbps."]
            M8,
        }
        impl FREQUENCYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u32 {
                match *self {
                    FREQUENCYW::K125 => 33554432,
                    FREQUENCYW::K250 => 67108864,
                    FREQUENCYW::K500 => 134217728,
                    FREQUENCYW::M1 => 268435456,
                    FREQUENCYW::M2 => 536870912,
                    FREQUENCYW::M4 => 1073741824,
                    FREQUENCYW::M8 => 2147483648,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQUENCYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQUENCYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FREQUENCYW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "125 kbps."]
            #[inline]
            pub fn k125(self) -> &'a mut W {
                self.variant(FREQUENCYW::K125)
            }
            #[doc = "250 kbps."]
            #[inline]
            pub fn k250(self) -> &'a mut W {
                self.variant(FREQUENCYW::K250)
            }
            #[doc = "500 kbps."]
            #[inline]
            pub fn k500(self) -> &'a mut W {
                self.variant(FREQUENCYW::K500)
            }
            #[doc = "1 Mbps."]
            #[inline]
            pub fn m1(self) -> &'a mut W {
                self.variant(FREQUENCYW::M1)
            }
            #[doc = "2 Mbps."]
            #[inline]
            pub fn m2(self) -> &'a mut W {
                self.variant(FREQUENCYW::M2)
            }
            #[doc = "4 Mbps."]
            #[inline]
            pub fn m4(self) -> &'a mut W {
                self.variant(FREQUENCYW::M4)
            }
            #[doc = "8 Mbps."]
            #[inline]
            pub fn m8(self) -> &'a mut W {
                self.variant(FREQUENCYW::M8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - SPI master data rate."]
            #[inline]
            pub fn frequency(&self) -> FREQUENCYR {
                FREQUENCYR::_from({
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0400_0000 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - SPI master data rate."]
            #[inline]
            pub fn frequency(&mut self) -> _FREQUENCYW {
                _FREQUENCYW { w: self }
            }
        }
    }
    #[doc = "Configuration register."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration register."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ORDER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ORDERR {
            #[doc = "Most significant bit transmitted out first."]
            MSBFIRST,
            #[doc = "Least significant bit transmitted out first."]
            LSBFIRST,
        }
        impl ORDERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ORDERR::MSBFIRST => false,
                    ORDERR::LSBFIRST => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ORDERR {
                match value {
                    false => ORDERR::MSBFIRST,
                    true => ORDERR::LSBFIRST,
                }
            }
            #[doc = "Checks if the value of the field is `MSBFIRST`"]
            #[inline]
            pub fn is_msb_first(&self) -> bool {
                *self == ORDERR::MSBFIRST
            }
            #[doc = "Checks if the value of the field is `LSBFIRST`"]
            #[inline]
            pub fn is_lsb_first(&self) -> bool {
                *self == ORDERR::LSBFIRST
            }
        }
        #[doc = "Possible values of the field `CPHA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHAR {
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            LEADING,
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            TRAILING,
        }
        impl CPHAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPHAR::LEADING => false,
                    CPHAR::TRAILING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPHAR {
                match value {
                    false => CPHAR::LEADING,
                    true => CPHAR::TRAILING,
                }
            }
            #[doc = "Checks if the value of the field is `LEADING`"]
            #[inline]
            pub fn is_leading(&self) -> bool {
                *self == CPHAR::LEADING
            }
            #[doc = "Checks if the value of the field is `TRAILING`"]
            #[inline]
            pub fn is_trailing(&self) -> bool {
                *self == CPHAR::TRAILING
            }
        }
        #[doc = "Possible values of the field `CPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOLR {
            #[doc = "Active high."]
            ACTIVEHIGH,
            #[doc = "Active low."]
            ACTIVELOW,
        }
        impl CPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPOLR::ACTIVEHIGH => false,
                    CPOLR::ACTIVELOW => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPOLR {
                match value {
                    false => CPOLR::ACTIVEHIGH,
                    true => CPOLR::ACTIVELOW,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVEHIGH`"]
            #[inline]
            pub fn is_active_high(&self) -> bool {
                *self == CPOLR::ACTIVEHIGH
            }
            #[doc = "Checks if the value of the field is `ACTIVELOW`"]
            #[inline]
            pub fn is_active_low(&self) -> bool {
                *self == CPOLR::ACTIVELOW
            }
        }
        #[doc = "Values that can be written to the field `ORDER`"]
        pub enum ORDERW {
            #[doc = "Most significant bit transmitted out first."]
            MSBFIRST,
            #[doc = "Least significant bit transmitted out first."]
            LSBFIRST,
        }
        impl ORDERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ORDERW::MSBFIRST => false,
                    ORDERW::LSBFIRST => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ORDERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ORDERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ORDERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Most significant bit transmitted out first."]
            #[inline]
            pub fn msb_first(self) -> &'a mut W {
                self.variant(ORDERW::MSBFIRST)
            }
            #[doc = "Least significant bit transmitted out first."]
            #[inline]
            pub fn lsb_first(self) -> &'a mut W {
                self.variant(ORDERW::LSBFIRST)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPHA`"]
        pub enum CPHAW {
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            LEADING,
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            TRAILING,
        }
        impl CPHAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPHAW::LEADING => false,
                    CPHAW::TRAILING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPHAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPHAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPHAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Sample on leading edge of the clock. Shift serial data on trailing edge."]
            #[inline]
            pub fn leading(self) -> &'a mut W {
                self.variant(CPHAW::LEADING)
            }
            #[doc = "Sample on trailing edge of the clock. Shift serial data on leading edge."]
            #[inline]
            pub fn trailing(self) -> &'a mut W {
                self.variant(CPHAW::TRAILING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPOL`"]
        pub enum CPOLW {
            #[doc = "Active high."]
            ACTIVEHIGH,
            #[doc = "Active low."]
            ACTIVELOW,
        }
        impl CPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPOLW::ACTIVEHIGH => false,
                    CPOLW::ACTIVELOW => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Active high."]
            #[inline]
            pub fn active_high(self) -> &'a mut W {
                self.variant(CPOLW::ACTIVEHIGH)
            }
            #[doc = "Active low."]
            #[inline]
            pub fn active_low(self) -> &'a mut W {
                self.variant(CPOLW::ACTIVELOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Bit order."]
            #[inline]
            pub fn order(&self) -> ORDERR {
                ORDERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Serial clock (SCK) phase."]
            #[inline]
            pub fn cpha(&self) -> CPHAR {
                CPHAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Serial clock (SCK) polarity."]
            #[inline]
            pub fn cpol(&self) -> CPOLR {
                CPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Bit order."]
            #[inline]
            pub fn order(&mut self) -> _ORDERW {
                _ORDERW { w: self }
            }
            #[doc = "Bit 1 - Serial clock (SCK) phase."]
            #[inline]
            pub fn cpha(&mut self) -> _CPHAW {
                _CPHAW { w: self }
            }
            #[doc = "Bit 2 - Serial clock (SCK) polarity."]
            #[inline]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
        }
    }
    #[doc = "Over-read character."]
    pub struct ORC {
        register: VolatileCell<u32>,
    }
    #[doc = "Over-read character."]
    pub mod orc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ORC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ORCR {
            bits: u8,
        }
        impl ORCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ORCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ORCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Over-read character."]
            #[inline]
            pub fn orc(&self) -> ORCR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ORCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Over-read character."]
            #[inline]
            pub fn orc(&mut self) -> _ORCW {
                _ORCW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "GPIO tasks and events."]
pub struct GPIOTE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOTE {}
impl GPIOTE {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpiote::RegisterBlock {
        0x4000_6000 as *const _
    }
}
impl Deref for GPIOTE {
    type Target = gpiote::RegisterBlock;
    fn deref(&self) -> &gpiote::RegisterBlock {
        unsafe { &*GPIOTE::ptr() }
    }
}
#[doc = "GPIO tasks and events."]
pub mod gpiote {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Tasks asssociated with GPIOTE channels."]
        pub tasks_out: [TASKS_OUT; 4],
        _reserved0: [u8; 240usize],
        #[doc = "0x100 - Tasks asssociated with GPIOTE channels."]
        pub events_in: [EVENTS_IN; 4],
        _reserved1: [u8; 108usize],
        #[doc = "0x17c - Event generated from multiple pins."]
        pub events_port: EVENTS_PORT,
        _reserved2: [u8; 388usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 516usize],
        #[doc = "0x510 - Channel configuration registers."]
        pub config: [CONFIG; 4],
        _reserved4: [u8; 2780usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Tasks asssociated with GPIOTE channels."]
    pub struct TASKS_OUT {
        register: VolatileCell<u32>,
    }
    #[doc = "Tasks asssociated with GPIOTE channels."]
    pub mod tasks_out {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_OUT {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Tasks asssociated with GPIOTE channels."]
    pub struct EVENTS_IN {
        register: VolatileCell<u32>,
    }
    #[doc = "Tasks asssociated with GPIOTE channels."]
    pub mod events_in {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_IN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Event generated from multiple pins."]
    pub struct EVENTS_PORT {
        register: VolatileCell<u32>,
    }
    #[doc = "Event generated from multiple pins."]
    pub mod events_port {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_PORT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IN0R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl IN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IN0R::DISABLED => false,
                    IN0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IN0R {
                match value {
                    false => IN0R::DISABLED,
                    true => IN0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IN0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IN0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `IN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IN1R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl IN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IN1R::DISABLED => false,
                    IN1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IN1R {
                match value {
                    false => IN1R::DISABLED,
                    true => IN1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IN1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IN1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `IN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IN2R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl IN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IN2R::DISABLED => false,
                    IN2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IN2R {
                match value {
                    false => IN2R::DISABLED,
                    true => IN2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IN2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IN2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `IN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IN3R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl IN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IN3R::DISABLED => false,
                    IN3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IN3R {
                match value {
                    false => IN3R::DISABLED,
                    true => IN3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IN3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IN3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PORT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PORTR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl PORTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PORTR::DISABLED => false,
                    PORTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PORTR {
                match value {
                    false => PORTR::DISABLED,
                    true => PORTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PORTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PORTR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `IN0`"]
        pub enum IN0W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl IN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IN0W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(IN0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IN1`"]
        pub enum IN1W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl IN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IN1W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(IN1W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IN2`"]
        pub enum IN2W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl IN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IN2W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(IN2W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IN3`"]
        pub enum IN3W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl IN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IN3W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(IN3W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PORT`"]
        pub enum PORTW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl PORTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PORTW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PORTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PORTW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on IN[0] event."]
            #[inline]
            pub fn in0(&self) -> IN0R {
                IN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on IN[1] event."]
            #[inline]
            pub fn in1(&self) -> IN1R {
                IN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable interrupt on IN[2] event."]
            #[inline]
            pub fn in2(&self) -> IN2R {
                IN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable interrupt on IN[3] event."]
            #[inline]
            pub fn in3(&self) -> IN3R {
                IN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Enable interrupt on PORT event."]
            #[inline]
            pub fn port(&self) -> PORTR {
                PORTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on IN[0] event."]
            #[inline]
            pub fn in0(&mut self) -> _IN0W {
                _IN0W { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on IN[1] event."]
            #[inline]
            pub fn in1(&mut self) -> _IN1W {
                _IN1W { w: self }
            }
            #[doc = "Bit 2 - Enable interrupt on IN[2] event."]
            #[inline]
            pub fn in2(&mut self) -> _IN2W {
                _IN2W { w: self }
            }
            #[doc = "Bit 3 - Enable interrupt on IN[3] event."]
            #[inline]
            pub fn in3(&mut self) -> _IN3W {
                _IN3W { w: self }
            }
            #[doc = "Bit 31 - Enable interrupt on PORT event."]
            #[inline]
            pub fn port(&mut self) -> _PORTW {
                _PORTW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IN0R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl IN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IN0R::DISABLED => false,
                    IN0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IN0R {
                match value {
                    false => IN0R::DISABLED,
                    true => IN0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IN0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IN0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `IN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IN1R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl IN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IN1R::DISABLED => false,
                    IN1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IN1R {
                match value {
                    false => IN1R::DISABLED,
                    true => IN1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IN1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IN1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `IN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IN2R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl IN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IN2R::DISABLED => false,
                    IN2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IN2R {
                match value {
                    false => IN2R::DISABLED,
                    true => IN2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IN2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IN2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `IN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IN3R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl IN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IN3R::DISABLED => false,
                    IN3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IN3R {
                match value {
                    false => IN3R::DISABLED,
                    true => IN3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IN3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IN3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PORT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PORTR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl PORTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PORTR::DISABLED => false,
                    PORTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PORTR {
                match value {
                    false => PORTR::DISABLED,
                    true => PORTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PORTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PORTR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `IN0`"]
        pub enum IN0W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl IN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IN0W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(IN0W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IN1`"]
        pub enum IN1W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl IN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IN1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(IN1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IN2`"]
        pub enum IN2W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl IN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IN2W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(IN2W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IN3`"]
        pub enum IN3W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl IN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IN3W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(IN3W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PORT`"]
        pub enum PORTW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl PORTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PORTW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PORTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PORTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PORTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PORTW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on IN[0] event."]
            #[inline]
            pub fn in0(&self) -> IN0R {
                IN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on IN[1] event."]
            #[inline]
            pub fn in1(&self) -> IN1R {
                IN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable interrupt on IN[2] event."]
            #[inline]
            pub fn in2(&self) -> IN2R {
                IN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Disable interrupt on IN[3] event."]
            #[inline]
            pub fn in3(&self) -> IN3R {
                IN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Disable interrupt on PORT event."]
            #[inline]
            pub fn port(&self) -> PORTR {
                PORTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on IN[0] event."]
            #[inline]
            pub fn in0(&mut self) -> _IN0W {
                _IN0W { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on IN[1] event."]
            #[inline]
            pub fn in1(&mut self) -> _IN1W {
                _IN1W { w: self }
            }
            #[doc = "Bit 2 - Disable interrupt on IN[2] event."]
            #[inline]
            pub fn in2(&mut self) -> _IN2W {
                _IN2W { w: self }
            }
            #[doc = "Bit 3 - Disable interrupt on IN[3] event."]
            #[inline]
            pub fn in3(&mut self) -> _IN3W {
                _IN3W { w: self }
            }
            #[doc = "Bit 31 - Disable interrupt on PORT event."]
            #[inline]
            pub fn port(&mut self) -> _PORTW {
                _PORTW { w: self }
            }
        }
    }
    #[doc = "Channel configuration registers."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel configuration registers."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Channel configure in event mode."]
            EVENT,
            #[doc = "Channel configure in task mode."]
            TASK,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::DISABLED => 0,
                    MODER::EVENT => 0x01,
                    MODER::TASK => 0x03,
                    MODER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::DISABLED,
                    1 => MODER::EVENT,
                    3 => MODER::TASK,
                    i => MODER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MODER::DISABLED
            }
            #[doc = "Checks if the value of the field is `EVENT`"]
            #[inline]
            pub fn is_event(&self) -> bool {
                *self == MODER::EVENT
            }
            #[doc = "Checks if the value of the field is `TASK`"]
            #[inline]
            pub fn is_task(&self) -> bool {
                *self == MODER::TASK
            }
        }
        #[doc = r" Value of the field"]
        pub struct PSELR {
            bits: u8,
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `POLARITY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POLARITYR {
            #[doc = "No task or event."]
            NONE,
            #[doc = "Low to high."]
            LOTOHI,
            #[doc = "High to low."]
            HITOLO,
            #[doc = "Toggle."]
            TOGGLE,
        }
        impl POLARITYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    POLARITYR::NONE => 0,
                    POLARITYR::LOTOHI => 0x01,
                    POLARITYR::HITOLO => 0x02,
                    POLARITYR::TOGGLE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> POLARITYR {
                match value {
                    0 => POLARITYR::NONE,
                    1 => POLARITYR::LOTOHI,
                    2 => POLARITYR::HITOLO,
                    3 => POLARITYR::TOGGLE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == POLARITYR::NONE
            }
            #[doc = "Checks if the value of the field is `LOTOHI`"]
            #[inline]
            pub fn is_lo_to_hi(&self) -> bool {
                *self == POLARITYR::LOTOHI
            }
            #[doc = "Checks if the value of the field is `HITOLO`"]
            #[inline]
            pub fn is_hi_to_lo(&self) -> bool {
                *self == POLARITYR::HITOLO
            }
            #[doc = "Checks if the value of the field is `TOGGLE`"]
            #[inline]
            pub fn is_toggle(&self) -> bool {
                *self == POLARITYR::TOGGLE
            }
        }
        #[doc = "Possible values of the field `OUTINIT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OUTINITR {
            #[doc = "Initial low output when in task mode."]
            LOW,
            #[doc = "Initial high output when in task mode."]
            HIGH,
        }
        impl OUTINITR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OUTINITR::LOW => false,
                    OUTINITR::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OUTINITR {
                match value {
                    false => OUTINITR::LOW,
                    true => OUTINITR::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == OUTINITR::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == OUTINITR::HIGH
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Channel configure in event mode."]
            EVENT,
            #[doc = "Channel configure in task mode."]
            TASK,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::DISABLED => 0,
                    MODEW::EVENT => 1,
                    MODEW::TASK => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MODEW::DISABLED)
            }
            #[doc = "Channel configure in event mode."]
            #[inline]
            pub fn event(self) -> &'a mut W {
                self.variant(MODEW::EVENT)
            }
            #[doc = "Channel configure in task mode."]
            #[inline]
            pub fn task(self) -> &'a mut W {
                self.variant(MODEW::TASK)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `POLARITY`"]
        pub enum POLARITYW {
            #[doc = "No task or event."]
            NONE,
            #[doc = "Low to high."]
            LOTOHI,
            #[doc = "High to low."]
            HITOLO,
            #[doc = "Toggle."]
            TOGGLE,
        }
        impl POLARITYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    POLARITYW::NONE => 0,
                    POLARITYW::LOTOHI => 1,
                    POLARITYW::HITOLO => 2,
                    POLARITYW::TOGGLE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POLARITYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POLARITYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POLARITYW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No task or event."]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(POLARITYW::NONE)
            }
            #[doc = "Low to high."]
            #[inline]
            pub fn lo_to_hi(self) -> &'a mut W {
                self.variant(POLARITYW::LOTOHI)
            }
            #[doc = "High to low."]
            #[inline]
            pub fn hi_to_lo(self) -> &'a mut W {
                self.variant(POLARITYW::HITOLO)
            }
            #[doc = "Toggle."]
            #[inline]
            pub fn toggle(self) -> &'a mut W {
                self.variant(POLARITYW::TOGGLE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OUTINIT`"]
        pub enum OUTINITW {
            #[doc = "Initial low output when in task mode."]
            LOW,
            #[doc = "Initial high output when in task mode."]
            HIGH,
        }
        impl OUTINITW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OUTINITW::LOW => false,
                    OUTINITW::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OUTINITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OUTINITW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OUTINITW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Initial low output when in task mode."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(OUTINITW::LOW)
            }
            #[doc = "Initial high output when in task mode."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(OUTINITW::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Mode"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:12 - Pin select."]
            #[inline]
            pub fn psel(&self) -> PSELR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PSELR { bits }
            }
            #[doc = "Bits 16:17 - Effects on output when in Task mode, or events on input that generates an event."]
            #[inline]
            pub fn polarity(&self) -> POLARITYR {
                POLARITYR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 20 - Initial value of the output when the GPIOTE channel is configured as a Task."]
            #[inline]
            pub fn outinit(&self) -> OUTINITR {
                OUTINITR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Mode"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bits 8:12 - Pin select."]
            #[inline]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
            #[doc = "Bits 16:17 - Effects on output when in Task mode, or events on input that generates an event."]
            #[inline]
            pub fn polarity(&mut self) -> _POLARITYW {
                _POLARITYW { w: self }
            }
            #[doc = "Bit 20 - Initial value of the output when the GPIOTE channel is configured as a Task."]
            #[inline]
            pub fn outinit(&mut self) -> _OUTINITW {
                _OUTINITW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Analog to digital converter."]
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const adc::RegisterBlock {
        0x4000_7000 as *const _
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    fn deref(&self) -> &adc::RegisterBlock {
        unsafe { &*ADC::ptr() }
    }
}
#[doc = "Analog to digital converter."]
pub mod adc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start an ADC conversion."]
        pub tasks_start: TASKS_START,
        #[doc = "0x04 - Stop ADC."]
        pub tasks_stop: TASKS_STOP,
        _reserved0: [u8; 248usize],
        #[doc = "0x100 - ADC conversion complete."]
        pub events_end: EVENTS_END,
        _reserved1: [u8; 512usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved2: [u8; 244usize],
        #[doc = "0x400 - ADC busy register."]
        pub busy: BUSY,
        _reserved3: [u8; 252usize],
        #[doc = "0x500 - ADC enable."]
        pub enable: ENABLE,
        #[doc = "0x504 - ADC configuration register."]
        pub config: CONFIG,
        #[doc = "0x508 - Result of ADC conversion."]
        pub result: RESULT,
        _reserved4: [u8; 2800usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start an ADC conversion."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start an ADC conversion."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop ADC."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop ADC."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ADC conversion complete."]
    pub struct EVENTS_END {
        register: VolatileCell<u32>,
    }
    #[doc = "ADC conversion complete."]
    pub mod events_end {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_END {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `END`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDR::DISABLED => false,
                    ENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDR {
                match value {
                    false => ENDR::DISABLED,
                    true => ENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `END`"]
        pub enum ENDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on END event."]
            #[inline]
            pub fn end(&self) -> ENDR {
                ENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on END event."]
            #[inline]
            pub fn end(&mut self) -> _ENDW {
                _ENDW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `END`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDR::DISABLED => false,
                    ENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDR {
                match value {
                    false => ENDR::DISABLED,
                    true => ENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `END`"]
        pub enum ENDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on END event."]
            #[inline]
            pub fn end(&self) -> ENDR {
                ENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on END event."]
            #[inline]
            pub fn end(&mut self) -> _ENDW {
                _ENDW { w: self }
            }
        }
    }
    #[doc = "ADC busy register."]
    pub struct BUSY {
        register: VolatileCell<u32>,
    }
    #[doc = "ADC busy register."]
    pub mod busy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::BUSY {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `BUSY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BUSYR {
            #[doc = "No ongoing ADC conversion is taking place. ADC is ready."]
            READY,
            #[doc = "An ADC conversion is taking place. ADC is busy."]
            BUSY,
        }
        impl BUSYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BUSYR::READY => false,
                    BUSYR::BUSY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BUSYR {
                match value {
                    false => BUSYR::READY,
                    true => BUSYR::BUSY,
                }
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline]
            pub fn is_ready(&self) -> bool {
                *self == BUSYR::READY
            }
            #[doc = "Checks if the value of the field is `BUSY`"]
            #[inline]
            pub fn is_busy(&self) -> bool {
                *self == BUSYR::BUSY
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - ADC busy register."]
            #[inline]
            pub fn busy(&self) -> BUSYR {
                BUSYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "ADC enable."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "ADC enable."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "ADC is disabled."]
            DISABLED,
            #[doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x01,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    1 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "ADC is disabled."]
            DISABLED,
            #[doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "ADC is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - ADC enable."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - ADC enable."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "ADC configuration register."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "ADC configuration register."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RES`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESR {
            #[doc = "8bit ADC resolution."]
            _8BIT,
            #[doc = "9bit ADC resolution."]
            _9BIT,
            #[doc = "10bit ADC resolution."]
            _10BIT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl RESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    RESR::_8BIT => 0,
                    RESR::_9BIT => 0x01,
                    RESR::_10BIT => 0x02,
                    RESR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> RESR {
                match value {
                    0 => RESR::_8BIT,
                    1 => RESR::_9BIT,
                    2 => RESR::_10BIT,
                    i => RESR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_8BIT`"]
            #[inline]
            pub fn is_8bit(&self) -> bool {
                *self == RESR::_8BIT
            }
            #[doc = "Checks if the value of the field is `_9BIT`"]
            #[inline]
            pub fn is_9bit(&self) -> bool {
                *self == RESR::_9BIT
            }
            #[doc = "Checks if the value of the field is `_10BIT`"]
            #[inline]
            pub fn is_10bit(&self) -> bool {
                *self == RESR::_10BIT
            }
        }
        #[doc = "Possible values of the field `INPSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INPSELR {
            #[doc = "Analog input specified by PSEL with no prescaling used as input for the conversion."]
            ANALOGINPUTNOPRESCALING,
            #[doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion."]
            ANALOGINPUTTWOTHIRDSPRESCALING,
            #[doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion."]
            ANALOGINPUTONETHIRDPRESCALING,
            #[doc = "Supply voltage with 2/3 prescaling used as input for the conversion."]
            SUPPLYTWOTHIRDSPRESCALING,
            #[doc = "Supply voltage with 1/3 prescaling used as input for the conversion."]
            SUPPLYONETHIRDPRESCALING,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl INPSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    INPSELR::ANALOGINPUTNOPRESCALING => 0,
                    INPSELR::ANALOGINPUTTWOTHIRDSPRESCALING => 0x01,
                    INPSELR::ANALOGINPUTONETHIRDPRESCALING => 0x02,
                    INPSELR::SUPPLYTWOTHIRDSPRESCALING => 0x05,
                    INPSELR::SUPPLYONETHIRDPRESCALING => 0x06,
                    INPSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> INPSELR {
                match value {
                    0 => INPSELR::ANALOGINPUTNOPRESCALING,
                    1 => INPSELR::ANALOGINPUTTWOTHIRDSPRESCALING,
                    2 => INPSELR::ANALOGINPUTONETHIRDPRESCALING,
                    5 => INPSELR::SUPPLYTWOTHIRDSPRESCALING,
                    6 => INPSELR::SUPPLYONETHIRDPRESCALING,
                    i => INPSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUTNOPRESCALING`"]
            #[inline]
            pub fn is_analog_input_no_prescaling(&self) -> bool {
                *self == INPSELR::ANALOGINPUTNOPRESCALING
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUTTWOTHIRDSPRESCALING`"]
            #[inline]
            pub fn is_analog_input_two_thirds_prescaling(&self) -> bool {
                *self == INPSELR::ANALOGINPUTTWOTHIRDSPRESCALING
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUTONETHIRDPRESCALING`"]
            #[inline]
            pub fn is_analog_input_one_third_prescaling(&self) -> bool {
                *self == INPSELR::ANALOGINPUTONETHIRDPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYTWOTHIRDSPRESCALING`"]
            #[inline]
            pub fn is_supply_two_thirds_prescaling(&self) -> bool {
                *self == INPSELR::SUPPLYTWOTHIRDSPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYONETHIRDPRESCALING`"]
            #[inline]
            pub fn is_supply_one_third_prescaling(&self) -> bool {
                *self == INPSELR::SUPPLYONETHIRDPRESCALING
            }
        }
        #[doc = "Possible values of the field `REFSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFSELR {
            #[doc = "Use internal 1.2V bandgap voltage as reference for conversion."]
            VBG,
            #[doc = "Use external source configured by EXTREFSEL as reference for conversion."]
            EXTERNAL,
            #[doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V."]
            SUPPLYONEHALFPRESCALING,
            #[doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V."]
            SUPPLYONETHIRDPRESCALING,
        }
        impl REFSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    REFSELR::VBG => 0,
                    REFSELR::EXTERNAL => 0x01,
                    REFSELR::SUPPLYONEHALFPRESCALING => 0x02,
                    REFSELR::SUPPLYONETHIRDPRESCALING => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> REFSELR {
                match value {
                    0 => REFSELR::VBG,
                    1 => REFSELR::EXTERNAL,
                    2 => REFSELR::SUPPLYONEHALFPRESCALING,
                    3 => REFSELR::SUPPLYONETHIRDPRESCALING,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `VBG`"]
            #[inline]
            pub fn is_vbg(&self) -> bool {
                *self == REFSELR::VBG
            }
            #[doc = "Checks if the value of the field is `EXTERNAL`"]
            #[inline]
            pub fn is_external(&self) -> bool {
                *self == REFSELR::EXTERNAL
            }
            #[doc = "Checks if the value of the field is `SUPPLYONEHALFPRESCALING`"]
            #[inline]
            pub fn is_supply_one_half_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYONEHALFPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYONETHIRDPRESCALING`"]
            #[inline]
            pub fn is_supply_one_third_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYONETHIRDPRESCALING
            }
        }
        #[doc = "Possible values of the field `PSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSELR {
            #[doc = "Analog input pins disabled."]
            DISABLED,
            #[doc = "Use analog input 0 as analog input."]
            ANALOGINPUT0,
            #[doc = "Use analog input 1 as analog input."]
            ANALOGINPUT1,
            #[doc = "Use analog input 2 as analog input."]
            ANALOGINPUT2,
            #[doc = "Use analog input 3 as analog input."]
            ANALOGINPUT3,
            #[doc = "Use analog input 4 as analog input."]
            ANALOGINPUT4,
            #[doc = "Use analog input 5 as analog input."]
            ANALOGINPUT5,
            #[doc = "Use analog input 6 as analog input."]
            ANALOGINPUT6,
            #[doc = "Use analog input 7 as analog input."]
            ANALOGINPUT7,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSELR::DISABLED => 0,
                    PSELR::ANALOGINPUT0 => 0x01,
                    PSELR::ANALOGINPUT1 => 0x02,
                    PSELR::ANALOGINPUT2 => 0x04,
                    PSELR::ANALOGINPUT3 => 0x08,
                    PSELR::ANALOGINPUT4 => 0x10,
                    PSELR::ANALOGINPUT5 => 0x20,
                    PSELR::ANALOGINPUT6 => 0x40,
                    PSELR::ANALOGINPUT7 => 0x80,
                    PSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PSELR {
                match value {
                    0 => PSELR::DISABLED,
                    1 => PSELR::ANALOGINPUT0,
                    2 => PSELR::ANALOGINPUT1,
                    4 => PSELR::ANALOGINPUT2,
                    8 => PSELR::ANALOGINPUT3,
                    16 => PSELR::ANALOGINPUT4,
                    32 => PSELR::ANALOGINPUT5,
                    64 => PSELR::ANALOGINPUT6,
                    128 => PSELR::ANALOGINPUT7,
                    i => PSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PSELR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT0`"]
            #[inline]
            pub fn is_analog_input0(&self) -> bool {
                *self == PSELR::ANALOGINPUT0
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT1`"]
            #[inline]
            pub fn is_analog_input1(&self) -> bool {
                *self == PSELR::ANALOGINPUT1
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT2`"]
            #[inline]
            pub fn is_analog_input2(&self) -> bool {
                *self == PSELR::ANALOGINPUT2
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT3`"]
            #[inline]
            pub fn is_analog_input3(&self) -> bool {
                *self == PSELR::ANALOGINPUT3
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT4`"]
            #[inline]
            pub fn is_analog_input4(&self) -> bool {
                *self == PSELR::ANALOGINPUT4
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT5`"]
            #[inline]
            pub fn is_analog_input5(&self) -> bool {
                *self == PSELR::ANALOGINPUT5
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT6`"]
            #[inline]
            pub fn is_analog_input6(&self) -> bool {
                *self == PSELR::ANALOGINPUT6
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT7`"]
            #[inline]
            pub fn is_analog_input7(&self) -> bool {
                *self == PSELR::ANALOGINPUT7
            }
        }
        #[doc = "Possible values of the field `EXTREFSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTREFSELR {
            #[doc = "Analog external reference inputs disabled."]
            NONE,
            #[doc = "Use analog reference 0 as reference."]
            ANALOGREFERENCE0,
            #[doc = "Use analog reference 1 as reference."]
            ANALOGREFERENCE1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl EXTREFSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EXTREFSELR::NONE => 0,
                    EXTREFSELR::ANALOGREFERENCE0 => 0x01,
                    EXTREFSELR::ANALOGREFERENCE1 => 0x02,
                    EXTREFSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EXTREFSELR {
                match value {
                    0 => EXTREFSELR::NONE,
                    1 => EXTREFSELR::ANALOGREFERENCE0,
                    2 => EXTREFSELR::ANALOGREFERENCE1,
                    i => EXTREFSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NONE`"]
            #[inline]
            pub fn is_none(&self) -> bool {
                *self == EXTREFSELR::NONE
            }
            #[doc = "Checks if the value of the field is `ANALOGREFERENCE0`"]
            #[inline]
            pub fn is_analog_reference0(&self) -> bool {
                *self == EXTREFSELR::ANALOGREFERENCE0
            }
            #[doc = "Checks if the value of the field is `ANALOGREFERENCE1`"]
            #[inline]
            pub fn is_analog_reference1(&self) -> bool {
                *self == EXTREFSELR::ANALOGREFERENCE1
            }
        }
        #[doc = "Values that can be written to the field `RES`"]
        pub enum RESW {
            #[doc = "8bit ADC resolution."]
            _8BIT,
            #[doc = "9bit ADC resolution."]
            _9BIT,
            #[doc = "10bit ADC resolution."]
            _10BIT,
        }
        impl RESW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RESW::_8BIT => 0,
                    RESW::_9BIT => 1,
                    RESW::_10BIT => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RESW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "8bit ADC resolution."]
            #[inline]
            pub fn _8bit(self) -> &'a mut W {
                self.variant(RESW::_8BIT)
            }
            #[doc = "9bit ADC resolution."]
            #[inline]
            pub fn _9bit(self) -> &'a mut W {
                self.variant(RESW::_9BIT)
            }
            #[doc = "10bit ADC resolution."]
            #[inline]
            pub fn _10bit(self) -> &'a mut W {
                self.variant(RESW::_10BIT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INPSEL`"]
        pub enum INPSELW {
            #[doc = "Analog input specified by PSEL with no prescaling used as input for the conversion."]
            ANALOGINPUTNOPRESCALING,
            #[doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion."]
            ANALOGINPUTTWOTHIRDSPRESCALING,
            #[doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion."]
            ANALOGINPUTONETHIRDPRESCALING,
            #[doc = "Supply voltage with 2/3 prescaling used as input for the conversion."]
            SUPPLYTWOTHIRDSPRESCALING,
            #[doc = "Supply voltage with 1/3 prescaling used as input for the conversion."]
            SUPPLYONETHIRDPRESCALING,
        }
        impl INPSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    INPSELW::ANALOGINPUTNOPRESCALING => 0,
                    INPSELW::ANALOGINPUTTWOTHIRDSPRESCALING => 1,
                    INPSELW::ANALOGINPUTONETHIRDPRESCALING => 2,
                    INPSELW::SUPPLYTWOTHIRDSPRESCALING => 5,
                    INPSELW::SUPPLYONETHIRDPRESCALING => 6,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INPSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Analog input specified by PSEL with no prescaling used as input for the conversion."]
            #[inline]
            pub fn analog_input_no_prescaling(self) -> &'a mut W {
                self.variant(INPSELW::ANALOGINPUTNOPRESCALING)
            }
            #[doc = "Analog input specified by PSEL with 2/3 prescaling used as input for the conversion."]
            #[inline]
            pub fn analog_input_two_thirds_prescaling(self) -> &'a mut W {
                self.variant(INPSELW::ANALOGINPUTTWOTHIRDSPRESCALING)
            }
            #[doc = "Analog input specified by PSEL with 1/3 prescaling used as input for the conversion."]
            #[inline]
            pub fn analog_input_one_third_prescaling(self) -> &'a mut W {
                self.variant(INPSELW::ANALOGINPUTONETHIRDPRESCALING)
            }
            #[doc = "Supply voltage with 2/3 prescaling used as input for the conversion."]
            #[inline]
            pub fn supply_two_thirds_prescaling(self) -> &'a mut W {
                self.variant(INPSELW::SUPPLYTWOTHIRDSPRESCALING)
            }
            #[doc = "Supply voltage with 1/3 prescaling used as input for the conversion."]
            #[inline]
            pub fn supply_one_third_prescaling(self) -> &'a mut W {
                self.variant(INPSELW::SUPPLYONETHIRDPRESCALING)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REFSEL`"]
        pub enum REFSELW {
            #[doc = "Use internal 1.2V bandgap voltage as reference for conversion."]
            VBG,
            #[doc = "Use external source configured by EXTREFSEL as reference for conversion."]
            EXTERNAL,
            #[doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V."]
            SUPPLYONEHALFPRESCALING,
            #[doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V."]
            SUPPLYONETHIRDPRESCALING,
        }
        impl REFSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    REFSELW::VBG => 0,
                    REFSELW::EXTERNAL => 1,
                    REFSELW::SUPPLYONEHALFPRESCALING => 2,
                    REFSELW::SUPPLYONETHIRDPRESCALING => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: REFSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Use internal 1.2V bandgap voltage as reference for conversion."]
            #[inline]
            pub fn vbg(self) -> &'a mut W {
                self.variant(REFSELW::VBG)
            }
            #[doc = "Use external source configured by EXTREFSEL as reference for conversion."]
            #[inline]
            pub fn external(self) -> &'a mut W {
                self.variant(REFSELW::EXTERNAL)
            }
            #[doc = "Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V."]
            #[inline]
            pub fn supply_one_half_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYONEHALFPRESCALING)
            }
            #[doc = "Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V."]
            #[inline]
            pub fn supply_one_third_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYONETHIRDPRESCALING)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PSEL`"]
        pub enum PSELW {
            #[doc = "Analog input pins disabled."]
            DISABLED,
            #[doc = "Use analog input 0 as analog input."]
            ANALOGINPUT0,
            #[doc = "Use analog input 1 as analog input."]
            ANALOGINPUT1,
            #[doc = "Use analog input 2 as analog input."]
            ANALOGINPUT2,
            #[doc = "Use analog input 3 as analog input."]
            ANALOGINPUT3,
            #[doc = "Use analog input 4 as analog input."]
            ANALOGINPUT4,
            #[doc = "Use analog input 5 as analog input."]
            ANALOGINPUT5,
            #[doc = "Use analog input 6 as analog input."]
            ANALOGINPUT6,
            #[doc = "Use analog input 7 as analog input."]
            ANALOGINPUT7,
        }
        impl PSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PSELW::DISABLED => 0,
                    PSELW::ANALOGINPUT0 => 1,
                    PSELW::ANALOGINPUT1 => 2,
                    PSELW::ANALOGINPUT2 => 4,
                    PSELW::ANALOGINPUT3 => 8,
                    PSELW::ANALOGINPUT4 => 16,
                    PSELW::ANALOGINPUT5 => 32,
                    PSELW::ANALOGINPUT6 => 64,
                    PSELW::ANALOGINPUT7 => 128,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Analog input pins disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PSELW::DISABLED)
            }
            #[doc = "Use analog input 0 as analog input."]
            #[inline]
            pub fn analog_input0(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT0)
            }
            #[doc = "Use analog input 1 as analog input."]
            #[inline]
            pub fn analog_input1(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT1)
            }
            #[doc = "Use analog input 2 as analog input."]
            #[inline]
            pub fn analog_input2(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT2)
            }
            #[doc = "Use analog input 3 as analog input."]
            #[inline]
            pub fn analog_input3(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT3)
            }
            #[doc = "Use analog input 4 as analog input."]
            #[inline]
            pub fn analog_input4(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT4)
            }
            #[doc = "Use analog input 5 as analog input."]
            #[inline]
            pub fn analog_input5(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT5)
            }
            #[doc = "Use analog input 6 as analog input."]
            #[inline]
            pub fn analog_input6(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT6)
            }
            #[doc = "Use analog input 7 as analog input."]
            #[inline]
            pub fn analog_input7(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EXTREFSEL`"]
        pub enum EXTREFSELW {
            #[doc = "Analog external reference inputs disabled."]
            NONE,
            #[doc = "Use analog reference 0 as reference."]
            ANALOGREFERENCE0,
            #[doc = "Use analog reference 1 as reference."]
            ANALOGREFERENCE1,
        }
        impl EXTREFSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EXTREFSELW::NONE => 0,
                    EXTREFSELW::ANALOGREFERENCE0 => 1,
                    EXTREFSELW::ANALOGREFERENCE1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTREFSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTREFSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EXTREFSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Analog external reference inputs disabled."]
            #[inline]
            pub fn none(self) -> &'a mut W {
                self.variant(EXTREFSELW::NONE)
            }
            #[doc = "Use analog reference 0 as reference."]
            #[inline]
            pub fn analog_reference0(self) -> &'a mut W {
                self.variant(EXTREFSELW::ANALOGREFERENCE0)
            }
            #[doc = "Use analog reference 1 as reference."]
            #[inline]
            pub fn analog_reference1(self) -> &'a mut W {
                self.variant(EXTREFSELW::ANALOGREFERENCE1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - ADC resolution."]
            #[inline]
            pub fn res(&self) -> RESR {
                RESR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:4 - ADC input selection."]
            #[inline]
            pub fn inpsel(&self) -> INPSELR {
                INPSELR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 5:6 - ADC reference selection."]
            #[inline]
            pub fn refsel(&self) -> REFSELR {
                REFSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:15 - ADC analog pin selection."]
            #[inline]
            pub fn psel(&self) -> PSELR {
                PSELR::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:17 - ADC external reference pin selection."]
            #[inline]
            pub fn extrefsel(&self) -> EXTREFSELR {
                EXTREFSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x18 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - ADC resolution."]
            #[inline]
            pub fn res(&mut self) -> _RESW {
                _RESW { w: self }
            }
            #[doc = "Bits 2:4 - ADC input selection."]
            #[inline]
            pub fn inpsel(&mut self) -> _INPSELW {
                _INPSELW { w: self }
            }
            #[doc = "Bits 5:6 - ADC reference selection."]
            #[inline]
            pub fn refsel(&mut self) -> _REFSELW {
                _REFSELW { w: self }
            }
            #[doc = "Bits 8:15 - ADC analog pin selection."]
            #[inline]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
            #[doc = "Bits 16:17 - ADC external reference pin selection."]
            #[inline]
            pub fn extrefsel(&mut self) -> _EXTREFSELW {
                _EXTREFSELW { w: self }
            }
        }
    }
    #[doc = "Result of ADC conversion."]
    pub struct RESULT {
        register: VolatileCell<u32>,
    }
    #[doc = "Result of ADC conversion."]
    pub mod result {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RESULT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RESULTR {
            bits: u16,
        }
        impl RESULTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - Result of ADC conversion."]
            #[inline]
            pub fn result(&self) -> RESULTR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                RESULTR { bits }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Timer 0."]
pub struct TIMER0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER0 {}
impl TIMER0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const timer0::RegisterBlock {
        0x4000_8000 as *const _
    }
}
impl Deref for TIMER0 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        unsafe { &*TIMER0::ptr() }
    }
}
#[doc = "Timer 0."]
pub mod timer0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start Timer."]
        pub tasks_start: TASKS_START,
        #[doc = "0x04 - Stop Timer."]
        pub tasks_stop: TASKS_STOP,
        #[doc = "0x08 - Increment Timer (In counter mode)."]
        pub tasks_count: TASKS_COUNT,
        #[doc = "0x0c - Clear timer."]
        pub tasks_clear: TASKS_CLEAR,
        #[doc = "0x10 - Shutdown timer."]
        pub tasks_shutdown: TASKS_SHUTDOWN,
        _reserved0: [u8; 44usize],
        #[doc = "0x40 - Capture Timer value to CC[n] registers."]
        pub tasks_capture: [TASKS_CAPTURE; 4],
        _reserved1: [u8; 240usize],
        #[doc = "0x140 - Compare event on CC[n] match."]
        pub events_compare: [EVENTS_COMPARE; 4],
        _reserved2: [u8; 176usize],
        #[doc = "0x200 - Shortcuts for Timer."]
        pub shorts: SHORTS,
        _reserved3: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved4: [u8; 504usize],
        #[doc = "0x504 - Timer Mode selection."]
        pub mode: MODE,
        #[doc = "0x508 - Sets timer behaviour."]
        pub bitmode: BITMODE,
        _reserved5: [u8; 4usize],
        #[doc = "0x510 - 4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE."]
        pub prescaler: PRESCALER,
        _reserved6: [u8; 44usize],
        #[doc = "0x540 - Capture/compare registers."]
        pub cc: [CC; 4],
        _reserved7: [u8; 2732usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start Timer."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start Timer."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop Timer."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop Timer."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Increment Timer (In counter mode)."]
    pub struct TASKS_COUNT {
        register: VolatileCell<u32>,
    }
    #[doc = "Increment Timer (In counter mode)."]
    pub mod tasks_count {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_COUNT {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Clear timer."]
    pub struct TASKS_CLEAR {
        register: VolatileCell<u32>,
    }
    #[doc = "Clear timer."]
    pub mod tasks_clear {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_CLEAR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shutdown timer."]
    pub struct TASKS_SHUTDOWN {
        register: VolatileCell<u32>,
    }
    #[doc = "Shutdown timer."]
    pub mod tasks_shutdown {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_SHUTDOWN {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Capture Timer value to CC[n] registers."]
    pub struct TASKS_CAPTURE {
        register: VolatileCell<u32>,
    }
    #[doc = "Capture Timer value to CC[n] registers."]
    pub mod tasks_capture {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_CAPTURE {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Compare event on CC[n] match."]
    pub struct EVENTS_COMPARE {
        register: VolatileCell<u32>,
    }
    #[doc = "Compare event on CC[n] match."]
    pub mod events_compare {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_COMPARE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for Timer."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for Timer."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `COMPARE0_CLEAR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0_CLEARR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE0_CLEARR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0_CLEARR::DISABLED => false,
                    COMPARE0_CLEARR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0_CLEARR {
                match value {
                    false => COMPARE0_CLEARR::DISABLED,
                    true => COMPARE0_CLEARR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0_CLEARR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0_CLEARR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1_CLEAR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1_CLEARR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE1_CLEARR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1_CLEARR::DISABLED => false,
                    COMPARE1_CLEARR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1_CLEARR {
                match value {
                    false => COMPARE1_CLEARR::DISABLED,
                    true => COMPARE1_CLEARR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1_CLEARR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1_CLEARR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2_CLEAR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2_CLEARR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE2_CLEARR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2_CLEARR::DISABLED => false,
                    COMPARE2_CLEARR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2_CLEARR {
                match value {
                    false => COMPARE2_CLEARR::DISABLED,
                    true => COMPARE2_CLEARR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2_CLEARR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2_CLEARR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3_CLEAR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3_CLEARR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE3_CLEARR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3_CLEARR::DISABLED => false,
                    COMPARE3_CLEARR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3_CLEARR {
                match value {
                    false => COMPARE3_CLEARR::DISABLED,
                    true => COMPARE3_CLEARR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3_CLEARR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3_CLEARR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE0_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE0_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0_STOPR::DISABLED => false,
                    COMPARE0_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0_STOPR {
                match value {
                    false => COMPARE0_STOPR::DISABLED,
                    true => COMPARE0_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0_STOPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE1_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1_STOPR::DISABLED => false,
                    COMPARE1_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1_STOPR {
                match value {
                    false => COMPARE1_STOPR::DISABLED,
                    true => COMPARE1_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1_STOPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE2_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2_STOPR::DISABLED => false,
                    COMPARE2_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2_STOPR {
                match value {
                    false => COMPARE2_STOPR::DISABLED,
                    true => COMPARE2_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2_STOPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE3_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3_STOPR::DISABLED => false,
                    COMPARE3_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3_STOPR {
                match value {
                    false => COMPARE3_STOPR::DISABLED,
                    true => COMPARE3_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3_STOPR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0_CLEAR`"]
        pub enum COMPARE0_CLEARW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE0_CLEARW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0_CLEARW::DISABLED => false,
                    COMPARE0_CLEARW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0_CLEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0_CLEARW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0_CLEARW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE0_CLEARW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE0_CLEARW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1_CLEAR`"]
        pub enum COMPARE1_CLEARW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE1_CLEARW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1_CLEARW::DISABLED => false,
                    COMPARE1_CLEARW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1_CLEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1_CLEARW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1_CLEARW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE1_CLEARW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE1_CLEARW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2_CLEAR`"]
        pub enum COMPARE2_CLEARW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE2_CLEARW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2_CLEARW::DISABLED => false,
                    COMPARE2_CLEARW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2_CLEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2_CLEARW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2_CLEARW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE2_CLEARW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE2_CLEARW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3_CLEAR`"]
        pub enum COMPARE3_CLEARW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE3_CLEARW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3_CLEARW::DISABLED => false,
                    COMPARE3_CLEARW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3_CLEARW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3_CLEARW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3_CLEARW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE3_CLEARW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE3_CLEARW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0_STOP`"]
        pub enum COMPARE0_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE0_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0_STOPW::DISABLED => false,
                    COMPARE0_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE0_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE0_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1_STOP`"]
        pub enum COMPARE1_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE1_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1_STOPW::DISABLED => false,
                    COMPARE1_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE1_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE1_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2_STOP`"]
        pub enum COMPARE2_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE2_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2_STOPW::DISABLED => false,
                    COMPARE2_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE2_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE2_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3_STOP`"]
        pub enum COMPARE3_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl COMPARE3_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3_STOPW::DISABLED => false,
                    COMPARE3_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE3_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE3_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Shortcut between CC[0] event and the CLEAR task."]
            #[inline]
            pub fn compare0_clear(&self) -> COMPARE0_CLEARR {
                COMPARE0_CLEARR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Shortcut between CC[1] event and the CLEAR task."]
            #[inline]
            pub fn compare1_clear(&self) -> COMPARE1_CLEARR {
                COMPARE1_CLEARR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Shortcut between CC[2] event and the CLEAR task."]
            #[inline]
            pub fn compare2_clear(&self) -> COMPARE2_CLEARR {
                COMPARE2_CLEARR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Shortcut between CC[3] event and the CLEAR task."]
            #[inline]
            pub fn compare3_clear(&self) -> COMPARE3_CLEARR {
                COMPARE3_CLEARR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Shortcut between CC[0] event and the STOP task."]
            #[inline]
            pub fn compare0_stop(&self) -> COMPARE0_STOPR {
                COMPARE0_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Shortcut between CC[1] event and the STOP task."]
            #[inline]
            pub fn compare1_stop(&self) -> COMPARE1_STOPR {
                COMPARE1_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Shortcut between CC[2] event and the STOP task."]
            #[inline]
            pub fn compare2_stop(&self) -> COMPARE2_STOPR {
                COMPARE2_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Shortcut between CC[3] event and the STOP task."]
            #[inline]
            pub fn compare3_stop(&self) -> COMPARE3_STOPR {
                COMPARE3_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Shortcut between CC[0] event and the CLEAR task."]
            #[inline]
            pub fn compare0_clear(&mut self) -> _COMPARE0_CLEARW {
                _COMPARE0_CLEARW { w: self }
            }
            #[doc = "Bit 1 - Shortcut between CC[1] event and the CLEAR task."]
            #[inline]
            pub fn compare1_clear(&mut self) -> _COMPARE1_CLEARW {
                _COMPARE1_CLEARW { w: self }
            }
            #[doc = "Bit 2 - Shortcut between CC[2] event and the CLEAR task."]
            #[inline]
            pub fn compare2_clear(&mut self) -> _COMPARE2_CLEARW {
                _COMPARE2_CLEARW { w: self }
            }
            #[doc = "Bit 3 - Shortcut between CC[3] event and the CLEAR task."]
            #[inline]
            pub fn compare3_clear(&mut self) -> _COMPARE3_CLEARW {
                _COMPARE3_CLEARW { w: self }
            }
            #[doc = "Bit 8 - Shortcut between CC[0] event and the STOP task."]
            #[inline]
            pub fn compare0_stop(&mut self) -> _COMPARE0_STOPW {
                _COMPARE0_STOPW { w: self }
            }
            #[doc = "Bit 9 - Shortcut between CC[1] event and the STOP task."]
            #[inline]
            pub fn compare1_stop(&mut self) -> _COMPARE1_STOPW {
                _COMPARE1_STOPW { w: self }
            }
            #[doc = "Bit 10 - Shortcut between CC[2] event and the STOP task."]
            #[inline]
            pub fn compare2_stop(&mut self) -> _COMPARE2_STOPW {
                _COMPARE2_STOPW { w: self }
            }
            #[doc = "Bit 11 - Shortcut between CC[3] event and the STOP task."]
            #[inline]
            pub fn compare3_stop(&mut self) -> _COMPARE3_STOPW {
                _COMPARE3_STOPW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `COMPARE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0R::DISABLED => false,
                    COMPARE0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0R {
                match value {
                    false => COMPARE0R::DISABLED,
                    true => COMPARE0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1R::DISABLED => false,
                    COMPARE1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1R {
                match value {
                    false => COMPARE1R::DISABLED,
                    true => COMPARE1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2R::DISABLED => false,
                    COMPARE2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2R {
                match value {
                    false => COMPARE2R::DISABLED,
                    true => COMPARE2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3R::DISABLED => false,
                    COMPARE3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3R {
                match value {
                    false => COMPARE3R::DISABLED,
                    true => COMPARE3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0`"]
        pub enum COMPARE0W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl COMPARE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1`"]
        pub enum COMPARE1W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl COMPARE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE1W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2`"]
        pub enum COMPARE2W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl COMPARE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE2W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3`"]
        pub enum COMPARE3W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl COMPARE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE3W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 16 - Enable interrupt on COMPARE[0]"]
            #[inline]
            pub fn compare0(&self) -> COMPARE0R {
                COMPARE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Enable interrupt on COMPARE[1]"]
            #[inline]
            pub fn compare1(&self) -> COMPARE1R {
                COMPARE1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Enable interrupt on COMPARE[2]"]
            #[inline]
            pub fn compare2(&self) -> COMPARE2R {
                COMPARE2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Enable interrupt on COMPARE[3]"]
            #[inline]
            pub fn compare3(&self) -> COMPARE3R {
                COMPARE3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 16 - Enable interrupt on COMPARE[0]"]
            #[inline]
            pub fn compare0(&mut self) -> _COMPARE0W {
                _COMPARE0W { w: self }
            }
            #[doc = "Bit 17 - Enable interrupt on COMPARE[1]"]
            #[inline]
            pub fn compare1(&mut self) -> _COMPARE1W {
                _COMPARE1W { w: self }
            }
            #[doc = "Bit 18 - Enable interrupt on COMPARE[2]"]
            #[inline]
            pub fn compare2(&mut self) -> _COMPARE2W {
                _COMPARE2W { w: self }
            }
            #[doc = "Bit 19 - Enable interrupt on COMPARE[3]"]
            #[inline]
            pub fn compare3(&mut self) -> _COMPARE3W {
                _COMPARE3W { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `COMPARE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0R::DISABLED => false,
                    COMPARE0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0R {
                match value {
                    false => COMPARE0R::DISABLED,
                    true => COMPARE0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1R::DISABLED => false,
                    COMPARE1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1R {
                match value {
                    false => COMPARE1R::DISABLED,
                    true => COMPARE1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2R::DISABLED => false,
                    COMPARE2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2R {
                match value {
                    false => COMPARE2R::DISABLED,
                    true => COMPARE2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3R::DISABLED => false,
                    COMPARE3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3R {
                match value {
                    false => COMPARE3R::DISABLED,
                    true => COMPARE3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0`"]
        pub enum COMPARE0W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl COMPARE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE0W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1`"]
        pub enum COMPARE1W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl COMPARE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2`"]
        pub enum COMPARE2W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl COMPARE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE2W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3`"]
        pub enum COMPARE3W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl COMPARE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE3W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 16 - Disable interrupt on COMPARE[0]"]
            #[inline]
            pub fn compare0(&self) -> COMPARE0R {
                COMPARE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Disable interrupt on COMPARE[1]"]
            #[inline]
            pub fn compare1(&self) -> COMPARE1R {
                COMPARE1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Disable interrupt on COMPARE[2]"]
            #[inline]
            pub fn compare2(&self) -> COMPARE2R {
                COMPARE2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Disable interrupt on COMPARE[3]"]
            #[inline]
            pub fn compare3(&self) -> COMPARE3R {
                COMPARE3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 16 - Disable interrupt on COMPARE[0]"]
            #[inline]
            pub fn compare0(&mut self) -> _COMPARE0W {
                _COMPARE0W { w: self }
            }
            #[doc = "Bit 17 - Disable interrupt on COMPARE[1]"]
            #[inline]
            pub fn compare1(&mut self) -> _COMPARE1W {
                _COMPARE1W { w: self }
            }
            #[doc = "Bit 18 - Disable interrupt on COMPARE[2]"]
            #[inline]
            pub fn compare2(&mut self) -> _COMPARE2W {
                _COMPARE2W { w: self }
            }
            #[doc = "Bit 19 - Disable interrupt on COMPARE[3]"]
            #[inline]
            pub fn compare3(&mut self) -> _COMPARE3W {
                _COMPARE3W { w: self }
            }
        }
    }
    #[doc = "Timer Mode selection."]
    pub struct MODE {
        register: VolatileCell<u32>,
    }
    #[doc = "Timer Mode selection."]
    pub mod mode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Timer in Counter mode."]
            COUNTER,
            #[doc = "Timer in Normal mode."]
            TIMER,
        }
        impl MODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MODER::COUNTER => true,
                    MODER::TIMER => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MODER {
                match value {
                    true => MODER::COUNTER,
                    false => MODER::TIMER,
                }
            }
            #[doc = "Checks if the value of the field is `COUNTER`"]
            #[inline]
            pub fn is_counter(&self) -> bool {
                *self == MODER::COUNTER
            }
            #[doc = "Checks if the value of the field is `TIMER`"]
            #[inline]
            pub fn is_timer(&self) -> bool {
                *self == MODER::TIMER
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Timer in Counter mode."]
            COUNTER,
            #[doc = "Timer in Normal mode."]
            TIMER,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MODEW::COUNTER => true,
                    MODEW::TIMER => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Timer in Counter mode."]
            #[inline]
            pub fn counter(self) -> &'a mut W {
                self.variant(MODEW::COUNTER)
            }
            #[doc = "Timer in Normal mode."]
            #[inline]
            pub fn timer(self) -> &'a mut W {
                self.variant(MODEW::TIMER)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Select Normal or Counter mode."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Select Normal or Counter mode."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
        }
    }
    #[doc = "Sets timer behaviour."]
    pub struct BITMODE {
        register: VolatileCell<u32>,
    }
    #[doc = "Sets timer behaviour."]
    pub mod bitmode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BITMODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BITMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BITMODER {
            #[doc = "16-bit timer behaviour."]
            _16BIT,
            #[doc = "8-bit timer behaviour."]
            _08BIT,
            #[doc = "24-bit timer behaviour."]
            _24BIT,
            #[doc = "32-bit timer behaviour."]
            _32BIT,
        }
        impl BITMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    BITMODER::_16BIT => 0,
                    BITMODER::_08BIT => 0x01,
                    BITMODER::_24BIT => 0x02,
                    BITMODER::_32BIT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> BITMODER {
                match value {
                    0 => BITMODER::_16BIT,
                    1 => BITMODER::_08BIT,
                    2 => BITMODER::_24BIT,
                    3 => BITMODER::_32BIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_16BIT`"]
            #[inline]
            pub fn is_16bit(&self) -> bool {
                *self == BITMODER::_16BIT
            }
            #[doc = "Checks if the value of the field is `_08BIT`"]
            #[inline]
            pub fn is_08bit(&self) -> bool {
                *self == BITMODER::_08BIT
            }
            #[doc = "Checks if the value of the field is `_24BIT`"]
            #[inline]
            pub fn is_24bit(&self) -> bool {
                *self == BITMODER::_24BIT
            }
            #[doc = "Checks if the value of the field is `_32BIT`"]
            #[inline]
            pub fn is_32bit(&self) -> bool {
                *self == BITMODER::_32BIT
            }
        }
        #[doc = "Values that can be written to the field `BITMODE`"]
        pub enum BITMODEW {
            #[doc = "16-bit timer behaviour."]
            _16BIT,
            #[doc = "8-bit timer behaviour."]
            _08BIT,
            #[doc = "24-bit timer behaviour."]
            _24BIT,
            #[doc = "32-bit timer behaviour."]
            _32BIT,
        }
        impl BITMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BITMODEW::_16BIT => 0,
                    BITMODEW::_08BIT => 1,
                    BITMODEW::_24BIT => 2,
                    BITMODEW::_32BIT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BITMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BITMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BITMODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "16-bit timer behaviour."]
            #[inline]
            pub fn _16bit(self) -> &'a mut W {
                self.variant(BITMODEW::_16BIT)
            }
            #[doc = "8-bit timer behaviour."]
            #[inline]
            pub fn _08bit(self) -> &'a mut W {
                self.variant(BITMODEW::_08BIT)
            }
            #[doc = "24-bit timer behaviour."]
            #[inline]
            pub fn _24bit(self) -> &'a mut W {
                self.variant(BITMODEW::_24BIT)
            }
            #[doc = "32-bit timer behaviour."]
            #[inline]
            pub fn _32bit(self) -> &'a mut W {
                self.variant(BITMODEW::_32BIT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Sets timer behaviour ro be like the implementation of a timer with width as indicated."]
            #[inline]
            pub fn bitmode(&self) -> BITMODER {
                BITMODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Sets timer behaviour ro be like the implementation of a timer with width as indicated."]
            #[inline]
            pub fn bitmode(&mut self) -> _BITMODEW {
                _BITMODEW { w: self }
            }
        }
    }
    #[doc = "4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE."]
    pub struct PRESCALER {
        register: VolatileCell<u32>,
    }
    #[doc = "4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE."]
    pub mod prescaler {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRESCALER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRESCALERR {
            bits: u8,
        }
        impl PRESCALERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCALERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCALERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Timer PRESCALER value. Max value is 9."]
            #[inline]
            pub fn prescaler(&self) -> PRESCALERR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PRESCALERR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x04 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Timer PRESCALER value. Max value is 9."]
            #[inline]
            pub fn prescaler(&mut self) -> _PRESCALERW {
                _PRESCALERW { w: self }
            }
        }
    }
    #[doc = "Capture/compare registers."]
    pub struct CC {
        register: VolatileCell<u32>,
    }
    #[doc = "Capture/compare registers."]
    pub mod cc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Timer 1."]
pub struct TIMER1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER1 {}
impl TIMER1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const timer0::RegisterBlock {
        0x4000_9000 as *const _
    }
}
impl Deref for TIMER1 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        unsafe { &*TIMER1::ptr() }
    }
}
#[doc = "Timer 2."]
pub struct TIMER2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIMER2 {}
impl TIMER2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const timer0::RegisterBlock {
        0x4000_a000 as *const _
    }
}
impl Deref for TIMER2 {
    type Target = timer0::RegisterBlock;
    fn deref(&self) -> &timer0::RegisterBlock {
        unsafe { &*TIMER2::ptr() }
    }
}
#[doc = "Real time counter 0."]
pub struct RTC0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC0 {}
impl RTC0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const rtc0::RegisterBlock {
        0x4000_b000 as *const _
    }
}
impl Deref for RTC0 {
    type Target = rtc0::RegisterBlock;
    fn deref(&self) -> &rtc0::RegisterBlock {
        unsafe { &*RTC0::ptr() }
    }
}
#[doc = "Real time counter 0."]
pub mod rtc0 {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start RTC Counter."]
        pub tasks_start: TASKS_START,
        #[doc = "0x04 - Stop RTC Counter."]
        pub tasks_stop: TASKS_STOP,
        #[doc = "0x08 - Clear RTC Counter."]
        pub tasks_clear: TASKS_CLEAR,
        #[doc = "0x0c - Set COUNTER to 0xFFFFFFF0."]
        pub tasks_trigovrflw: TASKS_TRIGOVRFLW,
        _reserved0: [u8; 240usize],
        #[doc = "0x100 - Event on COUNTER increment."]
        pub events_tick: EVENTS_TICK,
        #[doc = "0x104 - Event on COUNTER overflow."]
        pub events_ovrflw: EVENTS_OVRFLW,
        _reserved1: [u8; 56usize],
        #[doc = "0x140 - Compare event on CC[n] match."]
        pub events_compare: [EVENTS_COMPARE; 4],
        _reserved2: [u8; 436usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 52usize],
        #[doc = "0x340 - Configures event enable routing to PPI for each RTC event."]
        pub evten: EVTEN,
        #[doc = "0x344 - Enable events routing to PPI. The reading of this register gives the value of EVTEN."]
        pub evtenset: EVTENSET,
        #[doc = "0x348 - Disable events routing to PPI. The reading of this register gives the value of EVTEN."]
        pub evtenclr: EVTENCLR,
        _reserved4: [u8; 440usize],
        #[doc = "0x504 - Current COUNTER value."]
        pub counter: COUNTER,
        #[doc = "0x508 - 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed."]
        pub prescaler: PRESCALER,
        _reserved5: [u8; 52usize],
        #[doc = "0x540 - Capture/compare registers."]
        pub cc: [CC; 4],
        _reserved6: [u8; 2732usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start RTC Counter."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start RTC Counter."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop RTC Counter."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop RTC Counter."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Clear RTC Counter."]
    pub struct TASKS_CLEAR {
        register: VolatileCell<u32>,
    }
    #[doc = "Clear RTC Counter."]
    pub mod tasks_clear {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_CLEAR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Set COUNTER to 0xFFFFFFF0."]
    pub struct TASKS_TRIGOVRFLW {
        register: VolatileCell<u32>,
    }
    #[doc = "Set COUNTER to 0xFFFFFFF0."]
    pub mod tasks_trigovrflw {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_TRIGOVRFLW {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Event on COUNTER increment."]
    pub struct EVENTS_TICK {
        register: VolatileCell<u32>,
    }
    #[doc = "Event on COUNTER increment."]
    pub mod events_tick {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_TICK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Event on COUNTER overflow."]
    pub struct EVENTS_OVRFLW {
        register: VolatileCell<u32>,
    }
    #[doc = "Event on COUNTER overflow."]
    pub mod events_ovrflw {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_OVRFLW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Compare event on CC[n] match."]
    pub struct EVENTS_COMPARE {
        register: VolatileCell<u32>,
    }
    #[doc = "Compare event on CC[n] match."]
    pub mod events_compare {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_COMPARE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TICK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TICKR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl TICKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TICKR::DISABLED => false,
                    TICKR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TICKR {
                match value {
                    false => TICKR::DISABLED,
                    true => TICKR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TICKR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TICKR::ENABLED
            }
        }
        #[doc = "Possible values of the field `OVRFLW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRFLWR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl OVRFLWR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVRFLWR::DISABLED => false,
                    OVRFLWR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVRFLWR {
                match value {
                    false => OVRFLWR::DISABLED,
                    true => OVRFLWR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OVRFLWR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OVRFLWR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0R::DISABLED => false,
                    COMPARE0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0R {
                match value {
                    false => COMPARE0R::DISABLED,
                    true => COMPARE0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1R::DISABLED => false,
                    COMPARE1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1R {
                match value {
                    false => COMPARE1R::DISABLED,
                    true => COMPARE1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2R::DISABLED => false,
                    COMPARE2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2R {
                match value {
                    false => COMPARE2R::DISABLED,
                    true => COMPARE2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3R::DISABLED => false,
                    COMPARE3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3R {
                match value {
                    false => COMPARE3R::DISABLED,
                    true => COMPARE3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TICK`"]
        pub enum TICKW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl TICKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TICKW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TICKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TICKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TICKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(TICKW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OVRFLW`"]
        pub enum OVRFLWW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl OVRFLWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVRFLWW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVRFLWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVRFLWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVRFLWW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(OVRFLWW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0`"]
        pub enum COMPARE0W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl COMPARE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1`"]
        pub enum COMPARE1W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl COMPARE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE1W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2`"]
        pub enum COMPARE2W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl COMPARE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE2W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3`"]
        pub enum COMPARE3W {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl COMPARE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE3W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on TICK event."]
            #[inline]
            pub fn tick(&self) -> TICKR {
                TICKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on OVRFLW event."]
            #[inline]
            pub fn ovrflw(&self) -> OVRFLWR {
                OVRFLWR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Enable interrupt on COMPARE[0] event."]
            #[inline]
            pub fn compare0(&self) -> COMPARE0R {
                COMPARE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Enable interrupt on COMPARE[1] event."]
            #[inline]
            pub fn compare1(&self) -> COMPARE1R {
                COMPARE1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Enable interrupt on COMPARE[2] event."]
            #[inline]
            pub fn compare2(&self) -> COMPARE2R {
                COMPARE2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Enable interrupt on COMPARE[3] event."]
            #[inline]
            pub fn compare3(&self) -> COMPARE3R {
                COMPARE3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on TICK event."]
            #[inline]
            pub fn tick(&mut self) -> _TICKW {
                _TICKW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on OVRFLW event."]
            #[inline]
            pub fn ovrflw(&mut self) -> _OVRFLWW {
                _OVRFLWW { w: self }
            }
            #[doc = "Bit 16 - Enable interrupt on COMPARE[0] event."]
            #[inline]
            pub fn compare0(&mut self) -> _COMPARE0W {
                _COMPARE0W { w: self }
            }
            #[doc = "Bit 17 - Enable interrupt on COMPARE[1] event."]
            #[inline]
            pub fn compare1(&mut self) -> _COMPARE1W {
                _COMPARE1W { w: self }
            }
            #[doc = "Bit 18 - Enable interrupt on COMPARE[2] event."]
            #[inline]
            pub fn compare2(&mut self) -> _COMPARE2W {
                _COMPARE2W { w: self }
            }
            #[doc = "Bit 19 - Enable interrupt on COMPARE[3] event."]
            #[inline]
            pub fn compare3(&mut self) -> _COMPARE3W {
                _COMPARE3W { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TICK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TICKR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl TICKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TICKR::DISABLED => false,
                    TICKR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TICKR {
                match value {
                    false => TICKR::DISABLED,
                    true => TICKR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TICKR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TICKR::ENABLED
            }
        }
        #[doc = "Possible values of the field `OVRFLW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRFLWR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl OVRFLWR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVRFLWR::DISABLED => false,
                    OVRFLWR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVRFLWR {
                match value {
                    false => OVRFLWR::DISABLED,
                    true => OVRFLWR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OVRFLWR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OVRFLWR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0R::DISABLED => false,
                    COMPARE0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0R {
                match value {
                    false => COMPARE0R::DISABLED,
                    true => COMPARE0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1R::DISABLED => false,
                    COMPARE1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1R {
                match value {
                    false => COMPARE1R::DISABLED,
                    true => COMPARE1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2R::DISABLED => false,
                    COMPARE2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2R {
                match value {
                    false => COMPARE2R::DISABLED,
                    true => COMPARE2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3R {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl COMPARE3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3R::DISABLED => false,
                    COMPARE3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3R {
                match value {
                    false => COMPARE3R::DISABLED,
                    true => COMPARE3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TICK`"]
        pub enum TICKW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl TICKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TICKW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TICKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TICKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TICKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(TICKW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OVRFLW`"]
        pub enum OVRFLWW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl OVRFLWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVRFLWW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVRFLWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVRFLWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVRFLWW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVRFLWW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0`"]
        pub enum COMPARE0W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl COMPARE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE0W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1`"]
        pub enum COMPARE1W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl COMPARE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2`"]
        pub enum COMPARE2W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl COMPARE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE2W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3`"]
        pub enum COMPARE3W {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl COMPARE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE3W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on TICK event."]
            #[inline]
            pub fn tick(&self) -> TICKR {
                TICKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on OVRFLW event."]
            #[inline]
            pub fn ovrflw(&self) -> OVRFLWR {
                OVRFLWR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Disable interrupt on COMPARE[0] event."]
            #[inline]
            pub fn compare0(&self) -> COMPARE0R {
                COMPARE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Disable interrupt on COMPARE[1] event."]
            #[inline]
            pub fn compare1(&self) -> COMPARE1R {
                COMPARE1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Disable interrupt on COMPARE[2] event."]
            #[inline]
            pub fn compare2(&self) -> COMPARE2R {
                COMPARE2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Disable interrupt on COMPARE[3] event."]
            #[inline]
            pub fn compare3(&self) -> COMPARE3R {
                COMPARE3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on TICK event."]
            #[inline]
            pub fn tick(&mut self) -> _TICKW {
                _TICKW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on OVRFLW event."]
            #[inline]
            pub fn ovrflw(&mut self) -> _OVRFLWW {
                _OVRFLWW { w: self }
            }
            #[doc = "Bit 16 - Disable interrupt on COMPARE[0] event."]
            #[inline]
            pub fn compare0(&mut self) -> _COMPARE0W {
                _COMPARE0W { w: self }
            }
            #[doc = "Bit 17 - Disable interrupt on COMPARE[1] event."]
            #[inline]
            pub fn compare1(&mut self) -> _COMPARE1W {
                _COMPARE1W { w: self }
            }
            #[doc = "Bit 18 - Disable interrupt on COMPARE[2] event."]
            #[inline]
            pub fn compare2(&mut self) -> _COMPARE2W {
                _COMPARE2W { w: self }
            }
            #[doc = "Bit 19 - Disable interrupt on COMPARE[3] event."]
            #[inline]
            pub fn compare3(&mut self) -> _COMPARE3W {
                _COMPARE3W { w: self }
            }
        }
    }
    #[doc = "Configures event enable routing to PPI for each RTC event."]
    pub struct EVTEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Configures event enable routing to PPI for each RTC event."]
    pub mod evten {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVTEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TICK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TICKR {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl TICKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TICKR::DISABLED => false,
                    TICKR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TICKR {
                match value {
                    false => TICKR::DISABLED,
                    true => TICKR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TICKR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TICKR::ENABLED
            }
        }
        #[doc = "Possible values of the field `OVRFLW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRFLWR {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl OVRFLWR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVRFLWR::DISABLED => false,
                    OVRFLWR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVRFLWR {
                match value {
                    false => OVRFLWR::DISABLED,
                    true => OVRFLWR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OVRFLWR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OVRFLWR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0R::DISABLED => false,
                    COMPARE0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0R {
                match value {
                    false => COMPARE0R::DISABLED,
                    true => COMPARE0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1R::DISABLED => false,
                    COMPARE1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1R {
                match value {
                    false => COMPARE1R::DISABLED,
                    true => COMPARE1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2R::DISABLED => false,
                    COMPARE2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2R {
                match value {
                    false => COMPARE2R::DISABLED,
                    true => COMPARE2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3R::DISABLED => false,
                    COMPARE3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3R {
                match value {
                    false => COMPARE3R::DISABLED,
                    true => COMPARE3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TICK`"]
        pub enum TICKW {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl TICKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TICKW::DISABLED => false,
                    TICKW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TICKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TICKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TICKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Event disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TICKW::DISABLED)
            }
            #[doc = "Event enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TICKW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OVRFLW`"]
        pub enum OVRFLWW {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl OVRFLWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVRFLWW::DISABLED => false,
                    OVRFLWW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVRFLWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVRFLWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVRFLWW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Event disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OVRFLWW::DISABLED)
            }
            #[doc = "Event enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OVRFLWW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0`"]
        pub enum COMPARE0W {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0W::DISABLED => false,
                    COMPARE0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Event disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE0W::DISABLED)
            }
            #[doc = "Event enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1`"]
        pub enum COMPARE1W {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1W::DISABLED => false,
                    COMPARE1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Event disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE1W::DISABLED)
            }
            #[doc = "Event enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2`"]
        pub enum COMPARE2W {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2W::DISABLED => false,
                    COMPARE2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Event disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE2W::DISABLED)
            }
            #[doc = "Event enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3`"]
        pub enum COMPARE3W {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3W::DISABLED => false,
                    COMPARE3W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Event disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMPARE3W::DISABLED)
            }
            #[doc = "Event enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMPARE3W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - TICK event enable."]
            #[inline]
            pub fn tick(&self) -> TICKR {
                TICKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - OVRFLW event enable."]
            #[inline]
            pub fn ovrflw(&self) -> OVRFLWR {
                OVRFLWR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - COMPARE[0] event enable."]
            #[inline]
            pub fn compare0(&self) -> COMPARE0R {
                COMPARE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - COMPARE[1] event enable."]
            #[inline]
            pub fn compare1(&self) -> COMPARE1R {
                COMPARE1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - COMPARE[2] event enable."]
            #[inline]
            pub fn compare2(&self) -> COMPARE2R {
                COMPARE2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - COMPARE[3] event enable."]
            #[inline]
            pub fn compare3(&self) -> COMPARE3R {
                COMPARE3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - TICK event enable."]
            #[inline]
            pub fn tick(&mut self) -> _TICKW {
                _TICKW { w: self }
            }
            #[doc = "Bit 1 - OVRFLW event enable."]
            #[inline]
            pub fn ovrflw(&mut self) -> _OVRFLWW {
                _OVRFLWW { w: self }
            }
            #[doc = "Bit 16 - COMPARE[0] event enable."]
            #[inline]
            pub fn compare0(&mut self) -> _COMPARE0W {
                _COMPARE0W { w: self }
            }
            #[doc = "Bit 17 - COMPARE[1] event enable."]
            #[inline]
            pub fn compare1(&mut self) -> _COMPARE1W {
                _COMPARE1W { w: self }
            }
            #[doc = "Bit 18 - COMPARE[2] event enable."]
            #[inline]
            pub fn compare2(&mut self) -> _COMPARE2W {
                _COMPARE2W { w: self }
            }
            #[doc = "Bit 19 - COMPARE[3] event enable."]
            #[inline]
            pub fn compare3(&mut self) -> _COMPARE3W {
                _COMPARE3W { w: self }
            }
        }
    }
    #[doc = "Enable events routing to PPI. The reading of this register gives the value of EVTEN."]
    pub struct EVTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable events routing to PPI. The reading of this register gives the value of EVTEN."]
    pub mod evtenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TICK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TICKR {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl TICKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TICKR::DISABLED => false,
                    TICKR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TICKR {
                match value {
                    false => TICKR::DISABLED,
                    true => TICKR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TICKR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TICKR::ENABLED
            }
        }
        #[doc = "Possible values of the field `OVRFLW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRFLWR {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl OVRFLWR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVRFLWR::DISABLED => false,
                    OVRFLWR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVRFLWR {
                match value {
                    false => OVRFLWR::DISABLED,
                    true => OVRFLWR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OVRFLWR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OVRFLWR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0R::DISABLED => false,
                    COMPARE0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0R {
                match value {
                    false => COMPARE0R::DISABLED,
                    true => COMPARE0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1R::DISABLED => false,
                    COMPARE1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1R {
                match value {
                    false => COMPARE1R::DISABLED,
                    true => COMPARE1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2R::DISABLED => false,
                    COMPARE2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2R {
                match value {
                    false => COMPARE2R::DISABLED,
                    true => COMPARE2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3R::DISABLED => false,
                    COMPARE3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3R {
                match value {
                    false => COMPARE3R::DISABLED,
                    true => COMPARE3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TICK`"]
        pub enum TICKW {
            #[doc = "Enable event on write."]
            SET,
        }
        impl TICKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TICKW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TICKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TICKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TICKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable event on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(TICKW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OVRFLW`"]
        pub enum OVRFLWW {
            #[doc = "Enable event on write."]
            SET,
        }
        impl OVRFLWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVRFLWW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVRFLWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVRFLWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVRFLWW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable event on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(OVRFLWW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0`"]
        pub enum COMPARE0W {
            #[doc = "Enable event on write."]
            SET,
        }
        impl COMPARE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable event on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1`"]
        pub enum COMPARE1W {
            #[doc = "Enable event on write."]
            SET,
        }
        impl COMPARE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable event on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE1W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2`"]
        pub enum COMPARE2W {
            #[doc = "Enable event on write."]
            SET,
        }
        impl COMPARE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable event on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE2W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3`"]
        pub enum COMPARE3W {
            #[doc = "Enable event on write."]
            SET,
        }
        impl COMPARE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable event on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(COMPARE3W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable routing to PPI of TICK event."]
            #[inline]
            pub fn tick(&self) -> TICKR {
                TICKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable routing to PPI of OVRFLW event."]
            #[inline]
            pub fn ovrflw(&self) -> OVRFLWR {
                OVRFLWR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Enable routing to PPI of COMPARE[0] event."]
            #[inline]
            pub fn compare0(&self) -> COMPARE0R {
                COMPARE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Enable routing to PPI of COMPARE[1] event."]
            #[inline]
            pub fn compare1(&self) -> COMPARE1R {
                COMPARE1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Enable routing to PPI of COMPARE[2] event."]
            #[inline]
            pub fn compare2(&self) -> COMPARE2R {
                COMPARE2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Enable routing to PPI of COMPARE[3] event."]
            #[inline]
            pub fn compare3(&self) -> COMPARE3R {
                COMPARE3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable routing to PPI of TICK event."]
            #[inline]
            pub fn tick(&mut self) -> _TICKW {
                _TICKW { w: self }
            }
            #[doc = "Bit 1 - Enable routing to PPI of OVRFLW event."]
            #[inline]
            pub fn ovrflw(&mut self) -> _OVRFLWW {
                _OVRFLWW { w: self }
            }
            #[doc = "Bit 16 - Enable routing to PPI of COMPARE[0] event."]
            #[inline]
            pub fn compare0(&mut self) -> _COMPARE0W {
                _COMPARE0W { w: self }
            }
            #[doc = "Bit 17 - Enable routing to PPI of COMPARE[1] event."]
            #[inline]
            pub fn compare1(&mut self) -> _COMPARE1W {
                _COMPARE1W { w: self }
            }
            #[doc = "Bit 18 - Enable routing to PPI of COMPARE[2] event."]
            #[inline]
            pub fn compare2(&mut self) -> _COMPARE2W {
                _COMPARE2W { w: self }
            }
            #[doc = "Bit 19 - Enable routing to PPI of COMPARE[3] event."]
            #[inline]
            pub fn compare3(&mut self) -> _COMPARE3W {
                _COMPARE3W { w: self }
            }
        }
    }
    #[doc = "Disable events routing to PPI. The reading of this register gives the value of EVTEN."]
    pub struct EVTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Disable events routing to PPI. The reading of this register gives the value of EVTEN."]
    pub mod evtenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TICK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TICKR {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl TICKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TICKR::DISABLED => false,
                    TICKR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TICKR {
                match value {
                    false => TICKR::DISABLED,
                    true => TICKR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TICKR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TICKR::ENABLED
            }
        }
        #[doc = "Possible values of the field `OVRFLW`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVRFLWR {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl OVRFLWR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OVRFLWR::DISABLED => false,
                    OVRFLWR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OVRFLWR {
                match value {
                    false => OVRFLWR::DISABLED,
                    true => OVRFLWR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == OVRFLWR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == OVRFLWR::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE0R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE0R::DISABLED => false,
                    COMPARE0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE0R {
                match value {
                    false => COMPARE0R::DISABLED,
                    true => COMPARE0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE1R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE1R::DISABLED => false,
                    COMPARE1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE1R {
                match value {
                    false => COMPARE1R::DISABLED,
                    true => COMPARE1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE2R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE2R::DISABLED => false,
                    COMPARE2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE2R {
                match value {
                    false => COMPARE2R::DISABLED,
                    true => COMPARE2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `COMPARE3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMPARE3R {
            #[doc = "Event disabled."]
            DISABLED,
            #[doc = "Event enabled."]
            ENABLED,
        }
        impl COMPARE3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    COMPARE3R::DISABLED => false,
                    COMPARE3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> COMPARE3R {
                match value {
                    false => COMPARE3R::DISABLED,
                    true => COMPARE3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == COMPARE3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == COMPARE3R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TICK`"]
        pub enum TICKW {
            #[doc = "Disable event on write."]
            CLEAR,
        }
        impl TICKW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TICKW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TICKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TICKW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TICKW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable event on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(TICKW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OVRFLW`"]
        pub enum OVRFLWW {
            #[doc = "Disable event on write."]
            CLEAR,
        }
        impl OVRFLWW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OVRFLWW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVRFLWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVRFLWW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OVRFLWW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable event on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(OVRFLWW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE0`"]
        pub enum COMPARE0W {
            #[doc = "Disable event on write."]
            CLEAR,
        }
        impl COMPARE0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE0W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable event on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE0W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE1`"]
        pub enum COMPARE1W {
            #[doc = "Disable event on write."]
            CLEAR,
        }
        impl COMPARE1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable event on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE2`"]
        pub enum COMPARE2W {
            #[doc = "Disable event on write."]
            CLEAR,
        }
        impl COMPARE2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE2W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable event on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE2W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `COMPARE3`"]
        pub enum COMPARE3W {
            #[doc = "Disable event on write."]
            CLEAR,
        }
        impl COMPARE3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    COMPARE3W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPARE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPARE3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: COMPARE3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable event on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(COMPARE3W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable routing to PPI of TICK event."]
            #[inline]
            pub fn tick(&self) -> TICKR {
                TICKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable routing to PPI of OVRFLW event."]
            #[inline]
            pub fn ovrflw(&self) -> OVRFLWR {
                OVRFLWR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Disable routing to PPI of COMPARE[0] event."]
            #[inline]
            pub fn compare0(&self) -> COMPARE0R {
                COMPARE0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Disable routing to PPI of COMPARE[1] event."]
            #[inline]
            pub fn compare1(&self) -> COMPARE1R {
                COMPARE1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Disable routing to PPI of COMPARE[2] event."]
            #[inline]
            pub fn compare2(&self) -> COMPARE2R {
                COMPARE2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Disable routing to PPI of COMPARE[3] event."]
            #[inline]
            pub fn compare3(&self) -> COMPARE3R {
                COMPARE3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable routing to PPI of TICK event."]
            #[inline]
            pub fn tick(&mut self) -> _TICKW {
                _TICKW { w: self }
            }
            #[doc = "Bit 1 - Disable routing to PPI of OVRFLW event."]
            #[inline]
            pub fn ovrflw(&mut self) -> _OVRFLWW {
                _OVRFLWW { w: self }
            }
            #[doc = "Bit 16 - Disable routing to PPI of COMPARE[0] event."]
            #[inline]
            pub fn compare0(&mut self) -> _COMPARE0W {
                _COMPARE0W { w: self }
            }
            #[doc = "Bit 17 - Disable routing to PPI of COMPARE[1] event."]
            #[inline]
            pub fn compare1(&mut self) -> _COMPARE1W {
                _COMPARE1W { w: self }
            }
            #[doc = "Bit 18 - Disable routing to PPI of COMPARE[2] event."]
            #[inline]
            pub fn compare2(&mut self) -> _COMPARE2W {
                _COMPARE2W { w: self }
            }
            #[doc = "Bit 19 - Disable routing to PPI of COMPARE[3] event."]
            #[inline]
            pub fn compare3(&mut self) -> _COMPARE3W {
                _COMPARE3W { w: self }
            }
        }
    }
    #[doc = "Current COUNTER value."]
    pub struct COUNTER {
        register: VolatileCell<u32>,
    }
    #[doc = "Current COUNTER value."]
    pub mod counter {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::COUNTER {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTERR {
            bits: u32,
        }
        impl COUNTERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Counter value."]
            #[inline]
            pub fn counter(&self) -> COUNTERR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTERR { bits }
            }
        }
    }
    #[doc = "12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed."]
    pub struct PRESCALER {
        register: VolatileCell<u32>,
    }
    #[doc = "12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed."]
    pub mod prescaler {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRESCALER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRESCALERR {
            bits: u16,
        }
        impl PRESCALERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRESCALERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRESCALERW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x0fff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:11 - RTC PRESCALER value."]
            #[inline]
            pub fn prescaler(&self) -> PRESCALERR {
                let bits = {
                    const MASK: u16 = 0x0fff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PRESCALERR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:11 - RTC PRESCALER value."]
            #[inline]
            pub fn prescaler(&mut self) -> _PRESCALERW {
                _PRESCALERW { w: self }
            }
        }
    }
    #[doc = "Capture/compare registers."]
    pub struct CC {
        register: VolatileCell<u32>,
    }
    #[doc = "Capture/compare registers."]
    pub mod cc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COMPARER {
            bits: u32,
        }
        impl COMPARER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COMPAREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COMPAREW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Compare value."]
            #[inline]
            pub fn compare(&self) -> COMPARER {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COMPARER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Compare value."]
            #[inline]
            pub fn compare(&mut self) -> _COMPAREW {
                _COMPAREW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Temperature Sensor."]
pub struct TEMP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TEMP {}
impl TEMP {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const temp::RegisterBlock {
        0x4000_c000 as *const _
    }
}
impl Deref for TEMP {
    type Target = temp::RegisterBlock;
    fn deref(&self) -> &temp::RegisterBlock {
        unsafe { &*TEMP::ptr() }
    }
}
#[doc = "Temperature Sensor."]
pub mod temp {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start temperature measurement."]
        pub tasks_start: TASKS_START,
        #[doc = "0x04 - Stop temperature measurement."]
        pub tasks_stop: TASKS_STOP,
        _reserved0: [u8; 248usize],
        #[doc = "0x100 - Temperature measurement complete, data ready event."]
        pub events_datardy: EVENTS_DATARDY,
        _reserved1: [u8; 512usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved2: [u8; 508usize],
        #[doc = "0x508 - Die temperature in degC, 2's complement format, 0.25 degC pecision."]
        pub temp: TEMP,
        _reserved3: [u8; 2800usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start temperature measurement."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start temperature measurement."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop temperature measurement."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop temperature measurement."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Temperature measurement complete, data ready event."]
    pub struct EVENTS_DATARDY {
        register: VolatileCell<u32>,
    }
    #[doc = "Temperature measurement complete, data ready event."]
    pub mod events_datardy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_DATARDY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DATARDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATARDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DATARDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DATARDYR::DISABLED => false,
                    DATARDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DATARDYR {
                match value {
                    false => DATARDYR::DISABLED,
                    true => DATARDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DATARDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DATARDYR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `DATARDY`"]
        pub enum DATARDYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl DATARDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DATARDYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATARDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATARDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DATARDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(DATARDYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on DATARDY event."]
            #[inline]
            pub fn datardy(&self) -> DATARDYR {
                DATARDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on DATARDY event."]
            #[inline]
            pub fn datardy(&mut self) -> _DATARDYW {
                _DATARDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DATARDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DATARDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DATARDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DATARDYR::DISABLED => false,
                    DATARDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DATARDYR {
                match value {
                    false => DATARDYR::DISABLED,
                    true => DATARDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DATARDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DATARDYR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `DATARDY`"]
        pub enum DATARDYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl DATARDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DATARDYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATARDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATARDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DATARDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(DATARDYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on DATARDY event."]
            #[inline]
            pub fn datardy(&self) -> DATARDYR {
                DATARDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on DATARDY event."]
            #[inline]
            pub fn datardy(&mut self) -> _DATARDYW {
                _DATARDYW { w: self }
            }
        }
    }
    #[doc = "Die temperature in degC, 2's complement format, 0.25 degC pecision."]
    pub struct TEMP {
        register: VolatileCell<u32>,
    }
    #[doc = "Die temperature in degC, 2's complement format, 0.25 degC pecision."]
    pub mod temp {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::TEMP {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Random Number Generator."]
pub struct RNG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RNG {}
impl RNG {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const rng::RegisterBlock {
        0x4000_d000 as *const _
    }
}
impl Deref for RNG {
    type Target = rng::RegisterBlock;
    fn deref(&self) -> &rng::RegisterBlock {
        unsafe { &*RNG::ptr() }
    }
}
#[doc = "Random Number Generator."]
pub mod rng {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start the random number generator."]
        pub tasks_start: TASKS_START,
        #[doc = "0x04 - Stop the random number generator."]
        pub tasks_stop: TASKS_STOP,
        _reserved0: [u8; 248usize],
        #[doc = "0x100 - New random number generated and written to VALUE register."]
        pub events_valrdy: EVENTS_VALRDY,
        _reserved1: [u8; 252usize],
        #[doc = "0x200 - Shortcuts for the RNG."]
        pub shorts: SHORTS,
        _reserved2: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register"]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register"]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 504usize],
        #[doc = "0x504 - Configuration register."]
        pub config: CONFIG,
        #[doc = "0x508 - RNG random number."]
        pub value: VALUE,
        _reserved4: [u8; 2800usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start the random number generator."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start the random number generator."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop the random number generator."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop the random number generator."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "New random number generated and written to VALUE register."]
    pub struct EVENTS_VALRDY {
        register: VolatileCell<u32>,
    }
    #[doc = "New random number generated and written to VALUE register."]
    pub mod events_valrdy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_VALRDY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for the RNG."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for the RNG."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `VALRDY_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VALRDY_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl VALRDY_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    VALRDY_STOPR::DISABLED => false,
                    VALRDY_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> VALRDY_STOPR {
                match value {
                    false => VALRDY_STOPR::DISABLED,
                    true => VALRDY_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == VALRDY_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == VALRDY_STOPR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `VALRDY_STOP`"]
        pub enum VALRDY_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl VALRDY_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    VALRDY_STOPW::DISABLED => false,
                    VALRDY_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALRDY_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALRDY_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: VALRDY_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(VALRDY_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(VALRDY_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Shortcut between VALRDY event and STOP task."]
            #[inline]
            pub fn valrdy_stop(&self) -> VALRDY_STOPR {
                VALRDY_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Shortcut between VALRDY event and STOP task."]
            #[inline]
            pub fn valrdy_stop(&mut self) -> _VALRDY_STOPW {
                _VALRDY_STOPW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register"]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register"]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `VALRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VALRDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl VALRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    VALRDYR::DISABLED => false,
                    VALRDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> VALRDYR {
                match value {
                    false => VALRDYR::DISABLED,
                    true => VALRDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == VALRDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == VALRDYR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `VALRDY`"]
        pub enum VALRDYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl VALRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    VALRDYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: VALRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(VALRDYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on VALRDY event."]
            #[inline]
            pub fn valrdy(&self) -> VALRDYR {
                VALRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on VALRDY event."]
            #[inline]
            pub fn valrdy(&mut self) -> _VALRDYW {
                _VALRDYW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register"]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register"]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `VALRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum VALRDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl VALRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    VALRDYR::DISABLED => false,
                    VALRDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> VALRDYR {
                match value {
                    false => VALRDYR::DISABLED,
                    true => VALRDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == VALRDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == VALRDYR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `VALRDY`"]
        pub enum VALRDYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl VALRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    VALRDYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _VALRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _VALRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: VALRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(VALRDYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on VALRDY event."]
            #[inline]
            pub fn valrdy(&self) -> VALRDYR {
                VALRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on VALRDY event."]
            #[inline]
            pub fn valrdy(&mut self) -> _VALRDYW {
                _VALRDYW { w: self }
            }
        }
    }
    #[doc = "Configuration register."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration register."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DERCEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DERCENR {
            #[doc = "Digital error correction disabled."]
            DISABLED,
            #[doc = "Digital error correction enabled."]
            ENABLED,
        }
        impl DERCENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DERCENR::DISABLED => false,
                    DERCENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DERCENR {
                match value {
                    false => DERCENR::DISABLED,
                    true => DERCENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DERCENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DERCENR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `DERCEN`"]
        pub enum DERCENW {
            #[doc = "Digital error correction disabled."]
            DISABLED,
            #[doc = "Digital error correction enabled."]
            ENABLED,
        }
        impl DERCENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DERCENW::DISABLED => false,
                    DERCENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DERCENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DERCENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DERCENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Digital error correction disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DERCENW::DISABLED)
            }
            #[doc = "Digital error correction enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DERCENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Digital error correction enable."]
            #[inline]
            pub fn dercen(&self) -> DERCENR {
                DERCENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Digital error correction enable."]
            #[inline]
            pub fn dercen(&mut self) -> _DERCENW {
                _DERCENW { w: self }
            }
        }
    }
    #[doc = "RNG random number."]
    pub struct VALUE {
        register: VolatileCell<u32>,
    }
    #[doc = "RNG random number."]
    pub mod value {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::VALUE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct VALUER {
            bits: u8,
        }
        impl VALUER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Generated random number."]
            #[inline]
            pub fn value(&self) -> VALUER {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                VALUER { bits }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "AES ECB Mode Encryption."]
pub struct ECB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ECB {}
impl ECB {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ecb::RegisterBlock {
        0x4000_e000 as *const _
    }
}
impl Deref for ECB {
    type Target = ecb::RegisterBlock;
    fn deref(&self) -> &ecb::RegisterBlock {
        unsafe { &*ECB::ptr() }
    }
}
#[doc = "AES ECB Mode Encryption."]
pub mod ecb {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered."]
        pub tasks_startecb: TASKS_STARTECB,
        #[doc = "0x04 - Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event."]
        pub tasks_stopecb: TASKS_STOPECB,
        _reserved0: [u8; 248usize],
        #[doc = "0x100 - ECB block encrypt complete."]
        pub events_endecb: EVENTS_ENDECB,
        #[doc = "0x104 - ECB block encrypt aborted due to a STOPECB task or due to an error."]
        pub events_errorecb: EVENTS_ERRORECB,
        _reserved1: [u8; 508usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved2: [u8; 504usize],
        #[doc = "0x504 - ECB block encrypt memory pointer."]
        pub ecbdataptr: ECBDATAPTR,
        _reserved3: [u8; 2804usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered."]
    pub struct TASKS_STARTECB {
        register: VolatileCell<u32>,
    }
    #[doc = "Start ECB block encrypt. If a crypto operation is running, this will not initiate a new encryption and the ERRORECB event will be triggered."]
    pub mod tasks_startecb {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STARTECB {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event."]
    pub struct TASKS_STOPECB {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop current ECB encryption. If a crypto operation is running, this will will trigger the ERRORECB event."]
    pub mod tasks_stopecb {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOPECB {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ECB block encrypt complete."]
    pub struct EVENTS_ENDECB {
        register: VolatileCell<u32>,
    }
    #[doc = "ECB block encrypt complete."]
    pub mod events_endecb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ENDECB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ECB block encrypt aborted due to a STOPECB task or due to an error."]
    pub struct EVENTS_ERRORECB {
        register: VolatileCell<u32>,
    }
    #[doc = "ECB block encrypt aborted due to a STOPECB task or due to an error."]
    pub mod events_errorecb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ERRORECB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENDECB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDECBR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDECBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDECBR::DISABLED => false,
                    ENDECBR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDECBR {
                match value {
                    false => ENDECBR::DISABLED,
                    true => ENDECBR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDECBR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDECBR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ERRORECB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRORECBR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ERRORECBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERRORECBR::DISABLED => false,
                    ERRORECBR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERRORECBR {
                match value {
                    false => ERRORECBR::DISABLED,
                    true => ERRORECBR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ERRORECBR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ERRORECBR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENDECB`"]
        pub enum ENDECBW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDECBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDECBW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDECBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDECBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDECBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDECBW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ERRORECB`"]
        pub enum ERRORECBW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ERRORECBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERRORECBW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORECBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORECBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERRORECBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ERRORECBW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on ENDECB event."]
            #[inline]
            pub fn endecb(&self) -> ENDECBR {
                ENDECBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on ERRORECB event."]
            #[inline]
            pub fn errorecb(&self) -> ERRORECBR {
                ERRORECBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on ENDECB event."]
            #[inline]
            pub fn endecb(&mut self) -> _ENDECBW {
                _ENDECBW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on ERRORECB event."]
            #[inline]
            pub fn errorecb(&mut self) -> _ERRORECBW {
                _ERRORECBW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENDECB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDECBR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDECBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDECBR::DISABLED => false,
                    ENDECBR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDECBR {
                match value {
                    false => ENDECBR::DISABLED,
                    true => ENDECBR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDECBR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDECBR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ERRORECB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRORECBR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ERRORECBR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERRORECBR::DISABLED => false,
                    ERRORECBR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERRORECBR {
                match value {
                    false => ERRORECBR::DISABLED,
                    true => ERRORECBR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ERRORECBR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ERRORECBR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENDECB`"]
        pub enum ENDECBW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDECBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDECBW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDECBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDECBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDECBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDECBW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ERRORECB`"]
        pub enum ERRORECBW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ERRORECBW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERRORECBW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORECBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORECBW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERRORECBW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ERRORECBW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on ENDECB event."]
            #[inline]
            pub fn endecb(&self) -> ENDECBR {
                ENDECBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on ERRORECB event."]
            #[inline]
            pub fn errorecb(&self) -> ERRORECBR {
                ERRORECBR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on ENDECB event."]
            #[inline]
            pub fn endecb(&mut self) -> _ENDECBW {
                _ENDECBW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on ERRORECB event."]
            #[inline]
            pub fn errorecb(&mut self) -> _ERRORECBW {
                _ERRORECBW { w: self }
            }
        }
    }
    #[doc = "ECB block encrypt memory pointer."]
    pub struct ECBDATAPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "ECB block encrypt memory pointer."]
    pub mod ecbdataptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ECBDATAPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Accelerated Address Resolver."]
pub struct AAR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AAR {}
impl AAR {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const aar::RegisterBlock {
        0x4000_f000 as *const _
    }
}
impl Deref for AAR {
    type Target = aar::RegisterBlock;
    fn deref(&self) -> &aar::RegisterBlock {
        unsafe { &*AAR::ptr() }
    }
}
#[doc = "Accelerated Address Resolver."]
pub mod aar {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start resolving addresses based on IRKs specified in the IRK data structure."]
        pub tasks_start: TASKS_START,
        _reserved0: [u8; 4usize],
        #[doc = "0x08 - Stop resolving addresses."]
        pub tasks_stop: TASKS_STOP,
        _reserved1: [u8; 244usize],
        #[doc = "0x100 - Address resolution procedure completed."]
        pub events_end: EVENTS_END,
        #[doc = "0x104 - Address resolved."]
        pub events_resolved: EVENTS_RESOLVED,
        #[doc = "0x108 - Address not resolved."]
        pub events_notresolved: EVENTS_NOTRESOLVED,
        _reserved2: [u8; 504usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 244usize],
        #[doc = "0x400 - Resolution status."]
        pub status: STATUS,
        _reserved4: [u8; 252usize],
        #[doc = "0x500 - Enable AAR."]
        pub enable: ENABLE,
        #[doc = "0x504 - Number of Identity root Keys in the IRK data structure."]
        pub nirk: NIRK,
        #[doc = "0x508 - Pointer to the IRK data structure."]
        pub irkptr: IRKPTR,
        _reserved5: [u8; 4usize],
        #[doc = "0x510 - Pointer to the resolvable address (6 bytes)."]
        pub addrptr: ADDRPTR,
        #[doc = "0x514 - Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved."]
        pub scratchptr: SCRATCHPTR,
        _reserved6: [u8; 2788usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start resolving addresses based on IRKs specified in the IRK data structure."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start resolving addresses based on IRKs specified in the IRK data structure."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop resolving addresses."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop resolving addresses."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Address resolution procedure completed."]
    pub struct EVENTS_END {
        register: VolatileCell<u32>,
    }
    #[doc = "Address resolution procedure completed."]
    pub mod events_end {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_END {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Address resolved."]
    pub struct EVENTS_RESOLVED {
        register: VolatileCell<u32>,
    }
    #[doc = "Address resolved."]
    pub mod events_resolved {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_RESOLVED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Address not resolved."]
    pub struct EVENTS_NOTRESOLVED {
        register: VolatileCell<u32>,
    }
    #[doc = "Address not resolved."]
    pub mod events_notresolved {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_NOTRESOLVED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `END`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDR::DISABLED => false,
                    ENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDR {
                match value {
                    false => ENDR::DISABLED,
                    true => ENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RESOLVED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESOLVEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RESOLVEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RESOLVEDR::DISABLED => false,
                    RESOLVEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RESOLVEDR {
                match value {
                    false => RESOLVEDR::DISABLED,
                    true => RESOLVEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RESOLVEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RESOLVEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `NOTRESOLVED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NOTRESOLVEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl NOTRESOLVEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    NOTRESOLVEDR::DISABLED => false,
                    NOTRESOLVEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> NOTRESOLVEDR {
                match value {
                    false => NOTRESOLVEDR::DISABLED,
                    true => NOTRESOLVEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == NOTRESOLVEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == NOTRESOLVEDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `END`"]
        pub enum ENDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RESOLVED`"]
        pub enum RESOLVEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl RESOLVEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RESOLVEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESOLVEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESOLVEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RESOLVEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(RESOLVEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `NOTRESOLVED`"]
        pub enum NOTRESOLVEDW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl NOTRESOLVEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    NOTRESOLVEDW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NOTRESOLVEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NOTRESOLVEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NOTRESOLVEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(NOTRESOLVEDW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on END event."]
            #[inline]
            pub fn end(&self) -> ENDR {
                ENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on RESOLVED event."]
            #[inline]
            pub fn resolved(&self) -> RESOLVEDR {
                RESOLVEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable interrupt on NOTRESOLVED event."]
            #[inline]
            pub fn notresolved(&self) -> NOTRESOLVEDR {
                NOTRESOLVEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on END event."]
            #[inline]
            pub fn end(&mut self) -> _ENDW {
                _ENDW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on RESOLVED event."]
            #[inline]
            pub fn resolved(&mut self) -> _RESOLVEDW {
                _RESOLVEDW { w: self }
            }
            #[doc = "Bit 2 - Enable interrupt on NOTRESOLVED event."]
            #[inline]
            pub fn notresolved(&mut self) -> _NOTRESOLVEDW {
                _NOTRESOLVEDW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `END`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDR::DISABLED => false,
                    ENDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDR {
                match value {
                    false => ENDR::DISABLED,
                    true => ENDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RESOLVED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESOLVEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl RESOLVEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RESOLVEDR::DISABLED => false,
                    RESOLVEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RESOLVEDR {
                match value {
                    false => RESOLVEDR::DISABLED,
                    true => RESOLVEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RESOLVEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RESOLVEDR::ENABLED
            }
        }
        #[doc = "Possible values of the field `NOTRESOLVED`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NOTRESOLVEDR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl NOTRESOLVEDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    NOTRESOLVEDR::DISABLED => false,
                    NOTRESOLVEDR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> NOTRESOLVEDR {
                match value {
                    false => NOTRESOLVEDR::DISABLED,
                    true => NOTRESOLVEDR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == NOTRESOLVEDR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == NOTRESOLVEDR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `END`"]
        pub enum ENDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RESOLVED`"]
        pub enum RESOLVEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl RESOLVEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RESOLVEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RESOLVEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RESOLVEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RESOLVEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(RESOLVEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `NOTRESOLVED`"]
        pub enum NOTRESOLVEDW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl NOTRESOLVEDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    NOTRESOLVEDW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NOTRESOLVEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NOTRESOLVEDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NOTRESOLVEDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(NOTRESOLVEDW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on ENDKSGEN event."]
            #[inline]
            pub fn end(&self) -> ENDR {
                ENDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on RESOLVED event."]
            #[inline]
            pub fn resolved(&self) -> RESOLVEDR {
                RESOLVEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable interrupt on NOTRESOLVED event."]
            #[inline]
            pub fn notresolved(&self) -> NOTRESOLVEDR {
                NOTRESOLVEDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on ENDKSGEN event."]
            #[inline]
            pub fn end(&mut self) -> _ENDW {
                _ENDW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on RESOLVED event."]
            #[inline]
            pub fn resolved(&mut self) -> _RESOLVEDW {
                _RESOLVEDW { w: self }
            }
            #[doc = "Bit 2 - Disable interrupt on NOTRESOLVED event."]
            #[inline]
            pub fn notresolved(&mut self) -> _NOTRESOLVEDW {
                _NOTRESOLVEDW { w: self }
            }
        }
    }
    #[doc = "Resolution status."]
    pub struct STATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Resolution status."]
    pub mod status {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::STATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATUSR {
            bits: u8,
        }
        impl STATUSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - The IRK used last time an address was resolved."]
            #[inline]
            pub fn status(&self) -> STATUSR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATUSR { bits }
            }
        }
    }
    #[doc = "Enable AAR."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable AAR."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled AAR."]
            DISABLED,
            #[doc = "Enable AAR."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x03,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    3 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled AAR."]
            DISABLED,
            #[doc = "Enable AAR."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled AAR."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enable AAR."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Enable AAR."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Enable AAR."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Number of Identity root Keys in the IRK data structure."]
    pub struct NIRK {
        register: VolatileCell<u32>,
    }
    #[doc = "Number of Identity root Keys in the IRK data structure."]
    pub mod nirk {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NIRK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct NIRKR {
            bits: u8,
        }
        impl NIRKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _NIRKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NIRKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Number of Identity root Keys in the IRK data structure."]
            #[inline]
            pub fn nirk(&self) -> NIRKR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                NIRKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Number of Identity root Keys in the IRK data structure."]
            #[inline]
            pub fn nirk(&mut self) -> _NIRKW {
                _NIRKW { w: self }
            }
        }
    }
    #[doc = "Pointer to the IRK data structure."]
    pub struct IRKPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pointer to the IRK data structure."]
    pub mod irkptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IRKPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pointer to the resolvable address (6 bytes)."]
    pub struct ADDRPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pointer to the resolvable address (6 bytes)."]
    pub mod addrptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADDRPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved."]
    pub struct SCRATCHPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 3 bytes must be reserved."]
    pub mod scratchptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCRATCHPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "AES CCM Mode Encryption."]
pub struct CCM {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CCM {}
impl CCM {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ccm::RegisterBlock {
        0x4000_f000 as *const _
    }
}
impl Deref for CCM {
    type Target = ccm::RegisterBlock;
    fn deref(&self) -> &ccm::RegisterBlock {
        unsafe { &*CCM::ptr() }
    }
}
#[doc = "AES CCM Mode Encryption."]
pub mod ccm {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start generation of key-stream. This operation will stop by itself when completed."]
        pub tasks_ksgen: TASKS_KSGEN,
        #[doc = "0x04 - Start encrypt/decrypt. This operation will stop by itself when completed."]
        pub tasks_crypt: TASKS_CRYPT,
        #[doc = "0x08 - Stop encrypt/decrypt."]
        pub tasks_stop: TASKS_STOP,
        _reserved0: [u8; 244usize],
        #[doc = "0x100 - Keystream generation completed."]
        pub events_endksgen: EVENTS_ENDKSGEN,
        #[doc = "0x104 - Encrypt/decrypt completed."]
        pub events_endcrypt: EVENTS_ENDCRYPT,
        #[doc = "0x108 - Error happened."]
        pub events_error: EVENTS_ERROR,
        _reserved1: [u8; 244usize],
        #[doc = "0x200 - Shortcuts for the CCM."]
        pub shorts: SHORTS,
        _reserved2: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 244usize],
        #[doc = "0x400 - CCM RX MIC check result."]
        pub micstatus: MICSTATUS,
        _reserved4: [u8; 252usize],
        #[doc = "0x500 - CCM enable."]
        pub enable: ENABLE,
        #[doc = "0x504 - Operation mode."]
        pub mode: MODE,
        #[doc = "0x508 - Pointer to a data structure holding AES key and NONCE vector."]
        pub cnfptr: CNFPTR,
        #[doc = "0x50c - Pointer to the input packet."]
        pub inptr: INPTR,
        #[doc = "0x510 - Pointer to the output packet."]
        pub outptr: OUTPTR,
        #[doc = "0x514 - Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved."]
        pub scratchptr: SCRATCHPTR,
        _reserved5: [u8; 2788usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start generation of key-stream. This operation will stop by itself when completed."]
    pub struct TASKS_KSGEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Start generation of key-stream. This operation will stop by itself when completed."]
    pub mod tasks_ksgen {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_KSGEN {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Start encrypt/decrypt. This operation will stop by itself when completed."]
    pub struct TASKS_CRYPT {
        register: VolatileCell<u32>,
    }
    #[doc = "Start encrypt/decrypt. This operation will stop by itself when completed."]
    pub mod tasks_crypt {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_CRYPT {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop encrypt/decrypt."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop encrypt/decrypt."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Keystream generation completed."]
    pub struct EVENTS_ENDKSGEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Keystream generation completed."]
    pub mod events_endksgen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ENDKSGEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Encrypt/decrypt completed."]
    pub struct EVENTS_ENDCRYPT {
        register: VolatileCell<u32>,
    }
    #[doc = "Encrypt/decrypt completed."]
    pub mod events_endcrypt {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ENDCRYPT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Error happened."]
    pub struct EVENTS_ERROR {
        register: VolatileCell<u32>,
    }
    #[doc = "Error happened."]
    pub mod events_error {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ERROR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for the CCM."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for the CCM."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENDKSGEN_CRYPT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDKSGEN_CRYPTR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl ENDKSGEN_CRYPTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDKSGEN_CRYPTR::DISABLED => false,
                    ENDKSGEN_CRYPTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDKSGEN_CRYPTR {
                match value {
                    false => ENDKSGEN_CRYPTR::DISABLED,
                    true => ENDKSGEN_CRYPTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDKSGEN_CRYPTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDKSGEN_CRYPTR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENDKSGEN_CRYPT`"]
        pub enum ENDKSGEN_CRYPTW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl ENDKSGEN_CRYPTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDKSGEN_CRYPTW::DISABLED => false,
                    ENDKSGEN_CRYPTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDKSGEN_CRYPTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDKSGEN_CRYPTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDKSGEN_CRYPTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENDKSGEN_CRYPTW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENDKSGEN_CRYPTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Shortcut between ENDKSGEN event and CRYPT task."]
            #[inline]
            pub fn endksgen_crypt(&self) -> ENDKSGEN_CRYPTR {
                ENDKSGEN_CRYPTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Shortcut between ENDKSGEN event and CRYPT task."]
            #[inline]
            pub fn endksgen_crypt(&mut self) -> _ENDKSGEN_CRYPTW {
                _ENDKSGEN_CRYPTW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENDKSGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDKSGENR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDKSGENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDKSGENR::DISABLED => false,
                    ENDKSGENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDKSGENR {
                match value {
                    false => ENDKSGENR::DISABLED,
                    true => ENDKSGENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDKSGENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDKSGENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENDCRYPT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDCRYPTR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDCRYPTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDCRYPTR::DISABLED => false,
                    ENDCRYPTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDCRYPTR {
                match value {
                    false => ENDCRYPTR::DISABLED,
                    true => ENDCRYPTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDCRYPTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDCRYPTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ERROR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRORR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ERRORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERRORR::DISABLED => false,
                    ERRORR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERRORR {
                match value {
                    false => ERRORR::DISABLED,
                    true => ERRORR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ERRORR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ERRORR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENDKSGEN`"]
        pub enum ENDKSGENW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDKSGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDKSGENW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDKSGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDKSGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDKSGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDKSGENW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENDCRYPT`"]
        pub enum ENDCRYPTW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ENDCRYPTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDCRYPTW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDCRYPTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDCRYPTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDCRYPTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ENDCRYPTW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ERROR`"]
        pub enum ERRORW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ERRORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERRORW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERRORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ERRORW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on ENDKSGEN event."]
            #[inline]
            pub fn endksgen(&self) -> ENDKSGENR {
                ENDKSGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on ENDCRYPT event."]
            #[inline]
            pub fn endcrypt(&self) -> ENDCRYPTR {
                ENDCRYPTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable interrupt on ERROR event."]
            #[inline]
            pub fn error(&self) -> ERRORR {
                ERRORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on ENDKSGEN event."]
            #[inline]
            pub fn endksgen(&mut self) -> _ENDKSGENW {
                _ENDKSGENW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on ENDCRYPT event."]
            #[inline]
            pub fn endcrypt(&mut self) -> _ENDCRYPTW {
                _ENDCRYPTW { w: self }
            }
            #[doc = "Bit 2 - Enable interrupt on ERROR event."]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENDKSGEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDKSGENR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDKSGENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDKSGENR::DISABLED => false,
                    ENDKSGENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDKSGENR {
                match value {
                    false => ENDKSGENR::DISABLED,
                    true => ENDKSGENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDKSGENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDKSGENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENDCRYPT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDCRYPTR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ENDCRYPTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENDCRYPTR::DISABLED => false,
                    ENDCRYPTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENDCRYPTR {
                match value {
                    false => ENDCRYPTR::DISABLED,
                    true => ENDCRYPTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENDCRYPTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENDCRYPTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ERROR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRORR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ERRORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERRORR::DISABLED => false,
                    ERRORR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERRORR {
                match value {
                    false => ERRORR::DISABLED,
                    true => ERRORR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ERRORR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ERRORR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENDKSGEN`"]
        pub enum ENDKSGENW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDKSGENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDKSGENW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDKSGENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDKSGENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDKSGENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDKSGENW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENDCRYPT`"]
        pub enum ENDCRYPTW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ENDCRYPTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENDCRYPTW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENDCRYPTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENDCRYPTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENDCRYPTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ENDCRYPTW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ERROR`"]
        pub enum ERRORW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ERRORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERRORW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERRORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERRORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERRORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ERRORW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on ENDKSGEN event."]
            #[inline]
            pub fn endksgen(&self) -> ENDKSGENR {
                ENDKSGENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on ENDCRYPT event."]
            #[inline]
            pub fn endcrypt(&self) -> ENDCRYPTR {
                ENDCRYPTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable interrupt on ERROR event."]
            #[inline]
            pub fn error(&self) -> ERRORR {
                ERRORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on ENDKSGEN event."]
            #[inline]
            pub fn endksgen(&mut self) -> _ENDKSGENW {
                _ENDKSGENW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on ENDCRYPT event."]
            #[inline]
            pub fn endcrypt(&mut self) -> _ENDCRYPTW {
                _ENDCRYPTW { w: self }
            }
            #[doc = "Bit 2 - Disable interrupt on ERROR event."]
            #[inline]
            pub fn error(&mut self) -> _ERRORW {
                _ERRORW { w: self }
            }
        }
    }
    #[doc = "CCM RX MIC check result."]
    pub struct MICSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "CCM RX MIC check result."]
    pub mod micstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::MICSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `MICSTATUS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MICSTATUSR {
            #[doc = "MIC check failed."]
            CHECKFAILED,
            #[doc = "MIC check passed."]
            CHECKPASSED,
        }
        impl MICSTATUSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MICSTATUSR::CHECKFAILED => false,
                    MICSTATUSR::CHECKPASSED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MICSTATUSR {
                match value {
                    false => MICSTATUSR::CHECKFAILED,
                    true => MICSTATUSR::CHECKPASSED,
                }
            }
            #[doc = "Checks if the value of the field is `CHECKFAILED`"]
            #[inline]
            pub fn is_check_failed(&self) -> bool {
                *self == MICSTATUSR::CHECKFAILED
            }
            #[doc = "Checks if the value of the field is `CHECKPASSED`"]
            #[inline]
            pub fn is_check_passed(&self) -> bool {
                *self == MICSTATUSR::CHECKPASSED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Result of the MIC check performed during the previous CCM RX STARTCRYPT"]
            #[inline]
            pub fn micstatus(&self) -> MICSTATUSR {
                MICSTATUSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "CCM enable."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "CCM enable."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "CCM is disabled."]
            DISABLED,
            #[doc = "CCM is enabled."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x02,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    2 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "CCM is disabled."]
            DISABLED,
            #[doc = "CCM is enabled."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "CCM is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "CCM is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - CCM enable."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - CCM enable."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Operation mode."]
    pub struct MODE {
        register: VolatileCell<u32>,
    }
    #[doc = "Operation mode."]
    pub mod mode {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MODE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "CCM mode TX"]
            ENCRYPTION,
            #[doc = "CCM mode TX"]
            DECRYPTION,
        }
        impl MODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MODER::ENCRYPTION => false,
                    MODER::DECRYPTION => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MODER {
                match value {
                    false => MODER::ENCRYPTION,
                    true => MODER::DECRYPTION,
                }
            }
            #[doc = "Checks if the value of the field is `ENCRYPTION`"]
            #[inline]
            pub fn is_encryption(&self) -> bool {
                *self == MODER::ENCRYPTION
            }
            #[doc = "Checks if the value of the field is `DECRYPTION`"]
            #[inline]
            pub fn is_decryption(&self) -> bool {
                *self == MODER::DECRYPTION
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "CCM mode TX"]
            ENCRYPTION,
            #[doc = "CCM mode TX"]
            DECRYPTION,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MODEW::ENCRYPTION => false,
                    MODEW::DECRYPTION => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CCM mode TX"]
            #[inline]
            pub fn encryption(self) -> &'a mut W {
                self.variant(MODEW::ENCRYPTION)
            }
            #[doc = "CCM mode TX"]
            #[inline]
            pub fn decryption(self) -> &'a mut W {
                self.variant(MODEW::DECRYPTION)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - CCM mode operation."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - CCM mode operation."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
        }
    }
    #[doc = "Pointer to a data structure holding AES key and NONCE vector."]
    pub struct CNFPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pointer to a data structure holding AES key and NONCE vector."]
    pub mod cnfptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CNFPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pointer to the input packet."]
    pub struct INPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pointer to the input packet."]
    pub mod inptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pointer to the output packet."]
    pub struct OUTPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pointer to the output packet."]
    pub mod outptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved."]
    pub struct SCRATCHPTR {
        register: VolatileCell<u32>,
    }
    #[doc = "Pointer to a \"scratch\" data area used for temporary storage during resolution. A minimum of 43 bytes must be reserved."]
    pub mod scratchptr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCRATCHPTR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Watchdog Timer."]
pub struct WDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WDT {}
impl WDT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const wdt::RegisterBlock {
        0x4001_0000 as *const _
    }
}
impl Deref for WDT {
    type Target = wdt::RegisterBlock;
    fn deref(&self) -> &wdt::RegisterBlock {
        unsafe { &*WDT::ptr() }
    }
}
#[doc = "Watchdog Timer."]
pub mod wdt {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start the watchdog."]
        pub tasks_start: TASKS_START,
        _reserved0: [u8; 252usize],
        #[doc = "0x100 - Watchdog timeout."]
        pub events_timeout: EVENTS_TIMEOUT,
        _reserved1: [u8; 512usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved2: [u8; 244usize],
        #[doc = "0x400 - Watchdog running status."]
        pub runstatus: RUNSTATUS,
        #[doc = "0x404 - Request status."]
        pub reqstatus: REQSTATUS,
        _reserved3: [u8; 252usize],
        #[doc = "0x504 - Counter reload value in number of 32kiHz clock cycles."]
        pub crv: CRV,
        #[doc = "0x508 - Reload request enable."]
        pub rren: RREN,
        #[doc = "0x50c - Configuration register."]
        pub config: CONFIG,
        _reserved4: [u8; 240usize],
        #[doc = "0x600 - Reload requests registers."]
        pub rr: [RR; 8],
        _reserved5: [u8; 2524usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start the watchdog."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start the watchdog."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Watchdog timeout."]
    pub struct EVENTS_TIMEOUT {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog timeout."]
    pub mod events_timeout {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_TIMEOUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TIMEOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMEOUTR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl TIMEOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TIMEOUTR::DISABLED => false,
                    TIMEOUTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TIMEOUTR {
                match value {
                    false => TIMEOUTR::DISABLED,
                    true => TIMEOUTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TIMEOUTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TIMEOUTR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TIMEOUT`"]
        pub enum TIMEOUTW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl TIMEOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIMEOUTW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMEOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIMEOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(TIMEOUTW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on TIMEOUT event."]
            #[inline]
            pub fn timeout(&self) -> TIMEOUTR {
                TIMEOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on TIMEOUT event."]
            #[inline]
            pub fn timeout(&mut self) -> _TIMEOUTW {
                _TIMEOUTW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `TIMEOUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMEOUTR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl TIMEOUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TIMEOUTR::DISABLED => false,
                    TIMEOUTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TIMEOUTR {
                match value {
                    false => TIMEOUTR::DISABLED,
                    true => TIMEOUTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == TIMEOUTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == TIMEOUTR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `TIMEOUT`"]
        pub enum TIMEOUTW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl TIMEOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TIMEOUTW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TIMEOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TIMEOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TIMEOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIMEOUTW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on TIMEOUT event."]
            #[inline]
            pub fn timeout(&self) -> TIMEOUTR {
                TIMEOUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on TIMEOUT event."]
            #[inline]
            pub fn timeout(&mut self) -> _TIMEOUTW {
                _TIMEOUTW { w: self }
            }
        }
    }
    #[doc = "Watchdog running status."]
    pub struct RUNSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Watchdog running status."]
    pub mod runstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RUNSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `RUNSTATUS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RUNSTATUSR {
            #[doc = "Watchdog timer is not running."]
            NOTRUNNING,
            #[doc = "Watchdog timer is running."]
            RUNNING,
        }
        impl RUNSTATUSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RUNSTATUSR::NOTRUNNING => false,
                    RUNSTATUSR::RUNNING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RUNSTATUSR {
                match value {
                    false => RUNSTATUSR::NOTRUNNING,
                    true => RUNSTATUSR::RUNNING,
                }
            }
            #[doc = "Checks if the value of the field is `NOTRUNNING`"]
            #[inline]
            pub fn is_not_running(&self) -> bool {
                *self == RUNSTATUSR::NOTRUNNING
            }
            #[doc = "Checks if the value of the field is `RUNNING`"]
            #[inline]
            pub fn is_running(&self) -> bool {
                *self == RUNSTATUSR::RUNNING
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Watchdog running status."]
            #[inline]
            pub fn runstatus(&self) -> RUNSTATUSR {
                RUNSTATUSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Request status."]
    pub struct REQSTATUS {
        register: VolatileCell<u32>,
    }
    #[doc = "Request status."]
    pub mod reqstatus {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::REQSTATUS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `RR0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR0R {
            #[doc = "RR[0] register is not enabled or has already requested reload."]
            DISABLEDORREQUESTED,
            #[doc = "RR[0] register is enabled and has not jet requested."]
            ENABLEDANDUNREQUESTED,
        }
        impl RR0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR0R::DISABLEDORREQUESTED => false,
                    RR0R::ENABLEDANDUNREQUESTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR0R {
                match value {
                    false => RR0R::DISABLEDORREQUESTED,
                    true => RR0R::ENABLEDANDUNREQUESTED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDORREQUESTED`"]
            #[inline]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == RR0R::DISABLEDORREQUESTED
            }
            #[doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`"]
            #[inline]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == RR0R::ENABLEDANDUNREQUESTED
            }
        }
        #[doc = "Possible values of the field `RR1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR1R {
            #[doc = "RR[1] register is not enabled or has already requested reload."]
            DISABLEDORREQUESTED,
            #[doc = "RR[1] register is enabled and has not jet requested."]
            ENABLEDANDUNREQUESTED,
        }
        impl RR1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR1R::DISABLEDORREQUESTED => false,
                    RR1R::ENABLEDANDUNREQUESTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR1R {
                match value {
                    false => RR1R::DISABLEDORREQUESTED,
                    true => RR1R::ENABLEDANDUNREQUESTED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDORREQUESTED`"]
            #[inline]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == RR1R::DISABLEDORREQUESTED
            }
            #[doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`"]
            #[inline]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == RR1R::ENABLEDANDUNREQUESTED
            }
        }
        #[doc = "Possible values of the field `RR2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR2R {
            #[doc = "RR[2] register is not enabled or has already requested reload."]
            DISABLEDORREQUESTED,
            #[doc = "RR[2] register is enabled and has not jet requested."]
            ENABLEDANDUNREQUESTED,
        }
        impl RR2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR2R::DISABLEDORREQUESTED => false,
                    RR2R::ENABLEDANDUNREQUESTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR2R {
                match value {
                    false => RR2R::DISABLEDORREQUESTED,
                    true => RR2R::ENABLEDANDUNREQUESTED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDORREQUESTED`"]
            #[inline]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == RR2R::DISABLEDORREQUESTED
            }
            #[doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`"]
            #[inline]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == RR2R::ENABLEDANDUNREQUESTED
            }
        }
        #[doc = "Possible values of the field `RR3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR3R {
            #[doc = "RR[3] register is not enabled or has already requested reload."]
            DISABLEDORREQUESTED,
            #[doc = "RR[3] register is enabled and has not jet requested."]
            ENABLEDANDUNREQUESTED,
        }
        impl RR3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR3R::DISABLEDORREQUESTED => false,
                    RR3R::ENABLEDANDUNREQUESTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR3R {
                match value {
                    false => RR3R::DISABLEDORREQUESTED,
                    true => RR3R::ENABLEDANDUNREQUESTED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDORREQUESTED`"]
            #[inline]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == RR3R::DISABLEDORREQUESTED
            }
            #[doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`"]
            #[inline]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == RR3R::ENABLEDANDUNREQUESTED
            }
        }
        #[doc = "Possible values of the field `RR4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR4R {
            #[doc = "RR[4] register is not enabled or has already requested reload."]
            DISABLEDORREQUESTED,
            #[doc = "RR[4] register is enabled and has not jet requested."]
            ENABLEDANDUNREQUESTED,
        }
        impl RR4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR4R::DISABLEDORREQUESTED => false,
                    RR4R::ENABLEDANDUNREQUESTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR4R {
                match value {
                    false => RR4R::DISABLEDORREQUESTED,
                    true => RR4R::ENABLEDANDUNREQUESTED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDORREQUESTED`"]
            #[inline]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == RR4R::DISABLEDORREQUESTED
            }
            #[doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`"]
            #[inline]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == RR4R::ENABLEDANDUNREQUESTED
            }
        }
        #[doc = "Possible values of the field `RR5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR5R {
            #[doc = "RR[5] register is not enabled or has already requested reload."]
            DISABLEDORREQUESTED,
            #[doc = "RR[5] register is enabled and has not jet requested."]
            ENABLEDANDUNREQUESTED,
        }
        impl RR5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR5R::DISABLEDORREQUESTED => false,
                    RR5R::ENABLEDANDUNREQUESTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR5R {
                match value {
                    false => RR5R::DISABLEDORREQUESTED,
                    true => RR5R::ENABLEDANDUNREQUESTED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDORREQUESTED`"]
            #[inline]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == RR5R::DISABLEDORREQUESTED
            }
            #[doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`"]
            #[inline]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == RR5R::ENABLEDANDUNREQUESTED
            }
        }
        #[doc = "Possible values of the field `RR6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR6R {
            #[doc = "RR[6] register is not enabled or has already requested reload."]
            DISABLEDORREQUESTED,
            #[doc = "RR[6] register is enabled and has not jet requested."]
            ENABLEDANDUNREQUESTED,
        }
        impl RR6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR6R::DISABLEDORREQUESTED => false,
                    RR6R::ENABLEDANDUNREQUESTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR6R {
                match value {
                    false => RR6R::DISABLEDORREQUESTED,
                    true => RR6R::ENABLEDANDUNREQUESTED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDORREQUESTED`"]
            #[inline]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == RR6R::DISABLEDORREQUESTED
            }
            #[doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`"]
            #[inline]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == RR6R::ENABLEDANDUNREQUESTED
            }
        }
        #[doc = "Possible values of the field `RR7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR7R {
            #[doc = "RR[7] register is not enabled or has already requested reload."]
            DISABLEDORREQUESTED,
            #[doc = "RR[7] register is enabled and has not jet requested."]
            ENABLEDANDUNREQUESTED,
        }
        impl RR7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR7R::DISABLEDORREQUESTED => false,
                    RR7R::ENABLEDANDUNREQUESTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR7R {
                match value {
                    false => RR7R::DISABLEDORREQUESTED,
                    true => RR7R::ENABLEDANDUNREQUESTED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLEDORREQUESTED`"]
            #[inline]
            pub fn is_disabled_or_requested(&self) -> bool {
                *self == RR7R::DISABLEDORREQUESTED
            }
            #[doc = "Checks if the value of the field is `ENABLEDANDUNREQUESTED`"]
            #[inline]
            pub fn is_enabled_and_unrequested(&self) -> bool {
                *self == RR7R::ENABLEDANDUNREQUESTED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Request status for RR[0]."]
            #[inline]
            pub fn rr0(&self) -> RR0R {
                RR0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Request status for RR[1]."]
            #[inline]
            pub fn rr1(&self) -> RR1R {
                RR1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Request status for RR[2]."]
            #[inline]
            pub fn rr2(&self) -> RR2R {
                RR2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Request status for RR[3]."]
            #[inline]
            pub fn rr3(&self) -> RR3R {
                RR3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Request status for RR[4]."]
            #[inline]
            pub fn rr4(&self) -> RR4R {
                RR4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Request status for RR[5]."]
            #[inline]
            pub fn rr5(&self) -> RR5R {
                RR5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Request status for RR[6]."]
            #[inline]
            pub fn rr6(&self) -> RR6R {
                RR6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Request status for RR[7]."]
            #[inline]
            pub fn rr7(&self) -> RR7R {
                RR7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Counter reload value in number of 32kiHz clock cycles."]
    pub struct CRV {
        register: VolatileCell<u32>,
    }
    #[doc = "Counter reload value in number of 32kiHz clock cycles."]
    pub mod crv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CRV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Reload request enable."]
    pub struct RREN {
        register: VolatileCell<u32>,
    }
    #[doc = "Reload request enable."]
    pub mod rren {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RREN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RR0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR0R {
            #[doc = "RR[0] register is disabled."]
            DISABLED,
            #[doc = "RR[0] register is enabled."]
            ENABLED,
        }
        impl RR0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR0R::DISABLED => false,
                    RR0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR0R {
                match value {
                    false => RR0R::DISABLED,
                    true => RR0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RR0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RR0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `RR1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR1R {
            #[doc = "RR[1] register is disabled."]
            DISABLED,
            #[doc = "RR[1] register is enabled."]
            ENABLED,
        }
        impl RR1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR1R::DISABLED => false,
                    RR1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR1R {
                match value {
                    false => RR1R::DISABLED,
                    true => RR1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RR1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RR1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `RR2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR2R {
            #[doc = "RR[2] register is disabled."]
            DISABLED,
            #[doc = "RR[2] register is enabled."]
            ENABLED,
        }
        impl RR2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR2R::DISABLED => false,
                    RR2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR2R {
                match value {
                    false => RR2R::DISABLED,
                    true => RR2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RR2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RR2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `RR3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR3R {
            #[doc = "RR[3] register is disabled."]
            DISABLED,
            #[doc = "RR[3] register is enabled."]
            ENABLED,
        }
        impl RR3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR3R::DISABLED => false,
                    RR3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR3R {
                match value {
                    false => RR3R::DISABLED,
                    true => RR3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RR3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RR3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `RR4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR4R {
            #[doc = "RR[4] register is disabled."]
            DISABLED,
            #[doc = "RR[4] register is enabled."]
            ENABLED,
        }
        impl RR4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR4R::DISABLED => false,
                    RR4R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR4R {
                match value {
                    false => RR4R::DISABLED,
                    true => RR4R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RR4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RR4R::ENABLED
            }
        }
        #[doc = "Possible values of the field `RR5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR5R {
            #[doc = "RR[5] register is disabled."]
            DISABLED,
            #[doc = "RR[5] register is enabled."]
            ENABLED,
        }
        impl RR5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR5R::DISABLED => false,
                    RR5R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR5R {
                match value {
                    false => RR5R::DISABLED,
                    true => RR5R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RR5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RR5R::ENABLED
            }
        }
        #[doc = "Possible values of the field `RR6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR6R {
            #[doc = "RR[6] register is disabled."]
            DISABLED,
            #[doc = "RR[6] register is enabled."]
            ENABLED,
        }
        impl RR6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR6R::DISABLED => false,
                    RR6R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR6R {
                match value {
                    false => RR6R::DISABLED,
                    true => RR6R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RR6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RR6R::ENABLED
            }
        }
        #[doc = "Possible values of the field `RR7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RR7R {
            #[doc = "RR[7] register is disabled."]
            DISABLED,
            #[doc = "RR[7] register is enabled."]
            ENABLED,
        }
        impl RR7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RR7R::DISABLED => false,
                    RR7R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RR7R {
                match value {
                    false => RR7R::DISABLED,
                    true => RR7R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RR7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RR7R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `RR0`"]
        pub enum RR0W {
            #[doc = "RR[0] register is disabled."]
            DISABLED,
            #[doc = "RR[0] register is enabled."]
            ENABLED,
        }
        impl RR0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RR0W::DISABLED => false,
                    RR0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RR0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RR0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RR[0] register is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RR0W::DISABLED)
            }
            #[doc = "RR[0] register is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RR0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RR1`"]
        pub enum RR1W {
            #[doc = "RR[1] register is disabled."]
            DISABLED,
            #[doc = "RR[1] register is enabled."]
            ENABLED,
        }
        impl RR1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RR1W::DISABLED => false,
                    RR1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RR1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RR1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RR[1] register is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RR1W::DISABLED)
            }
            #[doc = "RR[1] register is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RR1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RR2`"]
        pub enum RR2W {
            #[doc = "RR[2] register is disabled."]
            DISABLED,
            #[doc = "RR[2] register is enabled."]
            ENABLED,
        }
        impl RR2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RR2W::DISABLED => false,
                    RR2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RR2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RR2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RR[2] register is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RR2W::DISABLED)
            }
            #[doc = "RR[2] register is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RR2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RR3`"]
        pub enum RR3W {
            #[doc = "RR[3] register is disabled."]
            DISABLED,
            #[doc = "RR[3] register is enabled."]
            ENABLED,
        }
        impl RR3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RR3W::DISABLED => false,
                    RR3W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RR3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RR3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RR[3] register is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RR3W::DISABLED)
            }
            #[doc = "RR[3] register is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RR3W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RR4`"]
        pub enum RR4W {
            #[doc = "RR[4] register is disabled."]
            DISABLED,
            #[doc = "RR[4] register is enabled."]
            ENABLED,
        }
        impl RR4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RR4W::DISABLED => false,
                    RR4W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RR4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RR4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RR[4] register is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RR4W::DISABLED)
            }
            #[doc = "RR[4] register is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RR4W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RR5`"]
        pub enum RR5W {
            #[doc = "RR[5] register is disabled."]
            DISABLED,
            #[doc = "RR[5] register is enabled."]
            ENABLED,
        }
        impl RR5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RR5W::DISABLED => false,
                    RR5W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RR5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RR5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RR[5] register is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RR5W::DISABLED)
            }
            #[doc = "RR[5] register is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RR5W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RR6`"]
        pub enum RR6W {
            #[doc = "RR[6] register is disabled."]
            DISABLED,
            #[doc = "RR[6] register is enabled."]
            ENABLED,
        }
        impl RR6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RR6W::DISABLED => false,
                    RR6W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RR6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RR6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RR[6] register is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RR6W::DISABLED)
            }
            #[doc = "RR[6] register is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RR6W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RR7`"]
        pub enum RR7W {
            #[doc = "RR[7] register is disabled."]
            DISABLED,
            #[doc = "RR[7] register is enabled."]
            ENABLED,
        }
        impl RR7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RR7W::DISABLED => false,
                    RR7W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RR7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RR7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RR[7] register is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RR7W::DISABLED)
            }
            #[doc = "RR[7] register is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RR7W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable or disable RR[0] register."]
            #[inline]
            pub fn rr0(&self) -> RR0R {
                RR0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable or disable RR[1] register."]
            #[inline]
            pub fn rr1(&self) -> RR1R {
                RR1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable or disable RR[2] register."]
            #[inline]
            pub fn rr2(&self) -> RR2R {
                RR2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable or disable RR[3] register."]
            #[inline]
            pub fn rr3(&self) -> RR3R {
                RR3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enable or disable RR[4] register."]
            #[inline]
            pub fn rr4(&self) -> RR4R {
                RR4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enable or disable RR[5] register."]
            #[inline]
            pub fn rr5(&self) -> RR5R {
                RR5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enable or disable RR[6] register."]
            #[inline]
            pub fn rr6(&self) -> RR6R {
                RR6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enable or disable RR[7] register."]
            #[inline]
            pub fn rr7(&self) -> RR7R {
                RR7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable or disable RR[0] register."]
            #[inline]
            pub fn rr0(&mut self) -> _RR0W {
                _RR0W { w: self }
            }
            #[doc = "Bit 1 - Enable or disable RR[1] register."]
            #[inline]
            pub fn rr1(&mut self) -> _RR1W {
                _RR1W { w: self }
            }
            #[doc = "Bit 2 - Enable or disable RR[2] register."]
            #[inline]
            pub fn rr2(&mut self) -> _RR2W {
                _RR2W { w: self }
            }
            #[doc = "Bit 3 - Enable or disable RR[3] register."]
            #[inline]
            pub fn rr3(&mut self) -> _RR3W {
                _RR3W { w: self }
            }
            #[doc = "Bit 4 - Enable or disable RR[4] register."]
            #[inline]
            pub fn rr4(&mut self) -> _RR4W {
                _RR4W { w: self }
            }
            #[doc = "Bit 5 - Enable or disable RR[5] register."]
            #[inline]
            pub fn rr5(&mut self) -> _RR5W {
                _RR5W { w: self }
            }
            #[doc = "Bit 6 - Enable or disable RR[6] register."]
            #[inline]
            pub fn rr6(&mut self) -> _RR6W {
                _RR6W { w: self }
            }
            #[doc = "Bit 7 - Enable or disable RR[7] register."]
            #[inline]
            pub fn rr7(&mut self) -> _RR7W {
                _RR7W { w: self }
            }
        }
    }
    #[doc = "Configuration register."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration register."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SLEEP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLEEPR {
            #[doc = "Pause watchdog while the CPU is asleep."]
            PAUSE,
            #[doc = "Do not pause watchdog while the CPU is asleep."]
            RUN,
        }
        impl SLEEPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLEEPR::PAUSE => false,
                    SLEEPR::RUN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLEEPR {
                match value {
                    false => SLEEPR::PAUSE,
                    true => SLEEPR::RUN,
                }
            }
            #[doc = "Checks if the value of the field is `PAUSE`"]
            #[inline]
            pub fn is_pause(&self) -> bool {
                *self == SLEEPR::PAUSE
            }
            #[doc = "Checks if the value of the field is `RUN`"]
            #[inline]
            pub fn is_run(&self) -> bool {
                *self == SLEEPR::RUN
            }
        }
        #[doc = "Possible values of the field `HALT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HALTR {
            #[doc = "Pause watchdog while the CPU is halted by the debugger."]
            PAUSE,
            #[doc = "Do not pause watchdog while the CPU is halted by the debugger."]
            RUN,
        }
        impl HALTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HALTR::PAUSE => false,
                    HALTR::RUN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HALTR {
                match value {
                    false => HALTR::PAUSE,
                    true => HALTR::RUN,
                }
            }
            #[doc = "Checks if the value of the field is `PAUSE`"]
            #[inline]
            pub fn is_pause(&self) -> bool {
                *self == HALTR::PAUSE
            }
            #[doc = "Checks if the value of the field is `RUN`"]
            #[inline]
            pub fn is_run(&self) -> bool {
                *self == HALTR::RUN
            }
        }
        #[doc = "Values that can be written to the field `SLEEP`"]
        pub enum SLEEPW {
            #[doc = "Pause watchdog while the CPU is asleep."]
            PAUSE,
            #[doc = "Do not pause watchdog while the CPU is asleep."]
            RUN,
        }
        impl SLEEPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLEEPW::PAUSE => false,
                    SLEEPW::RUN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLEEPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLEEPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLEEPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pause watchdog while the CPU is asleep."]
            #[inline]
            pub fn pause(self) -> &'a mut W {
                self.variant(SLEEPW::PAUSE)
            }
            #[doc = "Do not pause watchdog while the CPU is asleep."]
            #[inline]
            pub fn run(self) -> &'a mut W {
                self.variant(SLEEPW::RUN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HALT`"]
        pub enum HALTW {
            #[doc = "Pause watchdog while the CPU is halted by the debugger."]
            PAUSE,
            #[doc = "Do not pause watchdog while the CPU is halted by the debugger."]
            RUN,
        }
        impl HALTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HALTW::PAUSE => false,
                    HALTW::RUN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HALTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HALTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HALTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pause watchdog while the CPU is halted by the debugger."]
            #[inline]
            pub fn pause(self) -> &'a mut W {
                self.variant(HALTW::PAUSE)
            }
            #[doc = "Do not pause watchdog while the CPU is halted by the debugger."]
            #[inline]
            pub fn run(self) -> &'a mut W {
                self.variant(HALTW::RUN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Configure the watchdog to pause or not while the CPU is sleeping."]
            #[inline]
            pub fn sleep(&self) -> SLEEPR {
                SLEEPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Configure the watchdog to pause or not while the CPU is halted by the debugger."]
            #[inline]
            pub fn halt(&self) -> HALTR {
                HALTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Configure the watchdog to pause or not while the CPU is sleeping."]
            #[inline]
            pub fn sleep(&mut self) -> _SLEEPW {
                _SLEEPW { w: self }
            }
            #[doc = "Bit 3 - Configure the watchdog to pause or not while the CPU is halted by the debugger."]
            #[inline]
            pub fn halt(&mut self) -> _HALTW {
                _HALTW { w: self }
            }
        }
    }
    #[doc = "Reload requests registers."]
    pub struct RR {
        register: VolatileCell<u32>,
    }
    #[doc = "Reload requests registers."]
    pub mod rr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `RR`"]
        pub enum RRW {
            #[doc = "Value to request a reload of the watchdog timer."]
            RELOAD,
        }
        impl RRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u32 {
                match *self {
                    RRW::RELOAD => 1850885685,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RRW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Value to request a reload of the watchdog timer."]
            #[inline]
            pub fn reload(self) -> &'a mut W {
                self.variant(RRW::RELOAD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Reload register."]
            #[inline]
            pub fn rr(&mut self) -> _RRW {
                _RRW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Real time counter 1."]
pub struct RTC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC1 {}
impl RTC1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const rtc0::RegisterBlock {
        0x4001_1000 as *const _
    }
}
impl Deref for RTC1 {
    type Target = rtc0::RegisterBlock;
    fn deref(&self) -> &rtc0::RegisterBlock {
        unsafe { &*RTC1::ptr() }
    }
}
#[doc = "Rotary decoder."]
pub struct QDEC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for QDEC {}
impl QDEC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const qdec::RegisterBlock {
        0x4001_2000 as *const _
    }
}
impl Deref for QDEC {
    type Target = qdec::RegisterBlock;
    fn deref(&self) -> &qdec::RegisterBlock {
        unsafe { &*QDEC::ptr() }
    }
}
#[doc = "Rotary decoder."]
pub mod qdec {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start the quadrature decoder."]
        pub tasks_start: TASKS_START,
        #[doc = "0x04 - Stop the quadrature decoder."]
        pub tasks_stop: TASKS_STOP,
        #[doc = "0x08 - Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers."]
        pub tasks_readclracc: TASKS_READCLRACC,
        _reserved0: [u8; 244usize],
        #[doc = "0x100 - A new sample is written to the sample register."]
        pub events_samplerdy: EVENTS_SAMPLERDY,
        #[doc = "0x104 - REPORTPER number of samples accumulated in ACC register, and ACC register different than zero."]
        pub events_reportrdy: EVENTS_REPORTRDY,
        #[doc = "0x108 - ACC or ACCDBL register overflow."]
        pub events_accof: EVENTS_ACCOF,
        _reserved1: [u8; 244usize],
        #[doc = "0x200 - Shortcuts for the QDEC."]
        pub shorts: SHORTS,
        _reserved2: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 500usize],
        #[doc = "0x500 - Enable the QDEC."]
        pub enable: ENABLE,
        #[doc = "0x504 - LED output pin polarity."]
        pub ledpol: LEDPOL,
        #[doc = "0x508 - Sample period."]
        pub sampleper: SAMPLEPER,
        #[doc = "0x50c - Motion sample value."]
        pub sample: SAMPLE,
        #[doc = "0x510 - Number of samples to generate an EVENT_REPORTRDY."]
        pub reportper: REPORTPER,
        #[doc = "0x514 - Accumulated valid transitions register."]
        pub acc: ACC,
        #[doc = "0x518 - Snapshot of ACC register. Value generated by the TASKS_READCLEACC task."]
        pub accread: ACCREAD,
        #[doc = "0x51c - Pin select for LED output."]
        pub pselled: PSELLED,
        #[doc = "0x520 - Pin select for phase A input."]
        pub psela: PSELA,
        #[doc = "0x524 - Pin select for phase B input."]
        pub pselb: PSELB,
        #[doc = "0x528 - Enable debouncer input filters."]
        pub dbfen: DBFEN,
        _reserved4: [u8; 20usize],
        #[doc = "0x540 - Time LED is switched ON before the sample."]
        pub ledpre: LEDPRE,
        #[doc = "0x544 - Accumulated double (error) transitions register."]
        pub accdbl: ACCDBL,
        #[doc = "0x548 - Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task."]
        pub accdblread: ACCDBLREAD,
        _reserved5: [u8; 2736usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start the quadrature decoder."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start the quadrature decoder."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop the quadrature decoder."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop the quadrature decoder."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers."]
    pub struct TASKS_READCLRACC {
        register: VolatileCell<u32>,
    }
    #[doc = "Transfers the content from ACC registers to ACCREAD registers, and clears the ACC registers."]
    pub mod tasks_readclracc {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_READCLRACC {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "A new sample is written to the sample register."]
    pub struct EVENTS_SAMPLERDY {
        register: VolatileCell<u32>,
    }
    #[doc = "A new sample is written to the sample register."]
    pub mod events_samplerdy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_SAMPLERDY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "REPORTPER number of samples accumulated in ACC register, and ACC register different than zero."]
    pub struct EVENTS_REPORTRDY {
        register: VolatileCell<u32>,
    }
    #[doc = "REPORTPER number of samples accumulated in ACC register, and ACC register different than zero."]
    pub mod events_reportrdy {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_REPORTRDY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "ACC or ACCDBL register overflow."]
    pub struct EVENTS_ACCOF {
        register: VolatileCell<u32>,
    }
    #[doc = "ACC or ACCDBL register overflow."]
    pub mod events_accof {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_ACCOF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for the QDEC."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for the QDEC."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `REPORTRDY_READCLRACC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REPORTRDY_READCLRACCR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl REPORTRDY_READCLRACCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    REPORTRDY_READCLRACCR::DISABLED => false,
                    REPORTRDY_READCLRACCR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> REPORTRDY_READCLRACCR {
                match value {
                    false => REPORTRDY_READCLRACCR::DISABLED,
                    true => REPORTRDY_READCLRACCR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == REPORTRDY_READCLRACCR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == REPORTRDY_READCLRACCR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SAMPLERDY_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SAMPLERDY_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl SAMPLERDY_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SAMPLERDY_STOPR::DISABLED => false,
                    SAMPLERDY_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SAMPLERDY_STOPR {
                match value {
                    false => SAMPLERDY_STOPR::DISABLED,
                    true => SAMPLERDY_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SAMPLERDY_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SAMPLERDY_STOPR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `REPORTRDY_READCLRACC`"]
        pub enum REPORTRDY_READCLRACCW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl REPORTRDY_READCLRACCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    REPORTRDY_READCLRACCW::DISABLED => false,
                    REPORTRDY_READCLRACCW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REPORTRDY_READCLRACCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REPORTRDY_READCLRACCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: REPORTRDY_READCLRACCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(REPORTRDY_READCLRACCW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(REPORTRDY_READCLRACCW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SAMPLERDY_STOP`"]
        pub enum SAMPLERDY_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl SAMPLERDY_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SAMPLERDY_STOPW::DISABLED => false,
                    SAMPLERDY_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLERDY_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLERDY_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SAMPLERDY_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SAMPLERDY_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SAMPLERDY_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Shortcut between REPORTRDY event and READCLRACC task."]
            #[inline]
            pub fn reportrdy_readclracc(&self) -> REPORTRDY_READCLRACCR {
                REPORTRDY_READCLRACCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Shortcut between SAMPLERDY event and STOP task."]
            #[inline]
            pub fn samplerdy_stop(&self) -> SAMPLERDY_STOPR {
                SAMPLERDY_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Shortcut between REPORTRDY event and READCLRACC task."]
            #[inline]
            pub fn reportrdy_readclracc(&mut self) -> _REPORTRDY_READCLRACCW {
                _REPORTRDY_READCLRACCW { w: self }
            }
            #[doc = "Bit 1 - Shortcut between SAMPLERDY event and STOP task."]
            #[inline]
            pub fn samplerdy_stop(&mut self) -> _SAMPLERDY_STOPW {
                _SAMPLERDY_STOPW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SAMPLERDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SAMPLERDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl SAMPLERDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SAMPLERDYR::DISABLED => false,
                    SAMPLERDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SAMPLERDYR {
                match value {
                    false => SAMPLERDYR::DISABLED,
                    true => SAMPLERDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SAMPLERDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SAMPLERDYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `REPORTRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REPORTRDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl REPORTRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    REPORTRDYR::DISABLED => false,
                    REPORTRDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> REPORTRDYR {
                match value {
                    false => REPORTRDYR::DISABLED,
                    true => REPORTRDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == REPORTRDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == REPORTRDYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ACCOF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACCOFR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ACCOFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACCOFR::DISABLED => false,
                    ACCOFR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACCOFR {
                match value {
                    false => ACCOFR::DISABLED,
                    true => ACCOFR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ACCOFR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ACCOFR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `SAMPLERDY`"]
        pub enum SAMPLERDYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl SAMPLERDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SAMPLERDYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLERDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLERDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SAMPLERDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(SAMPLERDYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REPORTRDY`"]
        pub enum REPORTRDYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl REPORTRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    REPORTRDYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REPORTRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REPORTRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: REPORTRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(REPORTRDYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACCOF`"]
        pub enum ACCOFW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl ACCOFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACCOFW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACCOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACCOFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACCOFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(ACCOFW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on SAMPLERDY event."]
            #[inline]
            pub fn samplerdy(&self) -> SAMPLERDYR {
                SAMPLERDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on REPORTRDY event."]
            #[inline]
            pub fn reportrdy(&self) -> REPORTRDYR {
                REPORTRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable interrupt on ACCOF event."]
            #[inline]
            pub fn accof(&self) -> ACCOFR {
                ACCOFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on SAMPLERDY event."]
            #[inline]
            pub fn samplerdy(&mut self) -> _SAMPLERDYW {
                _SAMPLERDYW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on REPORTRDY event."]
            #[inline]
            pub fn reportrdy(&mut self) -> _REPORTRDYW {
                _REPORTRDYW { w: self }
            }
            #[doc = "Bit 2 - Enable interrupt on ACCOF event."]
            #[inline]
            pub fn accof(&mut self) -> _ACCOFW {
                _ACCOFW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SAMPLERDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SAMPLERDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl SAMPLERDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SAMPLERDYR::DISABLED => false,
                    SAMPLERDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SAMPLERDYR {
                match value {
                    false => SAMPLERDYR::DISABLED,
                    true => SAMPLERDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SAMPLERDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SAMPLERDYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `REPORTRDY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REPORTRDYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl REPORTRDYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    REPORTRDYR::DISABLED => false,
                    REPORTRDYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> REPORTRDYR {
                match value {
                    false => REPORTRDYR::DISABLED,
                    true => REPORTRDYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == REPORTRDYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == REPORTRDYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ACCOF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACCOFR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl ACCOFR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ACCOFR::DISABLED => false,
                    ACCOFR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ACCOFR {
                match value {
                    false => ACCOFR::DISABLED,
                    true => ACCOFR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ACCOFR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ACCOFR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `SAMPLERDY`"]
        pub enum SAMPLERDYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl SAMPLERDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SAMPLERDYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLERDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLERDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SAMPLERDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(SAMPLERDYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `REPORTRDY`"]
        pub enum REPORTRDYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl REPORTRDYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    REPORTRDYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REPORTRDYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REPORTRDYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: REPORTRDYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(REPORTRDYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ACCOF`"]
        pub enum ACCOFW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl ACCOFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ACCOFW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ACCOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ACCOFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ACCOFW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ACCOFW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on SAMPLERDY event."]
            #[inline]
            pub fn samplerdy(&self) -> SAMPLERDYR {
                SAMPLERDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on REPORTRDY event."]
            #[inline]
            pub fn reportrdy(&self) -> REPORTRDYR {
                REPORTRDYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable interrupt on ACCOF event."]
            #[inline]
            pub fn accof(&self) -> ACCOFR {
                ACCOFR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on SAMPLERDY event."]
            #[inline]
            pub fn samplerdy(&mut self) -> _SAMPLERDYW {
                _SAMPLERDYW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on REPORTRDY event."]
            #[inline]
            pub fn reportrdy(&mut self) -> _REPORTRDYW {
                _REPORTRDYW { w: self }
            }
            #[doc = "Bit 2 - Disable interrupt on ACCOF event."]
            #[inline]
            pub fn accof(&mut self) -> _ACCOFW {
                _ACCOFW { w: self }
            }
        }
    }
    #[doc = "Enable the QDEC."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable the QDEC."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled QDEC."]
            DISABLED,
            #[doc = "Enable QDEC."]
            ENABLED,
        }
        impl ENABLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENABLER::DISABLED => false,
                    ENABLER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENABLER {
                match value {
                    false => ENABLER::DISABLED,
                    true => ENABLER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled QDEC."]
            DISABLED,
            #[doc = "Enable QDEC."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENABLEW::DISABLED => false,
                    ENABLEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled QDEC."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enable QDEC."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable or disable QDEC."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable or disable QDEC."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "LED output pin polarity."]
    pub struct LEDPOL {
        register: VolatileCell<u32>,
    }
    #[doc = "LED output pin polarity."]
    pub mod ledpol {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LEDPOL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LEDPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LEDPOLR {
            #[doc = "LED output is active low."]
            ACTIVELOW,
            #[doc = "LED output is active high."]
            ACTIVEHIGH,
        }
        impl LEDPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LEDPOLR::ACTIVELOW => false,
                    LEDPOLR::ACTIVEHIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LEDPOLR {
                match value {
                    false => LEDPOLR::ACTIVELOW,
                    true => LEDPOLR::ACTIVEHIGH,
                }
            }
            #[doc = "Checks if the value of the field is `ACTIVELOW`"]
            #[inline]
            pub fn is_active_low(&self) -> bool {
                *self == LEDPOLR::ACTIVELOW
            }
            #[doc = "Checks if the value of the field is `ACTIVEHIGH`"]
            #[inline]
            pub fn is_active_high(&self) -> bool {
                *self == LEDPOLR::ACTIVEHIGH
            }
        }
        #[doc = "Values that can be written to the field `LEDPOL`"]
        pub enum LEDPOLW {
            #[doc = "LED output is active low."]
            ACTIVELOW,
            #[doc = "LED output is active high."]
            ACTIVEHIGH,
        }
        impl LEDPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LEDPOLW::ACTIVELOW => false,
                    LEDPOLW::ACTIVEHIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEDPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEDPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LEDPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "LED output is active low."]
            #[inline]
            pub fn active_low(self) -> &'a mut W {
                self.variant(LEDPOLW::ACTIVELOW)
            }
            #[doc = "LED output is active high."]
            #[inline]
            pub fn active_high(self) -> &'a mut W {
                self.variant(LEDPOLW::ACTIVEHIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - LED output pin polarity."]
            #[inline]
            pub fn ledpol(&self) -> LEDPOLR {
                LEDPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - LED output pin polarity."]
            #[inline]
            pub fn ledpol(&mut self) -> _LEDPOLW {
                _LEDPOLW { w: self }
            }
        }
    }
    #[doc = "Sample period."]
    pub struct SAMPLEPER {
        register: VolatileCell<u32>,
    }
    #[doc = "Sample period."]
    pub mod sampleper {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SAMPLEPER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SAMPLEPER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SAMPLEPERR {
            #[doc = "128us sample period."]
            _128US,
            #[doc = "256us sample period."]
            _256US,
            #[doc = "512us sample period."]
            _512US,
            #[doc = "1024us sample period."]
            _1024US,
            #[doc = "2048us sample period."]
            _2048US,
            #[doc = "4096us sample period."]
            _4096US,
            #[doc = "8192us sample period."]
            _8192US,
            #[doc = "16384us sample period."]
            _16384US,
        }
        impl SAMPLEPERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SAMPLEPERR::_128US => 0,
                    SAMPLEPERR::_256US => 0x01,
                    SAMPLEPERR::_512US => 0x02,
                    SAMPLEPERR::_1024US => 0x03,
                    SAMPLEPERR::_2048US => 0x04,
                    SAMPLEPERR::_4096US => 0x05,
                    SAMPLEPERR::_8192US => 0x06,
                    SAMPLEPERR::_16384US => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SAMPLEPERR {
                match value {
                    0 => SAMPLEPERR::_128US,
                    1 => SAMPLEPERR::_256US,
                    2 => SAMPLEPERR::_512US,
                    3 => SAMPLEPERR::_1024US,
                    4 => SAMPLEPERR::_2048US,
                    5 => SAMPLEPERR::_4096US,
                    6 => SAMPLEPERR::_8192US,
                    7 => SAMPLEPERR::_16384US,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_128US`"]
            #[inline]
            pub fn is_128us(&self) -> bool {
                *self == SAMPLEPERR::_128US
            }
            #[doc = "Checks if the value of the field is `_256US`"]
            #[inline]
            pub fn is_256us(&self) -> bool {
                *self == SAMPLEPERR::_256US
            }
            #[doc = "Checks if the value of the field is `_512US`"]
            #[inline]
            pub fn is_512us(&self) -> bool {
                *self == SAMPLEPERR::_512US
            }
            #[doc = "Checks if the value of the field is `_1024US`"]
            #[inline]
            pub fn is_1024us(&self) -> bool {
                *self == SAMPLEPERR::_1024US
            }
            #[doc = "Checks if the value of the field is `_2048US`"]
            #[inline]
            pub fn is_2048us(&self) -> bool {
                *self == SAMPLEPERR::_2048US
            }
            #[doc = "Checks if the value of the field is `_4096US`"]
            #[inline]
            pub fn is_4096us(&self) -> bool {
                *self == SAMPLEPERR::_4096US
            }
            #[doc = "Checks if the value of the field is `_8192US`"]
            #[inline]
            pub fn is_8192us(&self) -> bool {
                *self == SAMPLEPERR::_8192US
            }
            #[doc = "Checks if the value of the field is `_16384US`"]
            #[inline]
            pub fn is_16384us(&self) -> bool {
                *self == SAMPLEPERR::_16384US
            }
        }
        #[doc = "Values that can be written to the field `SAMPLEPER`"]
        pub enum SAMPLEPERW {
            #[doc = "128us sample period."]
            _128US,
            #[doc = "256us sample period."]
            _256US,
            #[doc = "512us sample period."]
            _512US,
            #[doc = "1024us sample period."]
            _1024US,
            #[doc = "2048us sample period."]
            _2048US,
            #[doc = "4096us sample period."]
            _4096US,
            #[doc = "8192us sample period."]
            _8192US,
            #[doc = "16384us sample period."]
            _16384US,
        }
        impl SAMPLEPERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SAMPLEPERW::_128US => 0,
                    SAMPLEPERW::_256US => 1,
                    SAMPLEPERW::_512US => 2,
                    SAMPLEPERW::_1024US => 3,
                    SAMPLEPERW::_2048US => 4,
                    SAMPLEPERW::_4096US => 5,
                    SAMPLEPERW::_8192US => 6,
                    SAMPLEPERW::_16384US => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SAMPLEPERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SAMPLEPERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SAMPLEPERW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "128us sample period."]
            #[inline]
            pub fn _128us(self) -> &'a mut W {
                self.variant(SAMPLEPERW::_128US)
            }
            #[doc = "256us sample period."]
            #[inline]
            pub fn _256us(self) -> &'a mut W {
                self.variant(SAMPLEPERW::_256US)
            }
            #[doc = "512us sample period."]
            #[inline]
            pub fn _512us(self) -> &'a mut W {
                self.variant(SAMPLEPERW::_512US)
            }
            #[doc = "1024us sample period."]
            #[inline]
            pub fn _1024us(self) -> &'a mut W {
                self.variant(SAMPLEPERW::_1024US)
            }
            #[doc = "2048us sample period."]
            #[inline]
            pub fn _2048us(self) -> &'a mut W {
                self.variant(SAMPLEPERW::_2048US)
            }
            #[doc = "4096us sample period."]
            #[inline]
            pub fn _4096us(self) -> &'a mut W {
                self.variant(SAMPLEPERW::_4096US)
            }
            #[doc = "8192us sample period."]
            #[inline]
            pub fn _8192us(self) -> &'a mut W {
                self.variant(SAMPLEPERW::_8192US)
            }
            #[doc = "16384us sample period."]
            #[inline]
            pub fn _16384us(self) -> &'a mut W {
                self.variant(SAMPLEPERW::_16384US)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Sample period."]
            #[inline]
            pub fn sampleper(&self) -> SAMPLEPERR {
                SAMPLEPERR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Sample period."]
            #[inline]
            pub fn sampleper(&mut self) -> _SAMPLEPERW {
                _SAMPLEPERW { w: self }
            }
        }
    }
    #[doc = "Motion sample value."]
    pub struct SAMPLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Motion sample value."]
    pub mod sample {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SAMPLE {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SAMPLER {
            bits: u32,
        }
        impl SAMPLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Last sample taken in compliment to 2."]
            #[inline]
            pub fn sample(&self) -> SAMPLER {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SAMPLER { bits }
            }
        }
    }
    #[doc = "Number of samples to generate an EVENT_REPORTRDY."]
    pub struct REPORTPER {
        register: VolatileCell<u32>,
    }
    #[doc = "Number of samples to generate an EVENT_REPORTRDY."]
    pub mod reportper {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::REPORTPER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `REPORTPER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REPORTPERR {
            #[doc = "10 samples per report."]
            _10SMPL,
            #[doc = "40 samples per report."]
            _40SMPL,
            #[doc = "80 samples per report."]
            _80SMPL,
            #[doc = "120 samples per report."]
            _120SMPL,
            #[doc = "160 samples per report."]
            _160SMPL,
            #[doc = "200 samples per report."]
            _200SMPL,
            #[doc = "240 samples per report."]
            _240SMPL,
            #[doc = "280 samples per report."]
            _280SMPL,
        }
        impl REPORTPERR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    REPORTPERR::_10SMPL => 0,
                    REPORTPERR::_40SMPL => 0x01,
                    REPORTPERR::_80SMPL => 0x02,
                    REPORTPERR::_120SMPL => 0x03,
                    REPORTPERR::_160SMPL => 0x04,
                    REPORTPERR::_200SMPL => 0x05,
                    REPORTPERR::_240SMPL => 0x06,
                    REPORTPERR::_280SMPL => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> REPORTPERR {
                match value {
                    0 => REPORTPERR::_10SMPL,
                    1 => REPORTPERR::_40SMPL,
                    2 => REPORTPERR::_80SMPL,
                    3 => REPORTPERR::_120SMPL,
                    4 => REPORTPERR::_160SMPL,
                    5 => REPORTPERR::_200SMPL,
                    6 => REPORTPERR::_240SMPL,
                    7 => REPORTPERR::_280SMPL,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_10SMPL`"]
            #[inline]
            pub fn is_10smpl(&self) -> bool {
                *self == REPORTPERR::_10SMPL
            }
            #[doc = "Checks if the value of the field is `_40SMPL`"]
            #[inline]
            pub fn is_40smpl(&self) -> bool {
                *self == REPORTPERR::_40SMPL
            }
            #[doc = "Checks if the value of the field is `_80SMPL`"]
            #[inline]
            pub fn is_80smpl(&self) -> bool {
                *self == REPORTPERR::_80SMPL
            }
            #[doc = "Checks if the value of the field is `_120SMPL`"]
            #[inline]
            pub fn is_120smpl(&self) -> bool {
                *self == REPORTPERR::_120SMPL
            }
            #[doc = "Checks if the value of the field is `_160SMPL`"]
            #[inline]
            pub fn is_160smpl(&self) -> bool {
                *self == REPORTPERR::_160SMPL
            }
            #[doc = "Checks if the value of the field is `_200SMPL`"]
            #[inline]
            pub fn is_200smpl(&self) -> bool {
                *self == REPORTPERR::_200SMPL
            }
            #[doc = "Checks if the value of the field is `_240SMPL`"]
            #[inline]
            pub fn is_240smpl(&self) -> bool {
                *self == REPORTPERR::_240SMPL
            }
            #[doc = "Checks if the value of the field is `_280SMPL`"]
            #[inline]
            pub fn is_280smpl(&self) -> bool {
                *self == REPORTPERR::_280SMPL
            }
        }
        #[doc = "Values that can be written to the field `REPORTPER`"]
        pub enum REPORTPERW {
            #[doc = "10 samples per report."]
            _10SMPL,
            #[doc = "40 samples per report."]
            _40SMPL,
            #[doc = "80 samples per report."]
            _80SMPL,
            #[doc = "120 samples per report."]
            _120SMPL,
            #[doc = "160 samples per report."]
            _160SMPL,
            #[doc = "200 samples per report."]
            _200SMPL,
            #[doc = "240 samples per report."]
            _240SMPL,
            #[doc = "280 samples per report."]
            _280SMPL,
        }
        impl REPORTPERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    REPORTPERW::_10SMPL => 0,
                    REPORTPERW::_40SMPL => 1,
                    REPORTPERW::_80SMPL => 2,
                    REPORTPERW::_120SMPL => 3,
                    REPORTPERW::_160SMPL => 4,
                    REPORTPERW::_200SMPL => 5,
                    REPORTPERW::_240SMPL => 6,
                    REPORTPERW::_280SMPL => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REPORTPERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REPORTPERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: REPORTPERW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "10 samples per report."]
            #[inline]
            pub fn _10smpl(self) -> &'a mut W {
                self.variant(REPORTPERW::_10SMPL)
            }
            #[doc = "40 samples per report."]
            #[inline]
            pub fn _40smpl(self) -> &'a mut W {
                self.variant(REPORTPERW::_40SMPL)
            }
            #[doc = "80 samples per report."]
            #[inline]
            pub fn _80smpl(self) -> &'a mut W {
                self.variant(REPORTPERW::_80SMPL)
            }
            #[doc = "120 samples per report."]
            #[inline]
            pub fn _120smpl(self) -> &'a mut W {
                self.variant(REPORTPERW::_120SMPL)
            }
            #[doc = "160 samples per report."]
            #[inline]
            pub fn _160smpl(self) -> &'a mut W {
                self.variant(REPORTPERW::_160SMPL)
            }
            #[doc = "200 samples per report."]
            #[inline]
            pub fn _200smpl(self) -> &'a mut W {
                self.variant(REPORTPERW::_200SMPL)
            }
            #[doc = "240 samples per report."]
            #[inline]
            pub fn _240smpl(self) -> &'a mut W {
                self.variant(REPORTPERW::_240SMPL)
            }
            #[doc = "280 samples per report."]
            #[inline]
            pub fn _280smpl(self) -> &'a mut W {
                self.variant(REPORTPERW::_280SMPL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Number of samples to generate an EVENT_REPORTRDY."]
            #[inline]
            pub fn reportper(&self) -> REPORTPERR {
                REPORTPERR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Number of samples to generate an EVENT_REPORTRDY."]
            #[inline]
            pub fn reportper(&mut self) -> _REPORTPERW {
                _REPORTPERW { w: self }
            }
        }
    }
    #[doc = "Accumulated valid transitions register."]
    pub struct ACC {
        register: VolatileCell<u32>,
    }
    #[doc = "Accumulated valid transitions register."]
    pub mod acc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ACC {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "Snapshot of ACC register. Value generated by the TASKS_READCLEACC task."]
    pub struct ACCREAD {
        register: VolatileCell<u32>,
    }
    #[doc = "Snapshot of ACC register. Value generated by the TASKS_READCLEACC task."]
    pub mod accread {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ACCREAD {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
    #[doc = "Pin select for LED output."]
    pub struct PSELLED {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for LED output."]
    pub mod pselled {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELLED {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for phase A input."]
    pub struct PSELA {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for phase A input."]
    pub mod psela {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pin select for phase B input."]
    pub struct PSELB {
        register: VolatileCell<u32>,
    }
    #[doc = "Pin select for phase B input."]
    pub mod pselb {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSELB {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xffff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Enable debouncer input filters."]
    pub struct DBFEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable debouncer input filters."]
    pub mod dbfen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DBFEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DBFEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DBFENR {
            #[doc = "Debounce input filters disabled."]
            DISABLED,
            #[doc = "Debounce input filters enabled."]
            ENABLED,
        }
        impl DBFENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DBFENR::DISABLED => false,
                    DBFENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DBFENR {
                match value {
                    false => DBFENR::DISABLED,
                    true => DBFENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DBFENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DBFENR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `DBFEN`"]
        pub enum DBFENW {
            #[doc = "Debounce input filters disabled."]
            DISABLED,
            #[doc = "Debounce input filters enabled."]
            ENABLED,
        }
        impl DBFENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DBFENW::DISABLED => false,
                    DBFENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DBFENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DBFENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DBFENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Debounce input filters disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DBFENW::DISABLED)
            }
            #[doc = "Debounce input filters enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DBFENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable debounce input filters."]
            #[inline]
            pub fn dbfen(&self) -> DBFENR {
                DBFENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable debounce input filters."]
            #[inline]
            pub fn dbfen(&mut self) -> _DBFENW {
                _DBFENW { w: self }
            }
        }
    }
    #[doc = "Time LED is switched ON before the sample."]
    pub struct LEDPRE {
        register: VolatileCell<u32>,
    }
    #[doc = "Time LED is switched ON before the sample."]
    pub mod ledpre {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LEDPRE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct LEDPRER {
            bits: u16,
        }
        impl LEDPRER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _LEDPREW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LEDPREW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x01ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:8 - Period in us the LED in switched on prior to sampling."]
            #[inline]
            pub fn ledpre(&self) -> LEDPRER {
                let bits = {
                    const MASK: u16 = 0x01ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                LEDPRER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x10 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:8 - Period in us the LED in switched on prior to sampling."]
            #[inline]
            pub fn ledpre(&mut self) -> _LEDPREW {
                _LEDPREW { w: self }
            }
        }
    }
    #[doc = "Accumulated double (error) transitions register."]
    pub struct ACCDBL {
        register: VolatileCell<u32>,
    }
    #[doc = "Accumulated double (error) transitions register."]
    pub mod accdbl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ACCDBL {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACCDBLR {
            bits: u8,
        }
        impl ACCDBLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Accumulated double (error) transitions."]
            #[inline]
            pub fn accdbl(&self) -> ACCDBLR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ACCDBLR { bits }
            }
        }
    }
    #[doc = "Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task."]
    pub struct ACCDBLREAD {
        register: VolatileCell<u32>,
    }
    #[doc = "Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task."]
    pub mod accdblread {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::ACCDBLREAD {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct ACCDBLREADR {
            bits: u8,
        }
        impl ACCDBLREADR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Snapshot of accumulated double (error) transitions."]
            #[inline]
            pub fn accdblread(&self) -> ACCDBLREADR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ACCDBLREADR { bits }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "Low power comparator."]
pub struct LPCOMP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for LPCOMP {}
impl LPCOMP {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const lpcomp::RegisterBlock {
        0x4001_3000 as *const _
    }
}
impl Deref for LPCOMP {
    type Target = lpcomp::RegisterBlock;
    fn deref(&self) -> &lpcomp::RegisterBlock {
        unsafe { &*LPCOMP::ptr() }
    }
}
#[doc = "Low power comparator."]
pub mod lpcomp {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Start the comparator."]
        pub tasks_start: TASKS_START,
        #[doc = "0x04 - Stop the comparator."]
        pub tasks_stop: TASKS_STOP,
        #[doc = "0x08 - Sample comparator value."]
        pub tasks_sample: TASKS_SAMPLE,
        _reserved0: [u8; 244usize],
        #[doc = "0x100 - LPCOMP is ready and output is valid."]
        pub events_ready: EVENTS_READY,
        #[doc = "0x104 - Input voltage crossed the threshold going down."]
        pub events_down: EVENTS_DOWN,
        #[doc = "0x108 - Input voltage crossed the threshold going up."]
        pub events_up: EVENTS_UP,
        #[doc = "0x10c - Input voltage crossed the threshold in any direction."]
        pub events_cross: EVENTS_CROSS,
        _reserved1: [u8; 240usize],
        #[doc = "0x200 - Shortcuts for the LPCOMP."]
        pub shorts: SHORTS,
        _reserved2: [u8; 256usize],
        #[doc = "0x304 - Interrupt enable set register."]
        pub intenset: INTENSET,
        #[doc = "0x308 - Interrupt enable clear register."]
        pub intenclr: INTENCLR,
        _reserved3: [u8; 244usize],
        #[doc = "0x400 - Result of last compare."]
        pub result: RESULT,
        _reserved4: [u8; 252usize],
        #[doc = "0x500 - Enable the LPCOMP."]
        pub enable: ENABLE,
        #[doc = "0x504 - Input pin select."]
        pub psel: PSEL,
        #[doc = "0x508 - Reference select."]
        pub refsel: REFSEL,
        #[doc = "0x50c - External reference select."]
        pub extrefsel: EXTREFSEL,
        _reserved5: [u8; 16usize],
        #[doc = "0x520 - Analog detect configuration."]
        pub anadetect: ANADETECT,
        _reserved6: [u8; 2776usize],
        #[doc = "0xffc - Peripheral power control."]
        pub power: POWER,
    }
    #[doc = "Start the comparator."]
    pub struct TASKS_START {
        register: VolatileCell<u32>,
    }
    #[doc = "Start the comparator."]
    pub mod tasks_start {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_START {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Stop the comparator."]
    pub struct TASKS_STOP {
        register: VolatileCell<u32>,
    }
    #[doc = "Stop the comparator."]
    pub mod tasks_stop {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_STOP {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Sample comparator value."]
    pub struct TASKS_SAMPLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Sample comparator value."]
    pub mod tasks_sample {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TASKS_SAMPLE {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "LPCOMP is ready and output is valid."]
    pub struct EVENTS_READY {
        register: VolatileCell<u32>,
    }
    #[doc = "LPCOMP is ready and output is valid."]
    pub mod events_ready {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_READY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Input voltage crossed the threshold going down."]
    pub struct EVENTS_DOWN {
        register: VolatileCell<u32>,
    }
    #[doc = "Input voltage crossed the threshold going down."]
    pub mod events_down {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_DOWN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Input voltage crossed the threshold going up."]
    pub struct EVENTS_UP {
        register: VolatileCell<u32>,
    }
    #[doc = "Input voltage crossed the threshold going up."]
    pub mod events_up {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_UP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Input voltage crossed the threshold in any direction."]
    pub struct EVENTS_CROSS {
        register: VolatileCell<u32>,
    }
    #[doc = "Input voltage crossed the threshold in any direction."]
    pub mod events_cross {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EVENTS_CROSS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Shortcuts for the LPCOMP."]
    pub struct SHORTS {
        register: VolatileCell<u32>,
    }
    #[doc = "Shortcuts for the LPCOMP."]
    pub mod shorts {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SHORTS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `READY_SAMPLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READY_SAMPLER {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl READY_SAMPLER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READY_SAMPLER::DISABLED => false,
                    READY_SAMPLER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READY_SAMPLER {
                match value {
                    false => READY_SAMPLER::DISABLED,
                    true => READY_SAMPLER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READY_SAMPLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READY_SAMPLER::ENABLED
            }
        }
        #[doc = "Possible values of the field `READY_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READY_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl READY_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READY_STOPR::DISABLED => false,
                    READY_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READY_STOPR {
                match value {
                    false => READY_STOPR::DISABLED,
                    true => READY_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READY_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READY_STOPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DOWN_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DOWN_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl DOWN_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DOWN_STOPR::DISABLED => false,
                    DOWN_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DOWN_STOPR {
                match value {
                    false => DOWN_STOPR::DISABLED,
                    true => DOWN_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DOWN_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DOWN_STOPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `UP_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UP_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl UP_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UP_STOPR::DISABLED => false,
                    UP_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UP_STOPR {
                match value {
                    false => UP_STOPR::DISABLED,
                    true => UP_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UP_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UP_STOPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `CROSS_STOP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CROSS_STOPR {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl CROSS_STOPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CROSS_STOPR::DISABLED => false,
                    CROSS_STOPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CROSS_STOPR {
                match value {
                    false => CROSS_STOPR::DISABLED,
                    true => CROSS_STOPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CROSS_STOPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CROSS_STOPR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `READY_SAMPLE`"]
        pub enum READY_SAMPLEW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl READY_SAMPLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READY_SAMPLEW::DISABLED => false,
                    READY_SAMPLEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READY_SAMPLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READY_SAMPLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READY_SAMPLEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(READY_SAMPLEW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(READY_SAMPLEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `READY_STOP`"]
        pub enum READY_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl READY_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READY_STOPW::DISABLED => false,
                    READY_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READY_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READY_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READY_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(READY_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(READY_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DOWN_STOP`"]
        pub enum DOWN_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl DOWN_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DOWN_STOPW::DISABLED => false,
                    DOWN_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DOWN_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DOWN_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DOWN_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DOWN_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DOWN_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UP_STOP`"]
        pub enum UP_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl UP_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UP_STOPW::DISABLED => false,
                    UP_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UP_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UP_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UP_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UP_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UP_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CROSS_STOP`"]
        pub enum CROSS_STOPW {
            #[doc = "Shortcut disabled."]
            DISABLED,
            #[doc = "Shortcut enabled."]
            ENABLED,
        }
        impl CROSS_STOPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CROSS_STOPW::DISABLED => false,
                    CROSS_STOPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CROSS_STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CROSS_STOPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CROSS_STOPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Shortcut disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CROSS_STOPW::DISABLED)
            }
            #[doc = "Shortcut enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CROSS_STOPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Shortcut between READY event and SAMPLE task."]
            #[inline]
            pub fn ready_sample(&self) -> READY_SAMPLER {
                READY_SAMPLER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Shortcut between RADY event and STOP task."]
            #[inline]
            pub fn ready_stop(&self) -> READY_STOPR {
                READY_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Shortcut between DOWN event and STOP task."]
            #[inline]
            pub fn down_stop(&self) -> DOWN_STOPR {
                DOWN_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Shortcut between UP event and STOP task."]
            #[inline]
            pub fn up_stop(&self) -> UP_STOPR {
                UP_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Shortcut between CROSS event and STOP task."]
            #[inline]
            pub fn cross_stop(&self) -> CROSS_STOPR {
                CROSS_STOPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Shortcut between READY event and SAMPLE task."]
            #[inline]
            pub fn ready_sample(&mut self) -> _READY_SAMPLEW {
                _READY_SAMPLEW { w: self }
            }
            #[doc = "Bit 1 - Shortcut between RADY event and STOP task."]
            #[inline]
            pub fn ready_stop(&mut self) -> _READY_STOPW {
                _READY_STOPW { w: self }
            }
            #[doc = "Bit 2 - Shortcut between DOWN event and STOP task."]
            #[inline]
            pub fn down_stop(&mut self) -> _DOWN_STOPW {
                _DOWN_STOPW { w: self }
            }
            #[doc = "Bit 3 - Shortcut between UP event and STOP task."]
            #[inline]
            pub fn up_stop(&mut self) -> _UP_STOPW {
                _UP_STOPW { w: self }
            }
            #[doc = "Bit 4 - Shortcut between CROSS event and STOP task."]
            #[inline]
            pub fn cross_stop(&mut self) -> _CROSS_STOPW {
                _CROSS_STOPW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable set register."]
    pub struct INTENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable set register."]
    pub mod intenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `READY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl READYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READYR::DISABLED => false,
                    READYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READYR {
                match value {
                    false => READYR::DISABLED,
                    true => READYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DOWN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DOWNR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DOWNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DOWNR::DISABLED => false,
                    DOWNR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DOWNR {
                match value {
                    false => DOWNR::DISABLED,
                    true => DOWNR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DOWNR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DOWNR::ENABLED
            }
        }
        #[doc = "Possible values of the field `UP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UPR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl UPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UPR::DISABLED => false,
                    UPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UPR {
                match value {
                    false => UPR::DISABLED,
                    true => UPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `CROSS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CROSSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl CROSSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CROSSR::DISABLED => false,
                    CROSSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CROSSR {
                match value {
                    false => CROSSR::DISABLED,
                    true => CROSSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CROSSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CROSSR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `READY`"]
        pub enum READYW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl READYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READYW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(READYW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DOWN`"]
        pub enum DOWNW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl DOWNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DOWNW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DOWNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DOWNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DOWNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(DOWNW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UP`"]
        pub enum UPW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl UPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UPW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(UPW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CROSS`"]
        pub enum CROSSW {
            #[doc = "Enable interrupt on write."]
            SET,
        }
        impl CROSSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CROSSW::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CROSSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CROSSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CROSSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable interrupt on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CROSSW::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable interrupt on READY event."]
            #[inline]
            pub fn ready(&self) -> READYR {
                READYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable interrupt on DOWN event."]
            #[inline]
            pub fn down(&self) -> DOWNR {
                DOWNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable interrupt on UP event."]
            #[inline]
            pub fn up(&self) -> UPR {
                UPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable interrupt on CROSS event."]
            #[inline]
            pub fn cross(&self) -> CROSSR {
                CROSSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable interrupt on READY event."]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Enable interrupt on DOWN event."]
            #[inline]
            pub fn down(&mut self) -> _DOWNW {
                _DOWNW { w: self }
            }
            #[doc = "Bit 2 - Enable interrupt on UP event."]
            #[inline]
            pub fn up(&mut self) -> _UPW {
                _UPW { w: self }
            }
            #[doc = "Bit 3 - Enable interrupt on CROSS event."]
            #[inline]
            pub fn cross(&mut self) -> _CROSSW {
                _CROSSW { w: self }
            }
        }
    }
    #[doc = "Interrupt enable clear register."]
    pub struct INTENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Interrupt enable clear register."]
    pub mod intenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `READY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READYR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl READYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READYR::DISABLED => false,
                    READYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READYR {
                match value {
                    false => READYR::DISABLED,
                    true => READYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == READYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == READYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `DOWN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DOWNR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl DOWNR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DOWNR::DISABLED => false,
                    DOWNR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DOWNR {
                match value {
                    false => DOWNR::DISABLED,
                    true => DOWNR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == DOWNR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == DOWNR::ENABLED
            }
        }
        #[doc = "Possible values of the field `UP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UPR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl UPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UPR::DISABLED => false,
                    UPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UPR {
                match value {
                    false => UPR::DISABLED,
                    true => UPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `CROSS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CROSSR {
            #[doc = "Interrupt disabled."]
            DISABLED,
            #[doc = "Interrupt enabled."]
            ENABLED,
        }
        impl CROSSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CROSSR::DISABLED => false,
                    CROSSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CROSSR {
                match value {
                    false => CROSSR::DISABLED,
                    true => CROSSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CROSSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CROSSR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `READY`"]
        pub enum READYW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl READYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    READYW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _READYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _READYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: READYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(READYW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DOWN`"]
        pub enum DOWNW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl DOWNW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DOWNW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DOWNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DOWNW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DOWNW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(DOWNW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UP`"]
        pub enum UPW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl UPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UPW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(UPW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CROSS`"]
        pub enum CROSSW {
            #[doc = "Disable interrupt on write."]
            CLEAR,
        }
        impl CROSSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CROSSW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CROSSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CROSSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CROSSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable interrupt on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CROSSW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable interrupt on READY event."]
            #[inline]
            pub fn ready(&self) -> READYR {
                READYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable interrupt on DOWN event."]
            #[inline]
            pub fn down(&self) -> DOWNR {
                DOWNR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable interrupt on UP event."]
            #[inline]
            pub fn up(&self) -> UPR {
                UPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Disable interrupt on CROSS event."]
            #[inline]
            pub fn cross(&self) -> CROSSR {
                CROSSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable interrupt on READY event."]
            #[inline]
            pub fn ready(&mut self) -> _READYW {
                _READYW { w: self }
            }
            #[doc = "Bit 1 - Disable interrupt on DOWN event."]
            #[inline]
            pub fn down(&mut self) -> _DOWNW {
                _DOWNW { w: self }
            }
            #[doc = "Bit 2 - Disable interrupt on UP event."]
            #[inline]
            pub fn up(&mut self) -> _UPW {
                _UPW { w: self }
            }
            #[doc = "Bit 3 - Disable interrupt on CROSS event."]
            #[inline]
            pub fn cross(&mut self) -> _CROSSW {
                _CROSSW { w: self }
            }
        }
    }
    #[doc = "Result of last compare."]
    pub struct RESULT {
        register: VolatileCell<u32>,
    }
    #[doc = "Result of last compare."]
    pub mod result {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RESULT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `RESULT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESULTR {
            #[doc = "Input voltage is bellow the reference threshold."]
            BELLOW,
            #[doc = "Input voltage is above the reference threshold."]
            ABOVE,
        }
        impl RESULTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RESULTR::BELLOW => false,
                    RESULTR::ABOVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RESULTR {
                match value {
                    false => RESULTR::BELLOW,
                    true => RESULTR::ABOVE,
                }
            }
            #[doc = "Checks if the value of the field is `BELLOW`"]
            #[inline]
            pub fn is_bellow(&self) -> bool {
                *self == RESULTR::BELLOW
            }
            #[doc = "Checks if the value of the field is `ABOVE`"]
            #[inline]
            pub fn is_above(&self) -> bool {
                *self == RESULTR::ABOVE
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Result of last compare. Decision point SAMPLE task."]
            #[inline]
            pub fn result(&self) -> RESULTR {
                RESULTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Enable the LPCOMP."]
    pub struct ENABLE {
        register: VolatileCell<u32>,
    }
    #[doc = "Enable the LPCOMP."]
    pub mod enable {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ENABLE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENABLE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENABLER {
            #[doc = "Disabled LPCOMP."]
            DISABLED,
            #[doc = "Enable LPCOMP."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ENABLER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ENABLER::DISABLED => 0,
                    ENABLER::ENABLED => 0x01,
                    ENABLER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ENABLER {
                match value {
                    0 => ENABLER::DISABLED,
                    1 => ENABLER::ENABLED,
                    i => ENABLER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ENABLER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ENABLER::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `ENABLE`"]
        pub enum ENABLEW {
            #[doc = "Disabled LPCOMP."]
            DISABLED,
            #[doc = "Enable LPCOMP."]
            ENABLED,
        }
        impl ENABLEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ENABLEW::DISABLED => 0,
                    ENABLEW::ENABLED => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENABLEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENABLEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENABLEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled LPCOMP."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENABLEW::DISABLED)
            }
            #[doc = "Enable LPCOMP."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENABLEW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Enable or disable LPCOMP."]
            #[inline]
            pub fn enable(&self) -> ENABLER {
                ENABLER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Enable or disable LPCOMP."]
            #[inline]
            pub fn enable(&mut self) -> _ENABLEW {
                _ENABLEW { w: self }
            }
        }
    }
    #[doc = "Input pin select."]
    pub struct PSEL {
        register: VolatileCell<u32>,
    }
    #[doc = "Input pin select."]
    pub mod psel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSELR {
            #[doc = "Use analog input 0 as analog input."]
            ANALOGINPUT0,
            #[doc = "Use analog input 1 as analog input."]
            ANALOGINPUT1,
            #[doc = "Use analog input 2 as analog input."]
            ANALOGINPUT2,
            #[doc = "Use analog input 3 as analog input."]
            ANALOGINPUT3,
            #[doc = "Use analog input 4 as analog input."]
            ANALOGINPUT4,
            #[doc = "Use analog input 5 as analog input."]
            ANALOGINPUT5,
            #[doc = "Use analog input 6 as analog input."]
            ANALOGINPUT6,
            #[doc = "Use analog input 7 as analog input."]
            ANALOGINPUT7,
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSELR::ANALOGINPUT0 => 0,
                    PSELR::ANALOGINPUT1 => 0x01,
                    PSELR::ANALOGINPUT2 => 0x02,
                    PSELR::ANALOGINPUT3 => 0x03,
                    PSELR::ANALOGINPUT4 => 0x04,
                    PSELR::ANALOGINPUT5 => 0x05,
                    PSELR::ANALOGINPUT6 => 0x06,
                    PSELR::ANALOGINPUT7 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PSELR {
                match value {
                    0 => PSELR::ANALOGINPUT0,
                    1 => PSELR::ANALOGINPUT1,
                    2 => PSELR::ANALOGINPUT2,
                    3 => PSELR::ANALOGINPUT3,
                    4 => PSELR::ANALOGINPUT4,
                    5 => PSELR::ANALOGINPUT5,
                    6 => PSELR::ANALOGINPUT6,
                    7 => PSELR::ANALOGINPUT7,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT0`"]
            #[inline]
            pub fn is_analog_input0(&self) -> bool {
                *self == PSELR::ANALOGINPUT0
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT1`"]
            #[inline]
            pub fn is_analog_input1(&self) -> bool {
                *self == PSELR::ANALOGINPUT1
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT2`"]
            #[inline]
            pub fn is_analog_input2(&self) -> bool {
                *self == PSELR::ANALOGINPUT2
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT3`"]
            #[inline]
            pub fn is_analog_input3(&self) -> bool {
                *self == PSELR::ANALOGINPUT3
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT4`"]
            #[inline]
            pub fn is_analog_input4(&self) -> bool {
                *self == PSELR::ANALOGINPUT4
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT5`"]
            #[inline]
            pub fn is_analog_input5(&self) -> bool {
                *self == PSELR::ANALOGINPUT5
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT6`"]
            #[inline]
            pub fn is_analog_input6(&self) -> bool {
                *self == PSELR::ANALOGINPUT6
            }
            #[doc = "Checks if the value of the field is `ANALOGINPUT7`"]
            #[inline]
            pub fn is_analog_input7(&self) -> bool {
                *self == PSELR::ANALOGINPUT7
            }
        }
        #[doc = "Values that can be written to the field `PSEL`"]
        pub enum PSELW {
            #[doc = "Use analog input 0 as analog input."]
            ANALOGINPUT0,
            #[doc = "Use analog input 1 as analog input."]
            ANALOGINPUT1,
            #[doc = "Use analog input 2 as analog input."]
            ANALOGINPUT2,
            #[doc = "Use analog input 3 as analog input."]
            ANALOGINPUT3,
            #[doc = "Use analog input 4 as analog input."]
            ANALOGINPUT4,
            #[doc = "Use analog input 5 as analog input."]
            ANALOGINPUT5,
            #[doc = "Use analog input 6 as analog input."]
            ANALOGINPUT6,
            #[doc = "Use analog input 7 as analog input."]
            ANALOGINPUT7,
        }
        impl PSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PSELW::ANALOGINPUT0 => 0,
                    PSELW::ANALOGINPUT1 => 1,
                    PSELW::ANALOGINPUT2 => 2,
                    PSELW::ANALOGINPUT3 => 3,
                    PSELW::ANALOGINPUT4 => 4,
                    PSELW::ANALOGINPUT5 => 5,
                    PSELW::ANALOGINPUT6 => 6,
                    PSELW::ANALOGINPUT7 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Use analog input 0 as analog input."]
            #[inline]
            pub fn analog_input0(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT0)
            }
            #[doc = "Use analog input 1 as analog input."]
            #[inline]
            pub fn analog_input1(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT1)
            }
            #[doc = "Use analog input 2 as analog input."]
            #[inline]
            pub fn analog_input2(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT2)
            }
            #[doc = "Use analog input 3 as analog input."]
            #[inline]
            pub fn analog_input3(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT3)
            }
            #[doc = "Use analog input 4 as analog input."]
            #[inline]
            pub fn analog_input4(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT4)
            }
            #[doc = "Use analog input 5 as analog input."]
            #[inline]
            pub fn analog_input5(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT5)
            }
            #[doc = "Use analog input 6 as analog input."]
            #[inline]
            pub fn analog_input6(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT6)
            }
            #[doc = "Use analog input 7 as analog input."]
            #[inline]
            pub fn analog_input7(self) -> &'a mut W {
                self.variant(PSELW::ANALOGINPUT7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Analog input pin select."]
            #[inline]
            pub fn psel(&self) -> PSELR {
                PSELR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Analog input pin select."]
            #[inline]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
        }
    }
    #[doc = "Reference select."]
    pub struct REFSEL {
        register: VolatileCell<u32>,
    }
    #[doc = "Reference select."]
    pub mod refsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::REFSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `REFSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum REFSELR {
            #[doc = "Use supply with a 1/8 prescaler as reference."]
            SUPPLYONEEIGHTHPRESCALING,
            #[doc = "Use supply with a 2/8 prescaler as reference."]
            SUPPLYTWOEIGHTHSPRESCALING,
            #[doc = "Use supply with a 3/8 prescaler as reference."]
            SUPPLYTHREEEIGHTHSPRESCALING,
            #[doc = "Use supply with a 4/8 prescaler as reference."]
            SUPPLYFOUREIGHTHSPRESCALING,
            #[doc = "Use supply with a 5/8 prescaler as reference."]
            SUPPLYFIVEEIGHTHSPRESCALING,
            #[doc = "Use supply with a 6/8 prescaler as reference."]
            SUPPLYSIXEIGHTHSPRESCALING,
            #[doc = "Use supply with a 7/8 prescaler as reference."]
            SUPPLYSEVENEIGHTHSPRESCALING,
            #[doc = "Use external analog reference as reference."]
            AREF,
        }
        impl REFSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    REFSELR::SUPPLYONEEIGHTHPRESCALING => 0,
                    REFSELR::SUPPLYTWOEIGHTHSPRESCALING => 0x01,
                    REFSELR::SUPPLYTHREEEIGHTHSPRESCALING => 0x02,
                    REFSELR::SUPPLYFOUREIGHTHSPRESCALING => 0x03,
                    REFSELR::SUPPLYFIVEEIGHTHSPRESCALING => 0x04,
                    REFSELR::SUPPLYSIXEIGHTHSPRESCALING => 0x05,
                    REFSELR::SUPPLYSEVENEIGHTHSPRESCALING => 0x06,
                    REFSELR::AREF => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> REFSELR {
                match value {
                    0 => REFSELR::SUPPLYONEEIGHTHPRESCALING,
                    1 => REFSELR::SUPPLYTWOEIGHTHSPRESCALING,
                    2 => REFSELR::SUPPLYTHREEEIGHTHSPRESCALING,
                    3 => REFSELR::SUPPLYFOUREIGHTHSPRESCALING,
                    4 => REFSELR::SUPPLYFIVEEIGHTHSPRESCALING,
                    5 => REFSELR::SUPPLYSIXEIGHTHSPRESCALING,
                    6 => REFSELR::SUPPLYSEVENEIGHTHSPRESCALING,
                    7 => REFSELR::AREF,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SUPPLYONEEIGHTHPRESCALING`"]
            #[inline]
            pub fn is_supply_one_eighth_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYONEEIGHTHPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYTWOEIGHTHSPRESCALING`"]
            #[inline]
            pub fn is_supply_two_eighths_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYTWOEIGHTHSPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYTHREEEIGHTHSPRESCALING`"]
            #[inline]
            pub fn is_supply_three_eighths_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYTHREEEIGHTHSPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYFOUREIGHTHSPRESCALING`"]
            #[inline]
            pub fn is_supply_four_eighths_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYFOUREIGHTHSPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYFIVEEIGHTHSPRESCALING`"]
            #[inline]
            pub fn is_supply_five_eighths_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYFIVEEIGHTHSPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYSIXEIGHTHSPRESCALING`"]
            #[inline]
            pub fn is_supply_six_eighths_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYSIXEIGHTHSPRESCALING
            }
            #[doc = "Checks if the value of the field is `SUPPLYSEVENEIGHTHSPRESCALING`"]
            #[inline]
            pub fn is_supply_seven_eighths_prescaling(&self) -> bool {
                *self == REFSELR::SUPPLYSEVENEIGHTHSPRESCALING
            }
            #[doc = "Checks if the value of the field is `AREF`"]
            #[inline]
            pub fn is_aref(&self) -> bool {
                *self == REFSELR::AREF
            }
        }
        #[doc = "Values that can be written to the field `REFSEL`"]
        pub enum REFSELW {
            #[doc = "Use supply with a 1/8 prescaler as reference."]
            SUPPLYONEEIGHTHPRESCALING,
            #[doc = "Use supply with a 2/8 prescaler as reference."]
            SUPPLYTWOEIGHTHSPRESCALING,
            #[doc = "Use supply with a 3/8 prescaler as reference."]
            SUPPLYTHREEEIGHTHSPRESCALING,
            #[doc = "Use supply with a 4/8 prescaler as reference."]
            SUPPLYFOUREIGHTHSPRESCALING,
            #[doc = "Use supply with a 5/8 prescaler as reference."]
            SUPPLYFIVEEIGHTHSPRESCALING,
            #[doc = "Use supply with a 6/8 prescaler as reference."]
            SUPPLYSIXEIGHTHSPRESCALING,
            #[doc = "Use supply with a 7/8 prescaler as reference."]
            SUPPLYSEVENEIGHTHSPRESCALING,
            #[doc = "Use external analog reference as reference."]
            AREF,
        }
        impl REFSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    REFSELW::SUPPLYONEEIGHTHPRESCALING => 0,
                    REFSELW::SUPPLYTWOEIGHTHSPRESCALING => 1,
                    REFSELW::SUPPLYTHREEEIGHTHSPRESCALING => 2,
                    REFSELW::SUPPLYFOUREIGHTHSPRESCALING => 3,
                    REFSELW::SUPPLYFIVEEIGHTHSPRESCALING => 4,
                    REFSELW::SUPPLYSIXEIGHTHSPRESCALING => 5,
                    REFSELW::SUPPLYSEVENEIGHTHSPRESCALING => 6,
                    REFSELW::AREF => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _REFSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _REFSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: REFSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Use supply with a 1/8 prescaler as reference."]
            #[inline]
            pub fn supply_one_eighth_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYONEEIGHTHPRESCALING)
            }
            #[doc = "Use supply with a 2/8 prescaler as reference."]
            #[inline]
            pub fn supply_two_eighths_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYTWOEIGHTHSPRESCALING)
            }
            #[doc = "Use supply with a 3/8 prescaler as reference."]
            #[inline]
            pub fn supply_three_eighths_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYTHREEEIGHTHSPRESCALING)
            }
            #[doc = "Use supply with a 4/8 prescaler as reference."]
            #[inline]
            pub fn supply_four_eighths_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYFOUREIGHTHSPRESCALING)
            }
            #[doc = "Use supply with a 5/8 prescaler as reference."]
            #[inline]
            pub fn supply_five_eighths_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYFIVEEIGHTHSPRESCALING)
            }
            #[doc = "Use supply with a 6/8 prescaler as reference."]
            #[inline]
            pub fn supply_six_eighths_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYSIXEIGHTHSPRESCALING)
            }
            #[doc = "Use supply with a 7/8 prescaler as reference."]
            #[inline]
            pub fn supply_seven_eighths_prescaling(self) -> &'a mut W {
                self.variant(REFSELW::SUPPLYSEVENEIGHTHSPRESCALING)
            }
            #[doc = "Use external analog reference as reference."]
            #[inline]
            pub fn aref(self) -> &'a mut W {
                self.variant(REFSELW::AREF)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Reference select."]
            #[inline]
            pub fn refsel(&self) -> REFSELR {
                REFSELR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Reference select."]
            #[inline]
            pub fn refsel(&mut self) -> _REFSELW {
                _REFSELW { w: self }
            }
        }
    }
    #[doc = "External reference select."]
    pub struct EXTREFSEL {
        register: VolatileCell<u32>,
    }
    #[doc = "External reference select."]
    pub mod extrefsel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::EXTREFSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `EXTREFSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTREFSELR {
            #[doc = "Use analog reference 0 as reference."]
            ANALOGREFERENCE0,
            #[doc = "Use analog reference 1 as reference."]
            ANALOGREFERENCE1,
        }
        impl EXTREFSELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EXTREFSELR::ANALOGREFERENCE0 => false,
                    EXTREFSELR::ANALOGREFERENCE1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EXTREFSELR {
                match value {
                    false => EXTREFSELR::ANALOGREFERENCE0,
                    true => EXTREFSELR::ANALOGREFERENCE1,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOGREFERENCE0`"]
            #[inline]
            pub fn is_analog_reference0(&self) -> bool {
                *self == EXTREFSELR::ANALOGREFERENCE0
            }
            #[doc = "Checks if the value of the field is `ANALOGREFERENCE1`"]
            #[inline]
            pub fn is_analog_reference1(&self) -> bool {
                *self == EXTREFSELR::ANALOGREFERENCE1
            }
        }
        #[doc = "Values that can be written to the field `EXTREFSEL`"]
        pub enum EXTREFSELW {
            #[doc = "Use analog reference 0 as reference."]
            ANALOGREFERENCE0,
            #[doc = "Use analog reference 1 as reference."]
            ANALOGREFERENCE1,
        }
        impl EXTREFSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EXTREFSELW::ANALOGREFERENCE0 => false,
                    EXTREFSELW::ANALOGREFERENCE1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EXTREFSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EXTREFSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EXTREFSELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Use analog reference 0 as reference."]
            #[inline]
            pub fn analog_reference0(self) -> &'a mut W {
                self.variant(EXTREFSELW::ANALOGREFERENCE0)
            }
            #[doc = "Use analog reference 1 as reference."]
            #[inline]
            pub fn analog_reference1(self) -> &'a mut W {
                self.variant(EXTREFSELW::ANALOGREFERENCE1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External analog reference pin selection."]
            #[inline]
            pub fn extrefsel(&self) -> EXTREFSELR {
                EXTREFSELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External analog reference pin selection."]
            #[inline]
            pub fn extrefsel(&mut self) -> _EXTREFSELW {
                _EXTREFSELW { w: self }
            }
        }
    }
    #[doc = "Analog detect configuration."]
    pub struct ANADETECT {
        register: VolatileCell<u32>,
    }
    #[doc = "Analog detect configuration."]
    pub mod anadetect {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ANADETECT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ANADETECT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ANADETECTR {
            #[doc = "Generate ANADETEC on crossing, both upwards and downwards crossing."]
            CROSS,
            #[doc = "Generate ANADETEC on upwards crossing only."]
            UP,
            #[doc = "Generate ANADETEC on downwards crossing only."]
            DOWN,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl ANADETECTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    ANADETECTR::CROSS => 0,
                    ANADETECTR::UP => 0x01,
                    ANADETECTR::DOWN => 0x02,
                    ANADETECTR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> ANADETECTR {
                match value {
                    0 => ANADETECTR::CROSS,
                    1 => ANADETECTR::UP,
                    2 => ANADETECTR::DOWN,
                    i => ANADETECTR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `CROSS`"]
            #[inline]
            pub fn is_cross(&self) -> bool {
                *self == ANADETECTR::CROSS
            }
            #[doc = "Checks if the value of the field is `UP`"]
            #[inline]
            pub fn is_up(&self) -> bool {
                *self == ANADETECTR::UP
            }
            #[doc = "Checks if the value of the field is `DOWN`"]
            #[inline]
            pub fn is_down(&self) -> bool {
                *self == ANADETECTR::DOWN
            }
        }
        #[doc = "Values that can be written to the field `ANADETECT`"]
        pub enum ANADETECTW {
            #[doc = "Generate ANADETEC on crossing, both upwards and downwards crossing."]
            CROSS,
            #[doc = "Generate ANADETEC on upwards crossing only."]
            UP,
            #[doc = "Generate ANADETEC on downwards crossing only."]
            DOWN,
        }
        impl ANADETECTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    ANADETECTW::CROSS => 0,
                    ANADETECTW::UP => 1,
                    ANADETECTW::DOWN => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ANADETECTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ANADETECTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ANADETECTW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Generate ANADETEC on crossing, both upwards and downwards crossing."]
            #[inline]
            pub fn cross(self) -> &'a mut W {
                self.variant(ANADETECTW::CROSS)
            }
            #[doc = "Generate ANADETEC on upwards crossing only."]
            #[inline]
            pub fn up(self) -> &'a mut W {
                self.variant(ANADETECTW::UP)
            }
            #[doc = "Generate ANADETEC on downwards crossing only."]
            #[inline]
            pub fn down(self) -> &'a mut W {
                self.variant(ANADETECTW::DOWN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Analog detect configuration."]
            #[inline]
            pub fn anadetect(&self) -> ANADETECTR {
                ANADETECTR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Analog detect configuration."]
            #[inline]
            pub fn anadetect(&mut self) -> _ANADETECTW {
                _ANADETECTW { w: self }
            }
        }
    }
    #[doc = "Peripheral power control."]
    pub struct POWER {
        register: VolatileCell<u32>,
    }
    #[doc = "Peripheral power control."]
    pub mod power {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::POWER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `POWER`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POWERR {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    POWERR::DISABLED => false,
                    POWERR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> POWERR {
                match value {
                    false => POWERR::DISABLED,
                    true => POWERR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == POWERR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == POWERR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `POWER`"]
        pub enum POWERW {
            #[doc = "Module power disabled."]
            DISABLED,
            #[doc = "Module power enabled."]
            ENABLED,
        }
        impl POWERW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    POWERW::DISABLED => false,
                    POWERW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _POWERW<'a> {
            w: &'a mut W,
        }
        impl<'a> _POWERW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: POWERW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Module power disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(POWERW::DISABLED)
            }
            #[doc = "Module power enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(POWERW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&self) -> POWERR {
                POWERR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Peripheral power control."]
            #[inline]
            pub fn power(&mut self) -> _POWERW {
                _POWERW { w: self }
            }
        }
    }
}
#[doc = "SW Interrupts."]
pub struct SWI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SWI {}
impl SWI {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const swi::RegisterBlock {
        0x4001_4000 as *const _
    }
}
impl Deref for SWI {
    type Target = swi::RegisterBlock;
    fn deref(&self) -> &swi::RegisterBlock {
        unsafe { &*SWI::ptr() }
    }
}
#[doc = "SW Interrupts."]
pub mod swi {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Unused."]
        pub unused: UNUSED,
    }
    #[doc = "Unused."]
    pub struct UNUSED {
        register: VolatileCell<u32>,
    }
    #[doc = "Unused."]
    pub mod unused {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::UNUSED {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
    }
}
#[doc = "Non Volatile Memory Controller."]
pub struct NVMC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for NVMC {}
impl NVMC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const nvmc::RegisterBlock {
        0x4001_e000 as *const _
    }
}
impl Deref for NVMC {
    type Target = nvmc::RegisterBlock;
    fn deref(&self) -> &nvmc::RegisterBlock {
        unsafe { &*NVMC::ptr() }
    }
}
#[doc = "Non Volatile Memory Controller."]
pub mod nvmc {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 1024usize],
        #[doc = "0x400 - Ready flag."]
        pub ready: READY,
        _reserved1: [u8; 256usize],
        #[doc = "0x504 - Configuration register."]
        pub config: CONFIG,
        #[doc = "0x508 - Register for erasing a non-protected non-volatile memory page."]
        pub erasepage: ERASEPAGE,
        #[doc = "0x50c - Register for erasing all non-volatile user memory."]
        pub eraseall: ERASEALL,
        #[doc = "0x510 - Register for erasing a protected non-volatile memory page."]
        pub erasepcr0: ERASEPCR0,
        #[doc = "0x514 - Register for start erasing User Information Congfiguration Registers."]
        pub eraseuicr: ERASEUICR,
    }
    #[doc = "Ready flag."]
    pub struct READY {
        register: VolatileCell<u32>,
    }
    #[doc = "Ready flag."]
    pub mod ready {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::READY {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `READY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum READYR {
            #[doc = "NVMC is busy (on-going write or erase operation)."]
            BUSY,
            #[doc = "NVMC is ready."]
            READY,
        }
        impl READYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    READYR::BUSY => false,
                    READYR::READY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> READYR {
                match value {
                    false => READYR::BUSY,
                    true => READYR::READY,
                }
            }
            #[doc = "Checks if the value of the field is `BUSY`"]
            #[inline]
            pub fn is_busy(&self) -> bool {
                *self == READYR::BUSY
            }
            #[doc = "Checks if the value of the field is `READY`"]
            #[inline]
            pub fn is_ready(&self) -> bool {
                *self == READYR::READY
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - NVMC ready."]
            #[inline]
            pub fn ready(&self) -> READYR {
                READYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Configuration register."]
    pub struct CONFIG {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration register."]
    pub mod config {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WENR {
            #[doc = "Read only access."]
            REN,
            #[doc = "Write enabled."]
            WEN,
            #[doc = "Erase enabled."]
            EEN,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl WENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WENR::REN => 0,
                    WENR::WEN => 0x01,
                    WENR::EEN => 0x02,
                    WENR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WENR {
                match value {
                    0 => WENR::REN,
                    1 => WENR::WEN,
                    2 => WENR::EEN,
                    i => WENR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `REN`"]
            #[inline]
            pub fn is_ren(&self) -> bool {
                *self == WENR::REN
            }
            #[doc = "Checks if the value of the field is `WEN`"]
            #[inline]
            pub fn is_wen(&self) -> bool {
                *self == WENR::WEN
            }
            #[doc = "Checks if the value of the field is `EEN`"]
            #[inline]
            pub fn is_een(&self) -> bool {
                *self == WENR::EEN
            }
        }
        #[doc = "Values that can be written to the field `WEN`"]
        pub enum WENW {
            #[doc = "Read only access."]
            REN,
            #[doc = "Write enabled."]
            WEN,
            #[doc = "Erase enabled."]
            EEN,
        }
        impl WENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WENW::REN => 0,
                    WENW::WEN => 1,
                    WENW::EEN => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WENW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Read only access."]
            #[inline]
            pub fn ren(self) -> &'a mut W {
                self.variant(WENW::REN)
            }
            #[doc = "Write enabled."]
            #[inline]
            pub fn wen(self) -> &'a mut W {
                self.variant(WENW::WEN)
            }
            #[doc = "Erase enabled."]
            #[inline]
            pub fn een(self) -> &'a mut W {
                self.variant(WENW::EEN)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Program write enable."]
            #[inline]
            pub fn wen(&self) -> WENR {
                WENR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Program write enable."]
            #[inline]
            pub fn wen(&mut self) -> _WENW {
                _WENW { w: self }
            }
        }
    }
    #[doc = "Register for erasing a non-protected non-volatile memory page."]
    pub struct ERASEPAGE {
        register: VolatileCell<u32>,
    }
    #[doc = "Register for erasing a non-protected non-volatile memory page."]
    pub mod erasepage {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ERASEPAGE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Register for erasing a non-protected non-volatile memory page."]
    pub struct ERASEPCR1 {
        register: VolatileCell<u32>,
    }
    #[doc = "Register for erasing a non-protected non-volatile memory page."]
    pub mod erasepcr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ERASEPCR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Register for erasing all non-volatile user memory."]
    pub struct ERASEALL {
        register: VolatileCell<u32>,
    }
    #[doc = "Register for erasing all non-volatile user memory."]
    pub mod eraseall {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ERASEALL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ERASEALL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERASEALLR {
            #[doc = "No operation."]
            NOOPERATION,
            #[doc = "Start chip erase."]
            ERASE,
        }
        impl ERASEALLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERASEALLR::NOOPERATION => false,
                    ERASEALLR::ERASE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERASEALLR {
                match value {
                    false => ERASEALLR::NOOPERATION,
                    true => ERASEALLR::ERASE,
                }
            }
            #[doc = "Checks if the value of the field is `NOOPERATION`"]
            #[inline]
            pub fn is_no_operation(&self) -> bool {
                *self == ERASEALLR::NOOPERATION
            }
            #[doc = "Checks if the value of the field is `ERASE`"]
            #[inline]
            pub fn is_erase(&self) -> bool {
                *self == ERASEALLR::ERASE
            }
        }
        #[doc = "Values that can be written to the field `ERASEALL`"]
        pub enum ERASEALLW {
            #[doc = "No operation."]
            NOOPERATION,
            #[doc = "Start chip erase."]
            ERASE,
        }
        impl ERASEALLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERASEALLW::NOOPERATION => false,
                    ERASEALLW::ERASE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERASEALLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERASEALLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERASEALLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No operation."]
            #[inline]
            pub fn no_operation(self) -> &'a mut W {
                self.variant(ERASEALLW::NOOPERATION)
            }
            #[doc = "Start chip erase."]
            #[inline]
            pub fn erase(self) -> &'a mut W {
                self.variant(ERASEALLW::ERASE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Starts the erasing of all user NVM (code region 0/1 and UICR registers)."]
            #[inline]
            pub fn eraseall(&self) -> ERASEALLR {
                ERASEALLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Starts the erasing of all user NVM (code region 0/1 and UICR registers)."]
            #[inline]
            pub fn eraseall(&mut self) -> _ERASEALLW {
                _ERASEALLW { w: self }
            }
        }
    }
    #[doc = "Register for erasing a protected non-volatile memory page."]
    pub struct ERASEPCR0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Register for erasing a protected non-volatile memory page."]
    pub mod erasepcr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ERASEPCR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Register for start erasing User Information Congfiguration Registers."]
    pub struct ERASEUICR {
        register: VolatileCell<u32>,
    }
    #[doc = "Register for start erasing User Information Congfiguration Registers."]
    pub mod eraseuicr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ERASEUICR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ERASEUICR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERASEUICRR {
            #[doc = "No operation."]
            NOOPERATION,
            #[doc = "Start UICR erase."]
            ERASE,
        }
        impl ERASEUICRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ERASEUICRR::NOOPERATION => false,
                    ERASEUICRR::ERASE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ERASEUICRR {
                match value {
                    false => ERASEUICRR::NOOPERATION,
                    true => ERASEUICRR::ERASE,
                }
            }
            #[doc = "Checks if the value of the field is `NOOPERATION`"]
            #[inline]
            pub fn is_no_operation(&self) -> bool {
                *self == ERASEUICRR::NOOPERATION
            }
            #[doc = "Checks if the value of the field is `ERASE`"]
            #[inline]
            pub fn is_erase(&self) -> bool {
                *self == ERASEUICRR::ERASE
            }
        }
        #[doc = "Values that can be written to the field `ERASEUICR`"]
        pub enum ERASEUICRW {
            #[doc = "No operation."]
            NOOPERATION,
            #[doc = "Start UICR erase."]
            ERASE,
        }
        impl ERASEUICRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ERASEUICRW::NOOPERATION => false,
                    ERASEUICRW::ERASE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERASEUICRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERASEUICRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ERASEUICRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No operation."]
            #[inline]
            pub fn no_operation(self) -> &'a mut W {
                self.variant(ERASEUICRW::NOOPERATION)
            }
            #[doc = "Start UICR erase."]
            #[inline]
            pub fn erase(self) -> &'a mut W {
                self.variant(ERASEUICRW::ERASE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - It can only be used when all contents of code region 1 are erased."]
            #[inline]
            pub fn eraseuicr(&self) -> ERASEUICRR {
                ERASEUICRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - It can only be used when all contents of code region 1 are erased."]
            #[inline]
            pub fn eraseuicr(&mut self) -> _ERASEUICRW {
                _ERASEUICRW { w: self }
            }
        }
    }
}
#[doc = "PPI controller."]
pub struct PPI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PPI {}
impl PPI {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ppi::RegisterBlock {
        0x4001_f000 as *const _
    }
}
impl Deref for PPI {
    type Target = ppi::RegisterBlock;
    fn deref(&self) -> &ppi::RegisterBlock {
        unsafe { &*PPI::ptr() }
    }
}
#[doc = "PPI controller."]
pub mod ppi {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 1280usize],
        #[doc = "0x500 - Channel enable."]
        pub chen: CHEN,
        #[doc = "0x504 - Channel enable set."]
        pub chenset: CHENSET,
        #[doc = "0x508 - Channel enable clear."]
        pub chenclr: CHENCLR,
        _reserved1: [u8; 756usize],
        #[doc = "0x800 - Channel group configuration."]
        pub chg: [CHG; 4],
    }
    #[doc = "Channel enable."]
    pub struct CHEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel enable."]
    pub mod chen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CHEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CH0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH0R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH0R::DISABLED => false,
                    CH0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH0R {
                match value {
                    false => CH0R::DISABLED,
                    true => CH0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH1R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH1R::DISABLED => false,
                    CH1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH1R {
                match value {
                    false => CH1R::DISABLED,
                    true => CH1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH2R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH2R::DISABLED => false,
                    CH2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH2R {
                match value {
                    false => CH2R::DISABLED,
                    true => CH2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH3R {
            #[doc = "Channel disabled"]
            DISABLED,
            #[doc = "Channel enabled"]
            ENABLED,
        }
        impl CH3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH3R::DISABLED => false,
                    CH3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH3R {
                match value {
                    false => CH3R::DISABLED,
                    true => CH3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH4R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH4R::DISABLED => false,
                    CH4R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH4R {
                match value {
                    false => CH4R::DISABLED,
                    true => CH4R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH4R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH5R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH5R::DISABLED => false,
                    CH5R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH5R {
                match value {
                    false => CH5R::DISABLED,
                    true => CH5R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH5R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH6R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH6R::DISABLED => false,
                    CH6R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH6R {
                match value {
                    false => CH6R::DISABLED,
                    true => CH6R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH6R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH7R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH7R::DISABLED => false,
                    CH7R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH7R {
                match value {
                    false => CH7R::DISABLED,
                    true => CH7R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH7R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH8R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH8R::DISABLED => false,
                    CH8R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH8R {
                match value {
                    false => CH8R::DISABLED,
                    true => CH8R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH8R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH8R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH9R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH9R::DISABLED => false,
                    CH9R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH9R {
                match value {
                    false => CH9R::DISABLED,
                    true => CH9R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH9R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH9R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH10R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH10R::DISABLED => false,
                    CH10R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH10R {
                match value {
                    false => CH10R::DISABLED,
                    true => CH10R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH10R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH10R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH11R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH11R::DISABLED => false,
                    CH11R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH11R {
                match value {
                    false => CH11R::DISABLED,
                    true => CH11R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH11R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH11R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH12R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH12R::DISABLED => false,
                    CH12R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH12R {
                match value {
                    false => CH12R::DISABLED,
                    true => CH12R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH12R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH12R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH13R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH13R::DISABLED => false,
                    CH13R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH13R {
                match value {
                    false => CH13R::DISABLED,
                    true => CH13R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH13R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH13R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH14R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH14R::DISABLED => false,
                    CH14R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH14R {
                match value {
                    false => CH14R::DISABLED,
                    true => CH14R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH14R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH14R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH15R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH15R::DISABLED => false,
                    CH15R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH15R {
                match value {
                    false => CH15R::DISABLED,
                    true => CH15R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH15R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH15R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH20R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH20R::DISABLED => false,
                    CH20R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH20R {
                match value {
                    false => CH20R::DISABLED,
                    true => CH20R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH20R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH20R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH21R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH21R::DISABLED => false,
                    CH21R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH21R {
                match value {
                    false => CH21R::DISABLED,
                    true => CH21R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH21R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH21R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH22R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH22R::DISABLED => false,
                    CH22R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH22R {
                match value {
                    false => CH22R::DISABLED,
                    true => CH22R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH22R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH22R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH23R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH23R::DISABLED => false,
                    CH23R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH23R {
                match value {
                    false => CH23R::DISABLED,
                    true => CH23R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH23R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH23R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH24R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH24R::DISABLED => false,
                    CH24R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH24R {
                match value {
                    false => CH24R::DISABLED,
                    true => CH24R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH24R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH24R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH25R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH25R::DISABLED => false,
                    CH25R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH25R {
                match value {
                    false => CH25R::DISABLED,
                    true => CH25R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH25R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH25R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH26R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH26R::DISABLED => false,
                    CH26R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH26R {
                match value {
                    false => CH26R::DISABLED,
                    true => CH26R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH26R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH26R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH27R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH27R::DISABLED => false,
                    CH27R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH27R {
                match value {
                    false => CH27R::DISABLED,
                    true => CH27R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH27R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH27R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH28R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH28R::DISABLED => false,
                    CH28R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH28R {
                match value {
                    false => CH28R::DISABLED,
                    true => CH28R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH28R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH28R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH29R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH29R::DISABLED => false,
                    CH29R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH29R {
                match value {
                    false => CH29R::DISABLED,
                    true => CH29R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH29R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH29R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH30R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH30R::DISABLED => false,
                    CH30R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH30R {
                match value {
                    false => CH30R::DISABLED,
                    true => CH30R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH30R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH30R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH31R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH31R::DISABLED => false,
                    CH31R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH31R {
                match value {
                    false => CH31R::DISABLED,
                    true => CH31R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH31R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH31R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `CH0`"]
        pub enum CH0W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH0W::DISABLED => false,
                    CH0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH0W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH1`"]
        pub enum CH1W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH1W::DISABLED => false,
                    CH1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH1W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH2`"]
        pub enum CH2W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH2W::DISABLED => false,
                    CH2W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH2W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH2W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH3`"]
        pub enum CH3W {
            #[doc = "Channel disabled"]
            DISABLED,
            #[doc = "Channel enabled"]
            ENABLED,
        }
        impl CH3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH3W::DISABLED => false,
                    CH3W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH3W::DISABLED)
            }
            #[doc = "Channel enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH3W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH4`"]
        pub enum CH4W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH4W::DISABLED => false,
                    CH4W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH4W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH4W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH5`"]
        pub enum CH5W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH5W::DISABLED => false,
                    CH5W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH5W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH5W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH6`"]
        pub enum CH6W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH6W::DISABLED => false,
                    CH6W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH6W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH6W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH7`"]
        pub enum CH7W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH7W::DISABLED => false,
                    CH7W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH7W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH7W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH8`"]
        pub enum CH8W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH8W::DISABLED => false,
                    CH8W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH8W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH8W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH9`"]
        pub enum CH9W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH9W::DISABLED => false,
                    CH9W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH9W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH9W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH10`"]
        pub enum CH10W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH10W::DISABLED => false,
                    CH10W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH10W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH10W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH11`"]
        pub enum CH11W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH11W::DISABLED => false,
                    CH11W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH11W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH11W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH12`"]
        pub enum CH12W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH12W::DISABLED => false,
                    CH12W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH12W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH12W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH13`"]
        pub enum CH13W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH13W::DISABLED => false,
                    CH13W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH13W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH13W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH14`"]
        pub enum CH14W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH14W::DISABLED => false,
                    CH14W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH14W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH14W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH15`"]
        pub enum CH15W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH15W::DISABLED => false,
                    CH15W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH15W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH15W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH20`"]
        pub enum CH20W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH20W::DISABLED => false,
                    CH20W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH20W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH20W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH21`"]
        pub enum CH21W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH21W::DISABLED => false,
                    CH21W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH21W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH21W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH22`"]
        pub enum CH22W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH22W::DISABLED => false,
                    CH22W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH22W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH22W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH23`"]
        pub enum CH23W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH23W::DISABLED => false,
                    CH23W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH23W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH23W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH24`"]
        pub enum CH24W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH24W::DISABLED => false,
                    CH24W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH24W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH24W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH25`"]
        pub enum CH25W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH25W::DISABLED => false,
                    CH25W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH25W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH25W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH26`"]
        pub enum CH26W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH26W::DISABLED => false,
                    CH26W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH26W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH26W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH27`"]
        pub enum CH27W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH27W::DISABLED => false,
                    CH27W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH27W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH27W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH28`"]
        pub enum CH28W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH28W::DISABLED => false,
                    CH28W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH28W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH28W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH29`"]
        pub enum CH29W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH29W::DISABLED => false,
                    CH29W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH29W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH29W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH30`"]
        pub enum CH30W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH30W::DISABLED => false,
                    CH30W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH30W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH30W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH31`"]
        pub enum CH31W {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH31W::DISABLED => false,
                    CH31W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CH31W::DISABLED)
            }
            #[doc = "Channel enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CH31W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable PPI channel 0."]
            #[inline]
            pub fn ch0(&self) -> CH0R {
                CH0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable PPI channel 1."]
            #[inline]
            pub fn ch1(&self) -> CH1R {
                CH1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable PPI channel 2."]
            #[inline]
            pub fn ch2(&self) -> CH2R {
                CH2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable PPI channel 3."]
            #[inline]
            pub fn ch3(&self) -> CH3R {
                CH3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enable PPI channel 4."]
            #[inline]
            pub fn ch4(&self) -> CH4R {
                CH4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enable PPI channel 5."]
            #[inline]
            pub fn ch5(&self) -> CH5R {
                CH5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enable PPI channel 6."]
            #[inline]
            pub fn ch6(&self) -> CH6R {
                CH6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enable PPI channel 7."]
            #[inline]
            pub fn ch7(&self) -> CH7R {
                CH7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Enable PPI channel 8."]
            #[inline]
            pub fn ch8(&self) -> CH8R {
                CH8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Enable PPI channel 9."]
            #[inline]
            pub fn ch9(&self) -> CH9R {
                CH9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Enable PPI channel 10."]
            #[inline]
            pub fn ch10(&self) -> CH10R {
                CH10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Enable PPI channel 11."]
            #[inline]
            pub fn ch11(&self) -> CH11R {
                CH11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Enable PPI channel 12."]
            #[inline]
            pub fn ch12(&self) -> CH12R {
                CH12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Enable PPI channel 13."]
            #[inline]
            pub fn ch13(&self) -> CH13R {
                CH13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Enable PPI channel 14."]
            #[inline]
            pub fn ch14(&self) -> CH14R {
                CH14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Enable PPI channel 15."]
            #[inline]
            pub fn ch15(&self) -> CH15R {
                CH15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Enable PPI channel 20."]
            #[inline]
            pub fn ch20(&self) -> CH20R {
                CH20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Enable PPI channel 21."]
            #[inline]
            pub fn ch21(&self) -> CH21R {
                CH21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Enable PPI channel 22."]
            #[inline]
            pub fn ch22(&self) -> CH22R {
                CH22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Enable PPI channel 23."]
            #[inline]
            pub fn ch23(&self) -> CH23R {
                CH23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Enable PPI channel 24."]
            #[inline]
            pub fn ch24(&self) -> CH24R {
                CH24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Enable PPI channel 25."]
            #[inline]
            pub fn ch25(&self) -> CH25R {
                CH25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Enable PPI channel 26."]
            #[inline]
            pub fn ch26(&self) -> CH26R {
                CH26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Enable PPI channel 27."]
            #[inline]
            pub fn ch27(&self) -> CH27R {
                CH27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Enable PPI channel 28."]
            #[inline]
            pub fn ch28(&self) -> CH28R {
                CH28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Enable PPI channel 29."]
            #[inline]
            pub fn ch29(&self) -> CH29R {
                CH29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Enable PPI channel 30."]
            #[inline]
            pub fn ch30(&self) -> CH30R {
                CH30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Enable PPI channel 31."]
            #[inline]
            pub fn ch31(&self) -> CH31R {
                CH31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable PPI channel 0."]
            #[inline]
            pub fn ch0(&mut self) -> _CH0W {
                _CH0W { w: self }
            }
            #[doc = "Bit 1 - Enable PPI channel 1."]
            #[inline]
            pub fn ch1(&mut self) -> _CH1W {
                _CH1W { w: self }
            }
            #[doc = "Bit 2 - Enable PPI channel 2."]
            #[inline]
            pub fn ch2(&mut self) -> _CH2W {
                _CH2W { w: self }
            }
            #[doc = "Bit 3 - Enable PPI channel 3."]
            #[inline]
            pub fn ch3(&mut self) -> _CH3W {
                _CH3W { w: self }
            }
            #[doc = "Bit 4 - Enable PPI channel 4."]
            #[inline]
            pub fn ch4(&mut self) -> _CH4W {
                _CH4W { w: self }
            }
            #[doc = "Bit 5 - Enable PPI channel 5."]
            #[inline]
            pub fn ch5(&mut self) -> _CH5W {
                _CH5W { w: self }
            }
            #[doc = "Bit 6 - Enable PPI channel 6."]
            #[inline]
            pub fn ch6(&mut self) -> _CH6W {
                _CH6W { w: self }
            }
            #[doc = "Bit 7 - Enable PPI channel 7."]
            #[inline]
            pub fn ch7(&mut self) -> _CH7W {
                _CH7W { w: self }
            }
            #[doc = "Bit 8 - Enable PPI channel 8."]
            #[inline]
            pub fn ch8(&mut self) -> _CH8W {
                _CH8W { w: self }
            }
            #[doc = "Bit 9 - Enable PPI channel 9."]
            #[inline]
            pub fn ch9(&mut self) -> _CH9W {
                _CH9W { w: self }
            }
            #[doc = "Bit 10 - Enable PPI channel 10."]
            #[inline]
            pub fn ch10(&mut self) -> _CH10W {
                _CH10W { w: self }
            }
            #[doc = "Bit 11 - Enable PPI channel 11."]
            #[inline]
            pub fn ch11(&mut self) -> _CH11W {
                _CH11W { w: self }
            }
            #[doc = "Bit 12 - Enable PPI channel 12."]
            #[inline]
            pub fn ch12(&mut self) -> _CH12W {
                _CH12W { w: self }
            }
            #[doc = "Bit 13 - Enable PPI channel 13."]
            #[inline]
            pub fn ch13(&mut self) -> _CH13W {
                _CH13W { w: self }
            }
            #[doc = "Bit 14 - Enable PPI channel 14."]
            #[inline]
            pub fn ch14(&mut self) -> _CH14W {
                _CH14W { w: self }
            }
            #[doc = "Bit 15 - Enable PPI channel 15."]
            #[inline]
            pub fn ch15(&mut self) -> _CH15W {
                _CH15W { w: self }
            }
            #[doc = "Bit 20 - Enable PPI channel 20."]
            #[inline]
            pub fn ch20(&mut self) -> _CH20W {
                _CH20W { w: self }
            }
            #[doc = "Bit 21 - Enable PPI channel 21."]
            #[inline]
            pub fn ch21(&mut self) -> _CH21W {
                _CH21W { w: self }
            }
            #[doc = "Bit 22 - Enable PPI channel 22."]
            #[inline]
            pub fn ch22(&mut self) -> _CH22W {
                _CH22W { w: self }
            }
            #[doc = "Bit 23 - Enable PPI channel 23."]
            #[inline]
            pub fn ch23(&mut self) -> _CH23W {
                _CH23W { w: self }
            }
            #[doc = "Bit 24 - Enable PPI channel 24."]
            #[inline]
            pub fn ch24(&mut self) -> _CH24W {
                _CH24W { w: self }
            }
            #[doc = "Bit 25 - Enable PPI channel 25."]
            #[inline]
            pub fn ch25(&mut self) -> _CH25W {
                _CH25W { w: self }
            }
            #[doc = "Bit 26 - Enable PPI channel 26."]
            #[inline]
            pub fn ch26(&mut self) -> _CH26W {
                _CH26W { w: self }
            }
            #[doc = "Bit 27 - Enable PPI channel 27."]
            #[inline]
            pub fn ch27(&mut self) -> _CH27W {
                _CH27W { w: self }
            }
            #[doc = "Bit 28 - Enable PPI channel 28."]
            #[inline]
            pub fn ch28(&mut self) -> _CH28W {
                _CH28W { w: self }
            }
            #[doc = "Bit 29 - Enable PPI channel 29."]
            #[inline]
            pub fn ch29(&mut self) -> _CH29W {
                _CH29W { w: self }
            }
            #[doc = "Bit 30 - Enable PPI channel 30."]
            #[inline]
            pub fn ch30(&mut self) -> _CH30W {
                _CH30W { w: self }
            }
            #[doc = "Bit 31 - Enable PPI channel 31."]
            #[inline]
            pub fn ch31(&mut self) -> _CH31W {
                _CH31W { w: self }
            }
        }
    }
    #[doc = "Channel enable set."]
    pub struct CHENSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel enable set."]
    pub mod chenset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CHENSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CH0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH0R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH0R::DISABLED => false,
                    CH0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH0R {
                match value {
                    false => CH0R::DISABLED,
                    true => CH0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH1R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH1R::DISABLED => false,
                    CH1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH1R {
                match value {
                    false => CH1R::DISABLED,
                    true => CH1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH2R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH2R::DISABLED => false,
                    CH2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH2R {
                match value {
                    false => CH2R::DISABLED,
                    true => CH2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH3R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH3R::DISABLED => false,
                    CH3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH3R {
                match value {
                    false => CH3R::DISABLED,
                    true => CH3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH4R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH4R::DISABLED => false,
                    CH4R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH4R {
                match value {
                    false => CH4R::DISABLED,
                    true => CH4R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH4R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH5R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH5R::DISABLED => false,
                    CH5R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH5R {
                match value {
                    false => CH5R::DISABLED,
                    true => CH5R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH5R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH6R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH6R::DISABLED => false,
                    CH6R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH6R {
                match value {
                    false => CH6R::DISABLED,
                    true => CH6R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH6R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH7R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH7R::DISABLED => false,
                    CH7R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH7R {
                match value {
                    false => CH7R::DISABLED,
                    true => CH7R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH7R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH8R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH8R::DISABLED => false,
                    CH8R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH8R {
                match value {
                    false => CH8R::DISABLED,
                    true => CH8R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH8R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH8R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH9R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH9R::DISABLED => false,
                    CH9R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH9R {
                match value {
                    false => CH9R::DISABLED,
                    true => CH9R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH9R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH9R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH10R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH10R::DISABLED => false,
                    CH10R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH10R {
                match value {
                    false => CH10R::DISABLED,
                    true => CH10R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH10R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH10R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH11R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH11R::DISABLED => false,
                    CH11R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH11R {
                match value {
                    false => CH11R::DISABLED,
                    true => CH11R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH11R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH11R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH12R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH12R::DISABLED => false,
                    CH12R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH12R {
                match value {
                    false => CH12R::DISABLED,
                    true => CH12R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH12R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH12R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH13R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH13R::DISABLED => false,
                    CH13R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH13R {
                match value {
                    false => CH13R::DISABLED,
                    true => CH13R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH13R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH13R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH14R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH14R::DISABLED => false,
                    CH14R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH14R {
                match value {
                    false => CH14R::DISABLED,
                    true => CH14R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH14R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH14R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH15R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH15R::DISABLED => false,
                    CH15R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH15R {
                match value {
                    false => CH15R::DISABLED,
                    true => CH15R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH15R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH15R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH20R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH20R::DISABLED => false,
                    CH20R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH20R {
                match value {
                    false => CH20R::DISABLED,
                    true => CH20R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH20R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH20R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH21R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH21R::DISABLED => false,
                    CH21R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH21R {
                match value {
                    false => CH21R::DISABLED,
                    true => CH21R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH21R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH21R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH22R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH22R::DISABLED => false,
                    CH22R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH22R {
                match value {
                    false => CH22R::DISABLED,
                    true => CH22R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH22R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH22R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH23R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH23R::DISABLED => false,
                    CH23R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH23R {
                match value {
                    false => CH23R::DISABLED,
                    true => CH23R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH23R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH23R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH24R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH24R::DISABLED => false,
                    CH24R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH24R {
                match value {
                    false => CH24R::DISABLED,
                    true => CH24R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH24R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH24R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH25R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH25R::DISABLED => false,
                    CH25R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH25R {
                match value {
                    false => CH25R::DISABLED,
                    true => CH25R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH25R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH25R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH26R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH26R::DISABLED => false,
                    CH26R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH26R {
                match value {
                    false => CH26R::DISABLED,
                    true => CH26R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH26R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH26R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH27R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH27R::DISABLED => false,
                    CH27R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH27R {
                match value {
                    false => CH27R::DISABLED,
                    true => CH27R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH27R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH27R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH28R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH28R::DISABLED => false,
                    CH28R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH28R {
                match value {
                    false => CH28R::DISABLED,
                    true => CH28R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH28R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH28R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH29R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH29R::DISABLED => false,
                    CH29R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH29R {
                match value {
                    false => CH29R::DISABLED,
                    true => CH29R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH29R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH29R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH30R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH30R::DISABLED => false,
                    CH30R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH30R {
                match value {
                    false => CH30R::DISABLED,
                    true => CH30R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH30R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH30R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH31R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH31R::DISABLED => false,
                    CH31R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH31R {
                match value {
                    false => CH31R::DISABLED,
                    true => CH31R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH31R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH31R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `CH0`"]
        pub enum CH0W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH0W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH1`"]
        pub enum CH1W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH1W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH1W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH2`"]
        pub enum CH2W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH2W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH2W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH3`"]
        pub enum CH3W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH3W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH3W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH4`"]
        pub enum CH4W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH4W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH4W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH5`"]
        pub enum CH5W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH5W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH5W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH6`"]
        pub enum CH6W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH6W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH6W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH7`"]
        pub enum CH7W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH7W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH7W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH8`"]
        pub enum CH8W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH8W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH8W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH9`"]
        pub enum CH9W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH9W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH9W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH10`"]
        pub enum CH10W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH10W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH10W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH11`"]
        pub enum CH11W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH11W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH11W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH12`"]
        pub enum CH12W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH12W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH12W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH13`"]
        pub enum CH13W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH13W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH13W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH14`"]
        pub enum CH14W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH14W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH14W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH15`"]
        pub enum CH15W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH15W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH15W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH20`"]
        pub enum CH20W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH20W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH20W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH21`"]
        pub enum CH21W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH21W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH21W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH22`"]
        pub enum CH22W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH22W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH22W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH23`"]
        pub enum CH23W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH23W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH23W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH24`"]
        pub enum CH24W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH24W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH24W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH25`"]
        pub enum CH25W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH25W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH25W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH26`"]
        pub enum CH26W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH26W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH26W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH27`"]
        pub enum CH27W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH27W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH27W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH28`"]
        pub enum CH28W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH28W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH28W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH29`"]
        pub enum CH29W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH29W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH29W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH30`"]
        pub enum CH30W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH30W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH30W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH31`"]
        pub enum CH31W {
            #[doc = "Enable channel on write."]
            SET,
        }
        impl CH31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH31W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enable channel on write."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(CH31W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable PPI channel 0."]
            #[inline]
            pub fn ch0(&self) -> CH0R {
                CH0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enable PPI channel 1."]
            #[inline]
            pub fn ch1(&self) -> CH1R {
                CH1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enable PPI channel 2."]
            #[inline]
            pub fn ch2(&self) -> CH2R {
                CH2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enable PPI channel 3."]
            #[inline]
            pub fn ch3(&self) -> CH3R {
                CH3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enable PPI channel 4."]
            #[inline]
            pub fn ch4(&self) -> CH4R {
                CH4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enable PPI channel 5."]
            #[inline]
            pub fn ch5(&self) -> CH5R {
                CH5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enable PPI channel 6."]
            #[inline]
            pub fn ch6(&self) -> CH6R {
                CH6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enable PPI channel 7."]
            #[inline]
            pub fn ch7(&self) -> CH7R {
                CH7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Enable PPI channel 8."]
            #[inline]
            pub fn ch8(&self) -> CH8R {
                CH8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Enable PPI channel 9."]
            #[inline]
            pub fn ch9(&self) -> CH9R {
                CH9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Enable PPI channel 10."]
            #[inline]
            pub fn ch10(&self) -> CH10R {
                CH10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Enable PPI channel 11."]
            #[inline]
            pub fn ch11(&self) -> CH11R {
                CH11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Enable PPI channel 12."]
            #[inline]
            pub fn ch12(&self) -> CH12R {
                CH12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Enable PPI channel 13."]
            #[inline]
            pub fn ch13(&self) -> CH13R {
                CH13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Enable PPI channel 14."]
            #[inline]
            pub fn ch14(&self) -> CH14R {
                CH14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Enable PPI channel 15."]
            #[inline]
            pub fn ch15(&self) -> CH15R {
                CH15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Enable PPI channel 20."]
            #[inline]
            pub fn ch20(&self) -> CH20R {
                CH20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Enable PPI channel 21."]
            #[inline]
            pub fn ch21(&self) -> CH21R {
                CH21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Enable PPI channel 22."]
            #[inline]
            pub fn ch22(&self) -> CH22R {
                CH22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Enable PPI channel 23."]
            #[inline]
            pub fn ch23(&self) -> CH23R {
                CH23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Enable PPI channel 24."]
            #[inline]
            pub fn ch24(&self) -> CH24R {
                CH24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Enable PPI channel 25."]
            #[inline]
            pub fn ch25(&self) -> CH25R {
                CH25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Enable PPI channel 26."]
            #[inline]
            pub fn ch26(&self) -> CH26R {
                CH26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Enable PPI channel 27."]
            #[inline]
            pub fn ch27(&self) -> CH27R {
                CH27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Enable PPI channel 28."]
            #[inline]
            pub fn ch28(&self) -> CH28R {
                CH28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Enable PPI channel 29."]
            #[inline]
            pub fn ch29(&self) -> CH29R {
                CH29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Enable PPI channel 30."]
            #[inline]
            pub fn ch30(&self) -> CH30R {
                CH30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Enable PPI channel 31."]
            #[inline]
            pub fn ch31(&self) -> CH31R {
                CH31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable PPI channel 0."]
            #[inline]
            pub fn ch0(&mut self) -> _CH0W {
                _CH0W { w: self }
            }
            #[doc = "Bit 1 - Enable PPI channel 1."]
            #[inline]
            pub fn ch1(&mut self) -> _CH1W {
                _CH1W { w: self }
            }
            #[doc = "Bit 2 - Enable PPI channel 2."]
            #[inline]
            pub fn ch2(&mut self) -> _CH2W {
                _CH2W { w: self }
            }
            #[doc = "Bit 3 - Enable PPI channel 3."]
            #[inline]
            pub fn ch3(&mut self) -> _CH3W {
                _CH3W { w: self }
            }
            #[doc = "Bit 4 - Enable PPI channel 4."]
            #[inline]
            pub fn ch4(&mut self) -> _CH4W {
                _CH4W { w: self }
            }
            #[doc = "Bit 5 - Enable PPI channel 5."]
            #[inline]
            pub fn ch5(&mut self) -> _CH5W {
                _CH5W { w: self }
            }
            #[doc = "Bit 6 - Enable PPI channel 6."]
            #[inline]
            pub fn ch6(&mut self) -> _CH6W {
                _CH6W { w: self }
            }
            #[doc = "Bit 7 - Enable PPI channel 7."]
            #[inline]
            pub fn ch7(&mut self) -> _CH7W {
                _CH7W { w: self }
            }
            #[doc = "Bit 8 - Enable PPI channel 8."]
            #[inline]
            pub fn ch8(&mut self) -> _CH8W {
                _CH8W { w: self }
            }
            #[doc = "Bit 9 - Enable PPI channel 9."]
            #[inline]
            pub fn ch9(&mut self) -> _CH9W {
                _CH9W { w: self }
            }
            #[doc = "Bit 10 - Enable PPI channel 10."]
            #[inline]
            pub fn ch10(&mut self) -> _CH10W {
                _CH10W { w: self }
            }
            #[doc = "Bit 11 - Enable PPI channel 11."]
            #[inline]
            pub fn ch11(&mut self) -> _CH11W {
                _CH11W { w: self }
            }
            #[doc = "Bit 12 - Enable PPI channel 12."]
            #[inline]
            pub fn ch12(&mut self) -> _CH12W {
                _CH12W { w: self }
            }
            #[doc = "Bit 13 - Enable PPI channel 13."]
            #[inline]
            pub fn ch13(&mut self) -> _CH13W {
                _CH13W { w: self }
            }
            #[doc = "Bit 14 - Enable PPI channel 14."]
            #[inline]
            pub fn ch14(&mut self) -> _CH14W {
                _CH14W { w: self }
            }
            #[doc = "Bit 15 - Enable PPI channel 15."]
            #[inline]
            pub fn ch15(&mut self) -> _CH15W {
                _CH15W { w: self }
            }
            #[doc = "Bit 20 - Enable PPI channel 20."]
            #[inline]
            pub fn ch20(&mut self) -> _CH20W {
                _CH20W { w: self }
            }
            #[doc = "Bit 21 - Enable PPI channel 21."]
            #[inline]
            pub fn ch21(&mut self) -> _CH21W {
                _CH21W { w: self }
            }
            #[doc = "Bit 22 - Enable PPI channel 22."]
            #[inline]
            pub fn ch22(&mut self) -> _CH22W {
                _CH22W { w: self }
            }
            #[doc = "Bit 23 - Enable PPI channel 23."]
            #[inline]
            pub fn ch23(&mut self) -> _CH23W {
                _CH23W { w: self }
            }
            #[doc = "Bit 24 - Enable PPI channel 24."]
            #[inline]
            pub fn ch24(&mut self) -> _CH24W {
                _CH24W { w: self }
            }
            #[doc = "Bit 25 - Enable PPI channel 25."]
            #[inline]
            pub fn ch25(&mut self) -> _CH25W {
                _CH25W { w: self }
            }
            #[doc = "Bit 26 - Enable PPI channel 26."]
            #[inline]
            pub fn ch26(&mut self) -> _CH26W {
                _CH26W { w: self }
            }
            #[doc = "Bit 27 - Enable PPI channel 27."]
            #[inline]
            pub fn ch27(&mut self) -> _CH27W {
                _CH27W { w: self }
            }
            #[doc = "Bit 28 - Enable PPI channel 28."]
            #[inline]
            pub fn ch28(&mut self) -> _CH28W {
                _CH28W { w: self }
            }
            #[doc = "Bit 29 - Enable PPI channel 29."]
            #[inline]
            pub fn ch29(&mut self) -> _CH29W {
                _CH29W { w: self }
            }
            #[doc = "Bit 30 - Enable PPI channel 30."]
            #[inline]
            pub fn ch30(&mut self) -> _CH30W {
                _CH30W { w: self }
            }
            #[doc = "Bit 31 - Enable PPI channel 31."]
            #[inline]
            pub fn ch31(&mut self) -> _CH31W {
                _CH31W { w: self }
            }
        }
    }
    #[doc = "Channel enable clear."]
    pub struct CHENCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel enable clear."]
    pub mod chenclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CHENCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CH0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH0R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH0R::DISABLED => false,
                    CH0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH0R {
                match value {
                    false => CH0R::DISABLED,
                    true => CH0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH1R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH1R::DISABLED => false,
                    CH1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH1R {
                match value {
                    false => CH1R::DISABLED,
                    true => CH1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH2R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH2R::DISABLED => false,
                    CH2R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH2R {
                match value {
                    false => CH2R::DISABLED,
                    true => CH2R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH2R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH2R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH3R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH3R::DISABLED => false,
                    CH3R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH3R {
                match value {
                    false => CH3R::DISABLED,
                    true => CH3R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH3R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH3R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH4R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH4R::DISABLED => false,
                    CH4R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH4R {
                match value {
                    false => CH4R::DISABLED,
                    true => CH4R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH4R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH4R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH5R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH5R::DISABLED => false,
                    CH5R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH5R {
                match value {
                    false => CH5R::DISABLED,
                    true => CH5R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH5R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH5R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH6R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH6R::DISABLED => false,
                    CH6R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH6R {
                match value {
                    false => CH6R::DISABLED,
                    true => CH6R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH6R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH6R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH7R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH7R::DISABLED => false,
                    CH7R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH7R {
                match value {
                    false => CH7R::DISABLED,
                    true => CH7R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH7R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH7R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH8R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH8R::DISABLED => false,
                    CH8R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH8R {
                match value {
                    false => CH8R::DISABLED,
                    true => CH8R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH8R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH8R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH9R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH9R::DISABLED => false,
                    CH9R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH9R {
                match value {
                    false => CH9R::DISABLED,
                    true => CH9R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH9R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH9R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH10R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH10R::DISABLED => false,
                    CH10R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH10R {
                match value {
                    false => CH10R::DISABLED,
                    true => CH10R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH10R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH10R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH11R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH11R::DISABLED => false,
                    CH11R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH11R {
                match value {
                    false => CH11R::DISABLED,
                    true => CH11R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH11R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH11R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH12R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH12R::DISABLED => false,
                    CH12R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH12R {
                match value {
                    false => CH12R::DISABLED,
                    true => CH12R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH12R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH12R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH13R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH13R::DISABLED => false,
                    CH13R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH13R {
                match value {
                    false => CH13R::DISABLED,
                    true => CH13R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH13R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH13R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH14R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH14R::DISABLED => false,
                    CH14R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH14R {
                match value {
                    false => CH14R::DISABLED,
                    true => CH14R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH14R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH14R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH15R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH15R::DISABLED => false,
                    CH15R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH15R {
                match value {
                    false => CH15R::DISABLED,
                    true => CH15R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH15R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH15R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH20R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH20R::DISABLED => false,
                    CH20R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH20R {
                match value {
                    false => CH20R::DISABLED,
                    true => CH20R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH20R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH20R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH21R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH21R::DISABLED => false,
                    CH21R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH21R {
                match value {
                    false => CH21R::DISABLED,
                    true => CH21R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH21R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH21R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH22R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH22R::DISABLED => false,
                    CH22R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH22R {
                match value {
                    false => CH22R::DISABLED,
                    true => CH22R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH22R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH22R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH23R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH23R::DISABLED => false,
                    CH23R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH23R {
                match value {
                    false => CH23R::DISABLED,
                    true => CH23R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH23R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH23R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH24R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH24R::DISABLED => false,
                    CH24R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH24R {
                match value {
                    false => CH24R::DISABLED,
                    true => CH24R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH24R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH24R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH25R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH25R::DISABLED => false,
                    CH25R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH25R {
                match value {
                    false => CH25R::DISABLED,
                    true => CH25R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH25R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH25R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH26R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH26R::DISABLED => false,
                    CH26R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH26R {
                match value {
                    false => CH26R::DISABLED,
                    true => CH26R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH26R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH26R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH27R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH27R::DISABLED => false,
                    CH27R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH27R {
                match value {
                    false => CH27R::DISABLED,
                    true => CH27R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH27R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH27R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH28R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH28R::DISABLED => false,
                    CH28R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH28R {
                match value {
                    false => CH28R::DISABLED,
                    true => CH28R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH28R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH28R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH29R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH29R::DISABLED => false,
                    CH29R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH29R {
                match value {
                    false => CH29R::DISABLED,
                    true => CH29R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH29R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH29R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH30R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH30R::DISABLED => false,
                    CH30R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH30R {
                match value {
                    false => CH30R::DISABLED,
                    true => CH30R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH30R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH30R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CH31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH31R {
            #[doc = "Channel disabled."]
            DISABLED,
            #[doc = "Channel enabled."]
            ENABLED,
        }
        impl CH31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH31R::DISABLED => false,
                    CH31R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH31R {
                match value {
                    false => CH31R::DISABLED,
                    true => CH31R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CH31R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CH31R::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `CH0`"]
        pub enum CH0W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH0W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH0W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH1`"]
        pub enum CH1W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH2`"]
        pub enum CH2W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH2W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH2W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH3`"]
        pub enum CH3W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH3W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH3W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH4`"]
        pub enum CH4W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH4W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH4W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH5`"]
        pub enum CH5W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH5W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH5W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH6`"]
        pub enum CH6W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH6W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH6W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH7`"]
        pub enum CH7W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH7W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH7W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH8`"]
        pub enum CH8W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH8W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH8W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH9`"]
        pub enum CH9W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH9W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH9W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH10`"]
        pub enum CH10W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH10W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH10W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH11`"]
        pub enum CH11W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH11W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH11W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH12`"]
        pub enum CH12W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH12W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH12W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH13`"]
        pub enum CH13W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH13W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH13W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH14`"]
        pub enum CH14W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH14W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH14W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH15`"]
        pub enum CH15W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH15W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH15W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH20`"]
        pub enum CH20W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH20W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH20W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH21`"]
        pub enum CH21W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH21W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH21W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH22`"]
        pub enum CH22W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH22W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH22W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH23`"]
        pub enum CH23W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH23W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH23W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH24`"]
        pub enum CH24W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH24W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH24W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH25`"]
        pub enum CH25W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH25W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH25W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH26`"]
        pub enum CH26W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH26W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH26W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH27`"]
        pub enum CH27W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH27W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH27W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH28`"]
        pub enum CH28W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH28W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH28W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH29`"]
        pub enum CH29W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH29W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH29W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH30`"]
        pub enum CH30W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH30W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH30W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH31`"]
        pub enum CH31W {
            #[doc = "Disable channel on write."]
            CLEAR,
        }
        impl CH31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH31W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable channel on write."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(CH31W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Disable PPI channel 0."]
            #[inline]
            pub fn ch0(&self) -> CH0R {
                CH0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Disable PPI channel 1."]
            #[inline]
            pub fn ch1(&self) -> CH1R {
                CH1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Disable PPI channel 2."]
            #[inline]
            pub fn ch2(&self) -> CH2R {
                CH2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Disable PPI channel 3."]
            #[inline]
            pub fn ch3(&self) -> CH3R {
                CH3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Disable PPI channel 4."]
            #[inline]
            pub fn ch4(&self) -> CH4R {
                CH4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Disable PPI channel 5."]
            #[inline]
            pub fn ch5(&self) -> CH5R {
                CH5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Disable PPI channel 6."]
            #[inline]
            pub fn ch6(&self) -> CH6R {
                CH6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Disable PPI channel 7."]
            #[inline]
            pub fn ch7(&self) -> CH7R {
                CH7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Disable PPI channel 8."]
            #[inline]
            pub fn ch8(&self) -> CH8R {
                CH8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Disable PPI channel 9."]
            #[inline]
            pub fn ch9(&self) -> CH9R {
                CH9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Disable PPI channel 10."]
            #[inline]
            pub fn ch10(&self) -> CH10R {
                CH10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Disable PPI channel 11."]
            #[inline]
            pub fn ch11(&self) -> CH11R {
                CH11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Disable PPI channel 12."]
            #[inline]
            pub fn ch12(&self) -> CH12R {
                CH12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Disable PPI channel 13."]
            #[inline]
            pub fn ch13(&self) -> CH13R {
                CH13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Disable PPI channel 14."]
            #[inline]
            pub fn ch14(&self) -> CH14R {
                CH14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Disable PPI channel 15."]
            #[inline]
            pub fn ch15(&self) -> CH15R {
                CH15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Disable PPI channel 20."]
            #[inline]
            pub fn ch20(&self) -> CH20R {
                CH20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Disable PPI channel 21."]
            #[inline]
            pub fn ch21(&self) -> CH21R {
                CH21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Disable PPI channel 22."]
            #[inline]
            pub fn ch22(&self) -> CH22R {
                CH22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Disable PPI channel 23."]
            #[inline]
            pub fn ch23(&self) -> CH23R {
                CH23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Disable PPI channel 24."]
            #[inline]
            pub fn ch24(&self) -> CH24R {
                CH24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Disable PPI channel 25."]
            #[inline]
            pub fn ch25(&self) -> CH25R {
                CH25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Disable PPI channel 26."]
            #[inline]
            pub fn ch26(&self) -> CH26R {
                CH26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Disable PPI channel 27."]
            #[inline]
            pub fn ch27(&self) -> CH27R {
                CH27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Disable PPI channel 28."]
            #[inline]
            pub fn ch28(&self) -> CH28R {
                CH28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Disable PPI channel 29."]
            #[inline]
            pub fn ch29(&self) -> CH29R {
                CH29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Disable PPI channel 30."]
            #[inline]
            pub fn ch30(&self) -> CH30R {
                CH30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Disable PPI channel 31."]
            #[inline]
            pub fn ch31(&self) -> CH31R {
                CH31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Disable PPI channel 0."]
            #[inline]
            pub fn ch0(&mut self) -> _CH0W {
                _CH0W { w: self }
            }
            #[doc = "Bit 1 - Disable PPI channel 1."]
            #[inline]
            pub fn ch1(&mut self) -> _CH1W {
                _CH1W { w: self }
            }
            #[doc = "Bit 2 - Disable PPI channel 2."]
            #[inline]
            pub fn ch2(&mut self) -> _CH2W {
                _CH2W { w: self }
            }
            #[doc = "Bit 3 - Disable PPI channel 3."]
            #[inline]
            pub fn ch3(&mut self) -> _CH3W {
                _CH3W { w: self }
            }
            #[doc = "Bit 4 - Disable PPI channel 4."]
            #[inline]
            pub fn ch4(&mut self) -> _CH4W {
                _CH4W { w: self }
            }
            #[doc = "Bit 5 - Disable PPI channel 5."]
            #[inline]
            pub fn ch5(&mut self) -> _CH5W {
                _CH5W { w: self }
            }
            #[doc = "Bit 6 - Disable PPI channel 6."]
            #[inline]
            pub fn ch6(&mut self) -> _CH6W {
                _CH6W { w: self }
            }
            #[doc = "Bit 7 - Disable PPI channel 7."]
            #[inline]
            pub fn ch7(&mut self) -> _CH7W {
                _CH7W { w: self }
            }
            #[doc = "Bit 8 - Disable PPI channel 8."]
            #[inline]
            pub fn ch8(&mut self) -> _CH8W {
                _CH8W { w: self }
            }
            #[doc = "Bit 9 - Disable PPI channel 9."]
            #[inline]
            pub fn ch9(&mut self) -> _CH9W {
                _CH9W { w: self }
            }
            #[doc = "Bit 10 - Disable PPI channel 10."]
            #[inline]
            pub fn ch10(&mut self) -> _CH10W {
                _CH10W { w: self }
            }
            #[doc = "Bit 11 - Disable PPI channel 11."]
            #[inline]
            pub fn ch11(&mut self) -> _CH11W {
                _CH11W { w: self }
            }
            #[doc = "Bit 12 - Disable PPI channel 12."]
            #[inline]
            pub fn ch12(&mut self) -> _CH12W {
                _CH12W { w: self }
            }
            #[doc = "Bit 13 - Disable PPI channel 13."]
            #[inline]
            pub fn ch13(&mut self) -> _CH13W {
                _CH13W { w: self }
            }
            #[doc = "Bit 14 - Disable PPI channel 14."]
            #[inline]
            pub fn ch14(&mut self) -> _CH14W {
                _CH14W { w: self }
            }
            #[doc = "Bit 15 - Disable PPI channel 15."]
            #[inline]
            pub fn ch15(&mut self) -> _CH15W {
                _CH15W { w: self }
            }
            #[doc = "Bit 20 - Disable PPI channel 20."]
            #[inline]
            pub fn ch20(&mut self) -> _CH20W {
                _CH20W { w: self }
            }
            #[doc = "Bit 21 - Disable PPI channel 21."]
            #[inline]
            pub fn ch21(&mut self) -> _CH21W {
                _CH21W { w: self }
            }
            #[doc = "Bit 22 - Disable PPI channel 22."]
            #[inline]
            pub fn ch22(&mut self) -> _CH22W {
                _CH22W { w: self }
            }
            #[doc = "Bit 23 - Disable PPI channel 23."]
            #[inline]
            pub fn ch23(&mut self) -> _CH23W {
                _CH23W { w: self }
            }
            #[doc = "Bit 24 - Disable PPI channel 24."]
            #[inline]
            pub fn ch24(&mut self) -> _CH24W {
                _CH24W { w: self }
            }
            #[doc = "Bit 25 - Disable PPI channel 25."]
            #[inline]
            pub fn ch25(&mut self) -> _CH25W {
                _CH25W { w: self }
            }
            #[doc = "Bit 26 - Disable PPI channel 26."]
            #[inline]
            pub fn ch26(&mut self) -> _CH26W {
                _CH26W { w: self }
            }
            #[doc = "Bit 27 - Disable PPI channel 27."]
            #[inline]
            pub fn ch27(&mut self) -> _CH27W {
                _CH27W { w: self }
            }
            #[doc = "Bit 28 - Disable PPI channel 28."]
            #[inline]
            pub fn ch28(&mut self) -> _CH28W {
                _CH28W { w: self }
            }
            #[doc = "Bit 29 - Disable PPI channel 29."]
            #[inline]
            pub fn ch29(&mut self) -> _CH29W {
                _CH29W { w: self }
            }
            #[doc = "Bit 30 - Disable PPI channel 30."]
            #[inline]
            pub fn ch30(&mut self) -> _CH30W {
                _CH30W { w: self }
            }
            #[doc = "Bit 31 - Disable PPI channel 31."]
            #[inline]
            pub fn ch31(&mut self) -> _CH31W {
                _CH31W { w: self }
            }
        }
    }
    #[doc = "Channel group configuration."]
    pub struct CHG {
        register: VolatileCell<u32>,
    }
    #[doc = "Channel group configuration."]
    pub mod chg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CHG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CH0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH0R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH0R::EXCLUDED => false,
                    CH0R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH0R {
                match value {
                    false => CH0R::EXCLUDED,
                    true => CH0R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH0R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH0R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH1R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH1R::EXCLUDED => false,
                    CH1R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH1R {
                match value {
                    false => CH1R::EXCLUDED,
                    true => CH1R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH1R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH1R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH2R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH2R::EXCLUDED => false,
                    CH2R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH2R {
                match value {
                    false => CH2R::EXCLUDED,
                    true => CH2R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH2R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH2R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH3R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH3R::EXCLUDED => false,
                    CH3R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH3R {
                match value {
                    false => CH3R::EXCLUDED,
                    true => CH3R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH3R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH3R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH4R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH4R::EXCLUDED => false,
                    CH4R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH4R {
                match value {
                    false => CH4R::EXCLUDED,
                    true => CH4R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH4R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH4R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH5R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH5R::EXCLUDED => false,
                    CH5R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH5R {
                match value {
                    false => CH5R::EXCLUDED,
                    true => CH5R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH5R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH5R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH6R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH6R::EXCLUDED => false,
                    CH6R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH6R {
                match value {
                    false => CH6R::EXCLUDED,
                    true => CH6R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH6R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH6R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH7R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH7R::EXCLUDED => false,
                    CH7R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH7R {
                match value {
                    false => CH7R::EXCLUDED,
                    true => CH7R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH7R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH7R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH8R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH8R::EXCLUDED => false,
                    CH8R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH8R {
                match value {
                    false => CH8R::EXCLUDED,
                    true => CH8R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH8R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH8R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH9R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH9R::EXCLUDED => false,
                    CH9R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH9R {
                match value {
                    false => CH9R::EXCLUDED,
                    true => CH9R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH9R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH9R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH10R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH10R::EXCLUDED => false,
                    CH10R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH10R {
                match value {
                    false => CH10R::EXCLUDED,
                    true => CH10R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH10R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH10R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH11R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH11R::EXCLUDED => false,
                    CH11R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH11R {
                match value {
                    false => CH11R::EXCLUDED,
                    true => CH11R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH11R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH11R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH12R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH12R::EXCLUDED => false,
                    CH12R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH12R {
                match value {
                    false => CH12R::EXCLUDED,
                    true => CH12R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH12R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH12R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH13R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH13R::EXCLUDED => false,
                    CH13R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH13R {
                match value {
                    false => CH13R::EXCLUDED,
                    true => CH13R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH13R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH13R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH14R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH14R::EXCLUDED => false,
                    CH14R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH14R {
                match value {
                    false => CH14R::EXCLUDED,
                    true => CH14R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH14R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH14R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH15R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH15R::EXCLUDED => false,
                    CH15R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH15R {
                match value {
                    false => CH15R::EXCLUDED,
                    true => CH15R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH15R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH15R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH20R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH20R::EXCLUDED => false,
                    CH20R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH20R {
                match value {
                    false => CH20R::EXCLUDED,
                    true => CH20R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH20R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH20R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH21R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH21R::EXCLUDED => false,
                    CH21R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH21R {
                match value {
                    false => CH21R::EXCLUDED,
                    true => CH21R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH21R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH21R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH22R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH22R::EXCLUDED => false,
                    CH22R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH22R {
                match value {
                    false => CH22R::EXCLUDED,
                    true => CH22R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH22R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH22R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH23R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH23R::EXCLUDED => false,
                    CH23R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH23R {
                match value {
                    false => CH23R::EXCLUDED,
                    true => CH23R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH23R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH23R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH24R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH24R::EXCLUDED => false,
                    CH24R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH24R {
                match value {
                    false => CH24R::EXCLUDED,
                    true => CH24R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH24R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH24R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH25R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH25R::EXCLUDED => false,
                    CH25R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH25R {
                match value {
                    false => CH25R::EXCLUDED,
                    true => CH25R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH25R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH25R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH26R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH26R::EXCLUDED => false,
                    CH26R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH26R {
                match value {
                    false => CH26R::EXCLUDED,
                    true => CH26R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH26R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH26R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH27R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH27R::EXCLUDED => false,
                    CH27R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH27R {
                match value {
                    false => CH27R::EXCLUDED,
                    true => CH27R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH27R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH27R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH28R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH28R::EXCLUDED => false,
                    CH28R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH28R {
                match value {
                    false => CH28R::EXCLUDED,
                    true => CH28R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH28R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH28R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH29R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH29R::EXCLUDED => false,
                    CH29R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH29R {
                match value {
                    false => CH29R::EXCLUDED,
                    true => CH29R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH29R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH29R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH30R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH30R::EXCLUDED => false,
                    CH30R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH30R {
                match value {
                    false => CH30R::EXCLUDED,
                    true => CH30R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH30R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH30R::INCLUDED
            }
        }
        #[doc = "Possible values of the field `CH31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CH31R {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CH31R::EXCLUDED => false,
                    CH31R::INCLUDED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CH31R {
                match value {
                    false => CH31R::EXCLUDED,
                    true => CH31R::INCLUDED,
                }
            }
            #[doc = "Checks if the value of the field is `EXCLUDED`"]
            #[inline]
            pub fn is_excluded(&self) -> bool {
                *self == CH31R::EXCLUDED
            }
            #[doc = "Checks if the value of the field is `INCLUDED`"]
            #[inline]
            pub fn is_included(&self) -> bool {
                *self == CH31R::INCLUDED
            }
        }
        #[doc = "Values that can be written to the field `CH0`"]
        pub enum CH0W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH0W::EXCLUDED => false,
                    CH0W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH0W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH0W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH1`"]
        pub enum CH1W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH1W::EXCLUDED => false,
                    CH1W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH1W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH1W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH2`"]
        pub enum CH2W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH2W::EXCLUDED => false,
                    CH2W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH2W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH2W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH3`"]
        pub enum CH3W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH3W::EXCLUDED => false,
                    CH3W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH3W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH3W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH4`"]
        pub enum CH4W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH4W::EXCLUDED => false,
                    CH4W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH4W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH4W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH5`"]
        pub enum CH5W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH5W::EXCLUDED => false,
                    CH5W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH5W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH5W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH6`"]
        pub enum CH6W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH6W::EXCLUDED => false,
                    CH6W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH6W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH6W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH7`"]
        pub enum CH7W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH7W::EXCLUDED => false,
                    CH7W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH7W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH7W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH8`"]
        pub enum CH8W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH8W::EXCLUDED => false,
                    CH8W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH8W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH8W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH9`"]
        pub enum CH9W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH9W::EXCLUDED => false,
                    CH9W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH9W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH9W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH10`"]
        pub enum CH10W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH10W::EXCLUDED => false,
                    CH10W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH10W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH10W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH11`"]
        pub enum CH11W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH11W::EXCLUDED => false,
                    CH11W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH11W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH11W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH12`"]
        pub enum CH12W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH12W::EXCLUDED => false,
                    CH12W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH12W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH12W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH13`"]
        pub enum CH13W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH13W::EXCLUDED => false,
                    CH13W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH13W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH13W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH14`"]
        pub enum CH14W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH14W::EXCLUDED => false,
                    CH14W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH14W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH14W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH15`"]
        pub enum CH15W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH15W::EXCLUDED => false,
                    CH15W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH15W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH15W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH20`"]
        pub enum CH20W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH20W::EXCLUDED => false,
                    CH20W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH20W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH20W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH21`"]
        pub enum CH21W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH21W::EXCLUDED => false,
                    CH21W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH21W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH21W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH22`"]
        pub enum CH22W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH22W::EXCLUDED => false,
                    CH22W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH22W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH22W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH23`"]
        pub enum CH23W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH23W::EXCLUDED => false,
                    CH23W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH23W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH23W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH24`"]
        pub enum CH24W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH24W::EXCLUDED => false,
                    CH24W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH24W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH24W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH25`"]
        pub enum CH25W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH25W::EXCLUDED => false,
                    CH25W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH25W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH25W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH26`"]
        pub enum CH26W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH26W::EXCLUDED => false,
                    CH26W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH26W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH26W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH27`"]
        pub enum CH27W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH27W::EXCLUDED => false,
                    CH27W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH27W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH27W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH28`"]
        pub enum CH28W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH28W::EXCLUDED => false,
                    CH28W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH28W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH28W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH29`"]
        pub enum CH29W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH29W::EXCLUDED => false,
                    CH29W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH29W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH29W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH30`"]
        pub enum CH30W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH30W::EXCLUDED => false,
                    CH30W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH30W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH30W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CH31`"]
        pub enum CH31W {
            #[doc = "Channel excluded."]
            EXCLUDED,
            #[doc = "Channel included."]
            INCLUDED,
        }
        impl CH31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CH31W::EXCLUDED => false,
                    CH31W::INCLUDED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CH31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CH31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CH31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Channel excluded."]
            #[inline]
            pub fn excluded(self) -> &'a mut W {
                self.variant(CH31W::EXCLUDED)
            }
            #[doc = "Channel included."]
            #[inline]
            pub fn included(self) -> &'a mut W {
                self.variant(CH31W::INCLUDED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Include CH0 in channel group."]
            #[inline]
            pub fn ch0(&self) -> CH0R {
                CH0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Include CH1 in channel group."]
            #[inline]
            pub fn ch1(&self) -> CH1R {
                CH1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Include CH2 in channel group."]
            #[inline]
            pub fn ch2(&self) -> CH2R {
                CH2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Include CH3 in channel group."]
            #[inline]
            pub fn ch3(&self) -> CH3R {
                CH3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Include CH4 in channel group."]
            #[inline]
            pub fn ch4(&self) -> CH4R {
                CH4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Include CH5 in channel group."]
            #[inline]
            pub fn ch5(&self) -> CH5R {
                CH5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Include CH6 in channel group."]
            #[inline]
            pub fn ch6(&self) -> CH6R {
                CH6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Include CH7 in channel group."]
            #[inline]
            pub fn ch7(&self) -> CH7R {
                CH7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Include CH8 in channel group."]
            #[inline]
            pub fn ch8(&self) -> CH8R {
                CH8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Include CH9 in channel group."]
            #[inline]
            pub fn ch9(&self) -> CH9R {
                CH9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Include CH10 in channel group."]
            #[inline]
            pub fn ch10(&self) -> CH10R {
                CH10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Include CH11 in channel group."]
            #[inline]
            pub fn ch11(&self) -> CH11R {
                CH11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Include CH12 in channel group."]
            #[inline]
            pub fn ch12(&self) -> CH12R {
                CH12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Include CH13 in channel group."]
            #[inline]
            pub fn ch13(&self) -> CH13R {
                CH13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Include CH14 in channel group."]
            #[inline]
            pub fn ch14(&self) -> CH14R {
                CH14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Include CH15 in channel group."]
            #[inline]
            pub fn ch15(&self) -> CH15R {
                CH15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Include CH20 in channel group."]
            #[inline]
            pub fn ch20(&self) -> CH20R {
                CH20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Include CH21 in channel group."]
            #[inline]
            pub fn ch21(&self) -> CH21R {
                CH21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Include CH22 in channel group."]
            #[inline]
            pub fn ch22(&self) -> CH22R {
                CH22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Include CH23 in channel group."]
            #[inline]
            pub fn ch23(&self) -> CH23R {
                CH23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Include CH24 in channel group."]
            #[inline]
            pub fn ch24(&self) -> CH24R {
                CH24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Include CH25 in channel group."]
            #[inline]
            pub fn ch25(&self) -> CH25R {
                CH25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Include CH26 in channel group."]
            #[inline]
            pub fn ch26(&self) -> CH26R {
                CH26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Include CH27 in channel group."]
            #[inline]
            pub fn ch27(&self) -> CH27R {
                CH27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Include CH28 in channel group."]
            #[inline]
            pub fn ch28(&self) -> CH28R {
                CH28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Include CH29 in channel group."]
            #[inline]
            pub fn ch29(&self) -> CH29R {
                CH29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Include CH30 in channel group."]
            #[inline]
            pub fn ch30(&self) -> CH30R {
                CH30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Include CH31 in channel group."]
            #[inline]
            pub fn ch31(&self) -> CH31R {
                CH31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Include CH0 in channel group."]
            #[inline]
            pub fn ch0(&mut self) -> _CH0W {
                _CH0W { w: self }
            }
            #[doc = "Bit 1 - Include CH1 in channel group."]
            #[inline]
            pub fn ch1(&mut self) -> _CH1W {
                _CH1W { w: self }
            }
            #[doc = "Bit 2 - Include CH2 in channel group."]
            #[inline]
            pub fn ch2(&mut self) -> _CH2W {
                _CH2W { w: self }
            }
            #[doc = "Bit 3 - Include CH3 in channel group."]
            #[inline]
            pub fn ch3(&mut self) -> _CH3W {
                _CH3W { w: self }
            }
            #[doc = "Bit 4 - Include CH4 in channel group."]
            #[inline]
            pub fn ch4(&mut self) -> _CH4W {
                _CH4W { w: self }
            }
            #[doc = "Bit 5 - Include CH5 in channel group."]
            #[inline]
            pub fn ch5(&mut self) -> _CH5W {
                _CH5W { w: self }
            }
            #[doc = "Bit 6 - Include CH6 in channel group."]
            #[inline]
            pub fn ch6(&mut self) -> _CH6W {
                _CH6W { w: self }
            }
            #[doc = "Bit 7 - Include CH7 in channel group."]
            #[inline]
            pub fn ch7(&mut self) -> _CH7W {
                _CH7W { w: self }
            }
            #[doc = "Bit 8 - Include CH8 in channel group."]
            #[inline]
            pub fn ch8(&mut self) -> _CH8W {
                _CH8W { w: self }
            }
            #[doc = "Bit 9 - Include CH9 in channel group."]
            #[inline]
            pub fn ch9(&mut self) -> _CH9W {
                _CH9W { w: self }
            }
            #[doc = "Bit 10 - Include CH10 in channel group."]
            #[inline]
            pub fn ch10(&mut self) -> _CH10W {
                _CH10W { w: self }
            }
            #[doc = "Bit 11 - Include CH11 in channel group."]
            #[inline]
            pub fn ch11(&mut self) -> _CH11W {
                _CH11W { w: self }
            }
            #[doc = "Bit 12 - Include CH12 in channel group."]
            #[inline]
            pub fn ch12(&mut self) -> _CH12W {
                _CH12W { w: self }
            }
            #[doc = "Bit 13 - Include CH13 in channel group."]
            #[inline]
            pub fn ch13(&mut self) -> _CH13W {
                _CH13W { w: self }
            }
            #[doc = "Bit 14 - Include CH14 in channel group."]
            #[inline]
            pub fn ch14(&mut self) -> _CH14W {
                _CH14W { w: self }
            }
            #[doc = "Bit 15 - Include CH15 in channel group."]
            #[inline]
            pub fn ch15(&mut self) -> _CH15W {
                _CH15W { w: self }
            }
            #[doc = "Bit 20 - Include CH20 in channel group."]
            #[inline]
            pub fn ch20(&mut self) -> _CH20W {
                _CH20W { w: self }
            }
            #[doc = "Bit 21 - Include CH21 in channel group."]
            #[inline]
            pub fn ch21(&mut self) -> _CH21W {
                _CH21W { w: self }
            }
            #[doc = "Bit 22 - Include CH22 in channel group."]
            #[inline]
            pub fn ch22(&mut self) -> _CH22W {
                _CH22W { w: self }
            }
            #[doc = "Bit 23 - Include CH23 in channel group."]
            #[inline]
            pub fn ch23(&mut self) -> _CH23W {
                _CH23W { w: self }
            }
            #[doc = "Bit 24 - Include CH24 in channel group."]
            #[inline]
            pub fn ch24(&mut self) -> _CH24W {
                _CH24W { w: self }
            }
            #[doc = "Bit 25 - Include CH25 in channel group."]
            #[inline]
            pub fn ch25(&mut self) -> _CH25W {
                _CH25W { w: self }
            }
            #[doc = "Bit 26 - Include CH26 in channel group."]
            #[inline]
            pub fn ch26(&mut self) -> _CH26W {
                _CH26W { w: self }
            }
            #[doc = "Bit 27 - Include CH27 in channel group."]
            #[inline]
            pub fn ch27(&mut self) -> _CH27W {
                _CH27W { w: self }
            }
            #[doc = "Bit 28 - Include CH28 in channel group."]
            #[inline]
            pub fn ch28(&mut self) -> _CH28W {
                _CH28W { w: self }
            }
            #[doc = "Bit 29 - Include CH29 in channel group."]
            #[inline]
            pub fn ch29(&mut self) -> _CH29W {
                _CH29W { w: self }
            }
            #[doc = "Bit 30 - Include CH30 in channel group."]
            #[inline]
            pub fn ch30(&mut self) -> _CH30W {
                _CH30W { w: self }
            }
            #[doc = "Bit 31 - Include CH31 in channel group."]
            #[inline]
            pub fn ch31(&mut self) -> _CH31W {
                _CH31W { w: self }
            }
        }
    }
}
#[doc = "Factory Information Configuration."]
pub struct FICR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FICR {}
impl FICR {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ficr::RegisterBlock {
        0x1000_0000 as *const _
    }
}
impl Deref for FICR {
    type Target = ficr::RegisterBlock;
    fn deref(&self) -> &ficr::RegisterBlock {
        unsafe { &*FICR::ptr() }
    }
}
#[doc = "Factory Information Configuration."]
pub mod ficr {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 16usize],
        #[doc = "0x10 - Code memory page size in bytes."]
        pub codepagesize: CODEPAGESIZE,
        #[doc = "0x14 - Code memory size in pages."]
        pub codesize: CODESIZE,
        _reserved1: [u8; 16usize],
        #[doc = "0x28 - Length of code region 0 in bytes."]
        pub clenr0: CLENR0,
        #[doc = "0x2c - Pre-programmed factory code present."]
        pub ppfc: PPFC,
        _reserved2: [u8; 4usize],
        #[doc = "0x34 - Number of individualy controllable RAM blocks."]
        pub numramblock: NUMRAMBLOCK,
        #[doc = "0x38 - Size of RAM blocks in bytes."]
        pub sizeramblocks: SIZERAMBLOCKS,
        _reserved3: [u8; 32usize],
        #[doc = "0x5c - Configuration identifier."]
        pub configid: CONFIGID,
        #[doc = "0x60 - Device identifier."]
        pub deviceid: [DEVICEID; 2],
        _reserved4: [u8; 24usize],
        #[doc = "0x80 - Encryption root."]
        pub er: [ER; 4],
        #[doc = "0x90 - Identity root."]
        pub ir: [IR; 4],
        #[doc = "0xa0 - Device address type."]
        pub deviceaddrtype: DEVICEADDRTYPE,
        #[doc = "0xa4 - Device address."]
        pub deviceaddr: [DEVICEADDR; 2],
        #[doc = "0xac - Radio calibration override enable."]
        pub overrideen: OVERRIDEEN,
        #[doc = "0xb0 - Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode."]
        pub nrf_1mbit: [NRF_1MBIT; 5],
        _reserved5: [u8; 40usize],
        #[doc = "0xec - Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode."]
        pub ble_1mbit: [BLE_1MBIT; 5],
    }
    #[doc = "Code memory page size in bytes."]
    pub struct CODEPAGESIZE {
        register: VolatileCell<u32>,
    }
    #[doc = "Code memory page size in bytes."]
    pub mod codepagesize {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CODEPAGESIZE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Code memory size in pages."]
    pub struct CODESIZE {
        register: VolatileCell<u32>,
    }
    #[doc = "Code memory size in pages."]
    pub mod codesize {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CODESIZE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Length of code region 0 in bytes."]
    pub struct CLENR0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Length of code region 0 in bytes."]
    pub mod clenr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLENR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Pre-programmed factory code present."]
    pub struct PPFC {
        register: VolatileCell<u32>,
    }
    #[doc = "Pre-programmed factory code present."]
    pub mod ppfc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PPFC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PPFC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PPFCR {
            #[doc = "Not present."]
            NOTPRESENT,
            #[doc = "Present."]
            PRESENT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PPFCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PPFCR::NOTPRESENT => 0xff,
                    PPFCR::PRESENT => 0,
                    PPFCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PPFCR {
                match value {
                    255 => PPFCR::NOTPRESENT,
                    0 => PPFCR::PRESENT,
                    i => PPFCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `NOTPRESENT`"]
            #[inline]
            pub fn is_not_present(&self) -> bool {
                *self == PPFCR::NOTPRESENT
            }
            #[doc = "Checks if the value of the field is `PRESENT`"]
            #[inline]
            pub fn is_present(&self) -> bool {
                *self == PPFCR::PRESENT
            }
        }
        #[doc = "Values that can be written to the field `PPFC`"]
        pub enum PPFCW {
            #[doc = "Not present."]
            NOTPRESENT,
            #[doc = "Present."]
            PRESENT,
        }
        impl PPFCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PPFCW::NOTPRESENT => 255,
                    PPFCW::PRESENT => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PPFCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PPFCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PPFCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Not present."]
            #[inline]
            pub fn not_present(self) -> &'a mut W {
                self.variant(PPFCW::NOTPRESENT)
            }
            #[doc = "Present."]
            #[inline]
            pub fn present(self) -> &'a mut W {
                self.variant(PPFCW::PRESENT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Pre-programmed factory code present."]
            #[inline]
            pub fn ppfc(&self) -> PPFCR {
                PPFCR::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Pre-programmed factory code present."]
            #[inline]
            pub fn ppfc(&mut self) -> _PPFCW {
                _PPFCW { w: self }
            }
        }
    }
    #[doc = "Number of individualy controllable RAM blocks."]
    pub struct NUMRAMBLOCK {
        register: VolatileCell<u32>,
    }
    #[doc = "Number of individualy controllable RAM blocks."]
    pub mod numramblock {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NUMRAMBLOCK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Size of RAM blocks in bytes."]
    pub struct SIZERAMBLOCKS {
        register: VolatileCell<u32>,
    }
    #[doc = "Size of RAM blocks in bytes."]
    pub mod sizeramblocks {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SIZERAMBLOCKS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Deprecated array of size of RAM block in bytes. This name is kept for backward compatinility purposes. Use SIZERAMBLOCKS instead."]
    pub struct SIZERAMBLOCK {
        register: VolatileCell<u32>,
    }
    #[doc = "Deprecated array of size of RAM block in bytes. This name is kept for backward compatinility purposes. Use SIZERAMBLOCKS instead."]
    pub mod sizeramblock {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SIZERAMBLOCK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Configuration identifier."]
    pub struct CONFIGID {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration identifier."]
    pub mod configid {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONFIGID {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct HWIDR {
            bits: u16,
        }
        impl HWIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct FWIDR {
            bits: u16,
        }
        impl FWIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _HWIDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HWIDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FWIDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FWIDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Hardware Identification Number."]
            #[inline]
            pub fn hwid(&self) -> HWIDR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                HWIDR { bits }
            }
            #[doc = "Bits 16:31 - Firmware Identification Number pre-loaded into the flash."]
            #[inline]
            pub fn fwid(&self) -> FWIDR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                FWIDR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Hardware Identification Number."]
            #[inline]
            pub fn hwid(&mut self) -> _HWIDW {
                _HWIDW { w: self }
            }
            #[doc = "Bits 16:31 - Firmware Identification Number pre-loaded into the flash."]
            #[inline]
            pub fn fwid(&mut self) -> _FWIDW {
                _FWIDW { w: self }
            }
        }
    }
    #[doc = "Device identifier."]
    pub struct DEVICEID {
        register: VolatileCell<u32>,
    }
    #[doc = "Device identifier."]
    pub mod deviceid {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DEVICEID {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Encryption root."]
    pub struct ER {
        register: VolatileCell<u32>,
    }
    #[doc = "Encryption root."]
    pub mod er {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Identity root."]
    pub struct IR {
        register: VolatileCell<u32>,
    }
    #[doc = "Identity root."]
    pub mod ir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Device address type."]
    pub struct DEVICEADDRTYPE {
        register: VolatileCell<u32>,
    }
    #[doc = "Device address type."]
    pub mod deviceaddrtype {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DEVICEADDRTYPE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DEVICEADDRTYPE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DEVICEADDRTYPER {
            #[doc = "Public address."]
            PUBLIC,
            #[doc = "Random address."]
            RANDOM,
        }
        impl DEVICEADDRTYPER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DEVICEADDRTYPER::PUBLIC => false,
                    DEVICEADDRTYPER::RANDOM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DEVICEADDRTYPER {
                match value {
                    false => DEVICEADDRTYPER::PUBLIC,
                    true => DEVICEADDRTYPER::RANDOM,
                }
            }
            #[doc = "Checks if the value of the field is `PUBLIC`"]
            #[inline]
            pub fn is_public(&self) -> bool {
                *self == DEVICEADDRTYPER::PUBLIC
            }
            #[doc = "Checks if the value of the field is `RANDOM`"]
            #[inline]
            pub fn is_random(&self) -> bool {
                *self == DEVICEADDRTYPER::RANDOM
            }
        }
        #[doc = "Values that can be written to the field `DEVICEADDRTYPE`"]
        pub enum DEVICEADDRTYPEW {
            #[doc = "Public address."]
            PUBLIC,
            #[doc = "Random address."]
            RANDOM,
        }
        impl DEVICEADDRTYPEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DEVICEADDRTYPEW::PUBLIC => false,
                    DEVICEADDRTYPEW::RANDOM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEVICEADDRTYPEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEVICEADDRTYPEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DEVICEADDRTYPEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Public address."]
            #[inline]
            pub fn public(self) -> &'a mut W {
                self.variant(DEVICEADDRTYPEW::PUBLIC)
            }
            #[doc = "Random address."]
            #[inline]
            pub fn random(self) -> &'a mut W {
                self.variant(DEVICEADDRTYPEW::RANDOM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Device address type."]
            #[inline]
            pub fn deviceaddrtype(&self) -> DEVICEADDRTYPER {
                DEVICEADDRTYPER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Device address type."]
            #[inline]
            pub fn deviceaddrtype(&mut self) -> _DEVICEADDRTYPEW {
                _DEVICEADDRTYPEW { w: self }
            }
        }
    }
    #[doc = "Device address."]
    pub struct DEVICEADDR {
        register: VolatileCell<u32>,
    }
    #[doc = "Device address."]
    pub mod deviceaddr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DEVICEADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Radio calibration override enable."]
    pub struct OVERRIDEEN {
        register: VolatileCell<u32>,
    }
    #[doc = "Radio calibration override enable."]
    pub mod overrideen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OVERRIDEEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `NRF_1MBIT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NRF_1MBITR {
            #[doc = "Override the default values for NRF_1Mbit mode."]
            OVERRIDE,
            #[doc = "Do not override the default values for NRF_1Mbit mode."]
            NOTOVERRIDE,
        }
        impl NRF_1MBITR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    NRF_1MBITR::OVERRIDE => false,
                    NRF_1MBITR::NOTOVERRIDE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> NRF_1MBITR {
                match value {
                    false => NRF_1MBITR::OVERRIDE,
                    true => NRF_1MBITR::NOTOVERRIDE,
                }
            }
            #[doc = "Checks if the value of the field is `OVERRIDE`"]
            #[inline]
            pub fn is_override_(&self) -> bool {
                *self == NRF_1MBITR::OVERRIDE
            }
            #[doc = "Checks if the value of the field is `NOTOVERRIDE`"]
            #[inline]
            pub fn is_not_override(&self) -> bool {
                *self == NRF_1MBITR::NOTOVERRIDE
            }
        }
        #[doc = "Possible values of the field `BLE_1MBIT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BLE_1MBITR {
            #[doc = "Override the default values for BLE_1Mbit mode."]
            OVERRIDE,
            #[doc = "Do not override the default values for BLE_1Mbit mode."]
            NOTOVERRIDE,
        }
        impl BLE_1MBITR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BLE_1MBITR::OVERRIDE => false,
                    BLE_1MBITR::NOTOVERRIDE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BLE_1MBITR {
                match value {
                    false => BLE_1MBITR::OVERRIDE,
                    true => BLE_1MBITR::NOTOVERRIDE,
                }
            }
            #[doc = "Checks if the value of the field is `OVERRIDE`"]
            #[inline]
            pub fn is_override_(&self) -> bool {
                *self == BLE_1MBITR::OVERRIDE
            }
            #[doc = "Checks if the value of the field is `NOTOVERRIDE`"]
            #[inline]
            pub fn is_not_override(&self) -> bool {
                *self == BLE_1MBITR::NOTOVERRIDE
            }
        }
        #[doc = "Values that can be written to the field `NRF_1MBIT`"]
        pub enum NRF_1MBITW {
            #[doc = "Override the default values for NRF_1Mbit mode."]
            OVERRIDE,
            #[doc = "Do not override the default values for NRF_1Mbit mode."]
            NOTOVERRIDE,
        }
        impl NRF_1MBITW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    NRF_1MBITW::OVERRIDE => false,
                    NRF_1MBITW::NOTOVERRIDE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NRF_1MBITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NRF_1MBITW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NRF_1MBITW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Override the default values for NRF_1Mbit mode."]
            #[inline]
            pub fn override_(self) -> &'a mut W {
                self.variant(NRF_1MBITW::OVERRIDE)
            }
            #[doc = "Do not override the default values for NRF_1Mbit mode."]
            #[inline]
            pub fn not_override(self) -> &'a mut W {
                self.variant(NRF_1MBITW::NOTOVERRIDE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BLE_1MBIT`"]
        pub enum BLE_1MBITW {
            #[doc = "Override the default values for BLE_1Mbit mode."]
            OVERRIDE,
            #[doc = "Do not override the default values for BLE_1Mbit mode."]
            NOTOVERRIDE,
        }
        impl BLE_1MBITW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BLE_1MBITW::OVERRIDE => false,
                    BLE_1MBITW::NOTOVERRIDE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BLE_1MBITW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BLE_1MBITW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BLE_1MBITW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Override the default values for BLE_1Mbit mode."]
            #[inline]
            pub fn override_(self) -> &'a mut W {
                self.variant(BLE_1MBITW::OVERRIDE)
            }
            #[doc = "Do not override the default values for BLE_1Mbit mode."]
            #[inline]
            pub fn not_override(self) -> &'a mut W {
                self.variant(BLE_1MBITW::NOTOVERRIDE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Override default values for NRF_1Mbit mode."]
            #[inline]
            pub fn nrf_1mbit(&self) -> NRF_1MBITR {
                NRF_1MBITR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Override default values for BLE_1Mbit mode."]
            #[inline]
            pub fn ble_1mbit(&self) -> BLE_1MBITR {
                BLE_1MBITR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Override default values for NRF_1Mbit mode."]
            #[inline]
            pub fn nrf_1mbit(&mut self) -> _NRF_1MBITW {
                _NRF_1MBITW { w: self }
            }
            #[doc = "Bit 3 - Override default values for BLE_1Mbit mode."]
            #[inline]
            pub fn ble_1mbit(&mut self) -> _BLE_1MBITW {
                _BLE_1MBITW { w: self }
            }
        }
    }
    #[doc = "Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode."]
    pub struct NRF_1MBIT {
        register: VolatileCell<u32>,
    }
    #[doc = "Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit mode."]
    pub mod nrf_1mbit {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NRF_1MBIT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode."]
    pub struct BLE_1MBIT {
        register: VolatileCell<u32>,
    }
    #[doc = "Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit mode."]
    pub mod ble_1mbit {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BLE_1MBIT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "User Information Configuration."]
pub struct UICR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UICR {}
impl UICR {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uicr::RegisterBlock {
        0x1000_1000 as *const _
    }
}
impl Deref for UICR {
    type Target = uicr::RegisterBlock;
    fn deref(&self) -> &uicr::RegisterBlock {
        unsafe { &*UICR::ptr() }
    }
}
#[doc = "User Information Configuration."]
pub mod uicr {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Length of code region 0."]
        pub clenr0: CLENR0,
        #[doc = "0x04 - Readback protection configuration."]
        pub rbpconf: RBPCONF,
        #[doc = "0x08 - Reset value for CLOCK XTALFREQ register."]
        pub xtalfreq: XTALFREQ,
        _reserved0: [u8; 4usize],
        #[doc = "0x10 - Firmware ID."]
        pub fwid: FWID,
        #[doc = "0x14 - Bootloader start address."]
        pub bootloaderaddr: BOOTLOADERADDR,
        _reserved1: [u8; 56usize],
        #[doc = "0x50 - Reserved for Nordic hardware design."]
        pub nrfhw: [NRFHW; 12],
        #[doc = "0x80 - Reserved for customer."]
        pub customer: [CUSTOMER; 32],
    }
    #[doc = "Length of code region 0."]
    pub struct CLENR0 {
        register: VolatileCell<u32>,
    }
    #[doc = "Length of code region 0."]
    pub mod clenr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLENR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Readback protection configuration."]
    pub struct RBPCONF {
        register: VolatileCell<u32>,
    }
    #[doc = "Readback protection configuration."]
    pub mod rbpconf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RBPCONF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PR0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PR0R {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PR0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PR0R::DISABLED => 0xff,
                    PR0R::ENABLED => 0,
                    PR0R::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PR0R {
                match value {
                    255 => PR0R::DISABLED,
                    0 => PR0R::ENABLED,
                    i => PR0R::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PR0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PR0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `PALL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PALLR {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PALLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PALLR::DISABLED => 0xff,
                    PALLR::ENABLED => 0,
                    PALLR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PALLR {
                match value {
                    255 => PALLR::DISABLED,
                    0 => PALLR::ENABLED,
                    i => PALLR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PALLR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == PALLR::ENABLED
            }
        }
        #[doc = "Values that can be written to the field `PR0`"]
        pub enum PR0W {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl PR0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PR0W::DISABLED => 255,
                    PR0W::ENABLED => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PR0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PR0W) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PR0W::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PR0W::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PALL`"]
        pub enum PALLW {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Enabled."]
            ENABLED,
        }
        impl PALLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PALLW::DISABLED => 255,
                    PALLW::ENABLED => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PALLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PALLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PALLW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PALLW::DISABLED)
            }
            #[doc = "Enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PALLW::ENABLED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip."]
            #[inline]
            pub fn pr0(&self) -> PR0R {
                PR0R::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:15 - Readback protect all code in the device."]
            #[inline]
            pub fn pall(&self) -> PALLR {
                PALLR::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip."]
            #[inline]
            pub fn pr0(&mut self) -> _PR0W {
                _PR0W { w: self }
            }
            #[doc = "Bits 8:15 - Readback protect all code in the device."]
            #[inline]
            pub fn pall(&mut self) -> _PALLW {
                _PALLW { w: self }
            }
        }
    }
    #[doc = "Reset value for CLOCK XTALFREQ register."]
    pub struct XTALFREQ {
        register: VolatileCell<u32>,
    }
    #[doc = "Reset value for CLOCK XTALFREQ register."]
    pub mod xtalfreq {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::XTALFREQ {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `XTALFREQ`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum XTALFREQR {
            #[doc = "16MHz Xtal is used."]
            _16MHZ,
            #[doc = "32MHz Xtal is used."]
            _32MHZ,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl XTALFREQR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    XTALFREQR::_16MHZ => 0xff,
                    XTALFREQR::_32MHZ => 0,
                    XTALFREQR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> XTALFREQR {
                match value {
                    255 => XTALFREQR::_16MHZ,
                    0 => XTALFREQR::_32MHZ,
                    i => XTALFREQR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_16MHZ`"]
            #[inline]
            pub fn is_16mhz(&self) -> bool {
                *self == XTALFREQR::_16MHZ
            }
            #[doc = "Checks if the value of the field is `_32MHZ`"]
            #[inline]
            pub fn is_32mhz(&self) -> bool {
                *self == XTALFREQR::_32MHZ
            }
        }
        #[doc = "Values that can be written to the field `XTALFREQ`"]
        pub enum XTALFREQW {
            #[doc = "16MHz Xtal is used."]
            _16MHZ,
            #[doc = "32MHz Xtal is used."]
            _32MHZ,
        }
        impl XTALFREQW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    XTALFREQW::_16MHZ => 255,
                    XTALFREQW::_32MHZ => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _XTALFREQW<'a> {
            w: &'a mut W,
        }
        impl<'a> _XTALFREQW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: XTALFREQW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "16MHz Xtal is used."]
            #[inline]
            pub fn _16mhz(self) -> &'a mut W {
                self.variant(XTALFREQW::_16MHZ)
            }
            #[doc = "32MHz Xtal is used."]
            #[inline]
            pub fn _32mhz(self) -> &'a mut W {
                self.variant(XTALFREQW::_32MHZ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Reset value for CLOCK XTALFREQ register."]
            #[inline]
            pub fn xtalfreq(&self) -> XTALFREQR {
                XTALFREQR::_from({
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Reset value for CLOCK XTALFREQ register."]
            #[inline]
            pub fn xtalfreq(&mut self) -> _XTALFREQW {
                _XTALFREQW { w: self }
            }
        }
    }
    #[doc = "Firmware ID."]
    pub struct FWID {
        register: VolatileCell<u32>,
    }
    #[doc = "Firmware ID."]
    pub mod fwid {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::FWID {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = r" Value of the field"]
        pub struct FWIDR {
            bits: u16,
        }
        impl FWIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Identification number for the firmware loaded into the chip."]
            #[inline]
            pub fn fwid(&self) -> FWIDR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                FWIDR { bits }
            }
        }
    }
    #[doc = "Bootloader start address."]
    pub struct BOOTLOADERADDR {
        register: VolatileCell<u32>,
    }
    #[doc = "Bootloader start address."]
    pub mod bootloaderaddr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BOOTLOADERADDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Reserved for Nordic firmware design."]
    pub struct NRFFW {
        register: VolatileCell<u32>,
    }
    #[doc = "Reserved for Nordic firmware design."]
    pub mod nrffw {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NRFFW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Reserved for Nordic hardware design."]
    pub struct NRFHW {
        register: VolatileCell<u32>,
    }
    #[doc = "Reserved for Nordic hardware design."]
    pub mod nrfhw {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::NRFHW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
    #[doc = "Reserved for customer."]
    pub struct CUSTOMER {
        register: VolatileCell<u32>,
    }
    #[doc = "Reserved for customer."]
    pub mod customer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CUSTOMER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
        }
    }
}
#[doc = "General purpose input and output."]
pub struct GPIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO {}
impl GPIO {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpio::RegisterBlock {
        0x5000_0000 as *const _
    }
}
impl Deref for GPIO {
    type Target = gpio::RegisterBlock;
    fn deref(&self) -> &gpio::RegisterBlock {
        unsafe { &*GPIO::ptr() }
    }
}
#[doc = "General purpose input and output."]
pub mod gpio {
    use vcell::VolatileCell;
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 1284usize],
        #[doc = "0x504 - Write GPIO port."]
        pub out: OUT,
        #[doc = "0x508 - Set individual bits in GPIO port."]
        pub outset: OUTSET,
        #[doc = "0x50c - Clear individual bits in GPIO port."]
        pub outclr: OUTCLR,
        #[doc = "0x510 - Read GPIO port."]
        pub in_: IN,
        #[doc = "0x514 - Direction of GPIO pins."]
        pub dir: DIR,
        #[doc = "0x518 - DIR set register."]
        pub dirset: DIRSET,
        #[doc = "0x51c - DIR clear register."]
        pub dirclr: DIRCLR,
        _reserved1: [u8; 480usize],
        #[doc = "0x700 - Configuration of GPIO pins."]
        pub pin_cnf: [PIN_CNF; 32],
    }
    #[doc = "Write GPIO port."]
    pub struct OUT {
        register: VolatileCell<u32>,
    }
    #[doc = "Write GPIO port."]
    pub mod out {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PIN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN0R::LOW => false,
                    PIN0R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN0R {
                match value {
                    false => PIN0R::LOW,
                    true => PIN0R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN0R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN0R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN1R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN1R::LOW => false,
                    PIN1R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN1R {
                match value {
                    false => PIN1R::LOW,
                    true => PIN1R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN1R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN1R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN2R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN2R::LOW => false,
                    PIN2R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN2R {
                match value {
                    false => PIN2R::LOW,
                    true => PIN2R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN2R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN2R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN3R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN3R::LOW => false,
                    PIN3R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN3R {
                match value {
                    false => PIN3R::LOW,
                    true => PIN3R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN3R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN3R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN4R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN4R::LOW => false,
                    PIN4R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN4R {
                match value {
                    false => PIN4R::LOW,
                    true => PIN4R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN4R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN4R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN5R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN5R::LOW => false,
                    PIN5R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN5R {
                match value {
                    false => PIN5R::LOW,
                    true => PIN5R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN5R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN5R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN6R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN6R::LOW => false,
                    PIN6R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN6R {
                match value {
                    false => PIN6R::LOW,
                    true => PIN6R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN6R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN6R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN7R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN7R::LOW => false,
                    PIN7R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN7R {
                match value {
                    false => PIN7R::LOW,
                    true => PIN7R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN7R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN7R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN8R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN8R::LOW => false,
                    PIN8R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN8R {
                match value {
                    false => PIN8R::LOW,
                    true => PIN8R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN8R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN8R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN9R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN9R::LOW => false,
                    PIN9R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN9R {
                match value {
                    false => PIN9R::LOW,
                    true => PIN9R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN9R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN9R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN10R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN10R::LOW => false,
                    PIN10R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN10R {
                match value {
                    false => PIN10R::LOW,
                    true => PIN10R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN10R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN10R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN11R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN11R::LOW => false,
                    PIN11R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN11R {
                match value {
                    false => PIN11R::LOW,
                    true => PIN11R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN11R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN11R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN12R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN12R::LOW => false,
                    PIN12R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN12R {
                match value {
                    false => PIN12R::LOW,
                    true => PIN12R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN12R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN12R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN13R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN13R::LOW => false,
                    PIN13R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN13R {
                match value {
                    false => PIN13R::LOW,
                    true => PIN13R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN13R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN13R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN14R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN14R::LOW => false,
                    PIN14R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN14R {
                match value {
                    false => PIN14R::LOW,
                    true => PIN14R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN14R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN14R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN15R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN15R::LOW => false,
                    PIN15R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN15R {
                match value {
                    false => PIN15R::LOW,
                    true => PIN15R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN15R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN15R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN16`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN16R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN16R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN16R::LOW => false,
                    PIN16R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN16R {
                match value {
                    false => PIN16R::LOW,
                    true => PIN16R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN16R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN16R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN17`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN17R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN17R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN17R::LOW => false,
                    PIN17R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN17R {
                match value {
                    false => PIN17R::LOW,
                    true => PIN17R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN17R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN17R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN18`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN18R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN18R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN18R::LOW => false,
                    PIN18R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN18R {
                match value {
                    false => PIN18R::LOW,
                    true => PIN18R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN18R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN18R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN19`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN19R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN19R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN19R::LOW => false,
                    PIN19R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN19R {
                match value {
                    false => PIN19R::LOW,
                    true => PIN19R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN19R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN19R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN20R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN20R::LOW => false,
                    PIN20R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN20R {
                match value {
                    false => PIN20R::LOW,
                    true => PIN20R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN20R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN20R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN21R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN21R::LOW => false,
                    PIN21R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN21R {
                match value {
                    false => PIN21R::LOW,
                    true => PIN21R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN21R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN21R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN22R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN22R::LOW => false,
                    PIN22R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN22R {
                match value {
                    false => PIN22R::LOW,
                    true => PIN22R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN22R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN22R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN23R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN23R::LOW => false,
                    PIN23R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN23R {
                match value {
                    false => PIN23R::LOW,
                    true => PIN23R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN23R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN23R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN24R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN24R::LOW => false,
                    PIN24R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN24R {
                match value {
                    false => PIN24R::LOW,
                    true => PIN24R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN24R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN24R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN25R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN25R::LOW => false,
                    PIN25R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN25R {
                match value {
                    false => PIN25R::LOW,
                    true => PIN25R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN25R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN25R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN26R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN26R::LOW => false,
                    PIN26R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN26R {
                match value {
                    false => PIN26R::LOW,
                    true => PIN26R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN26R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN26R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN27R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN27R::LOW => false,
                    PIN27R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN27R {
                match value {
                    false => PIN27R::LOW,
                    true => PIN27R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN27R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN27R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN28R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN28R::LOW => false,
                    PIN28R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN28R {
                match value {
                    false => PIN28R::LOW,
                    true => PIN28R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN28R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN28R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN29R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN29R::LOW => false,
                    PIN29R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN29R {
                match value {
                    false => PIN29R::LOW,
                    true => PIN29R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN29R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN29R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN30R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN30R::LOW => false,
                    PIN30R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN30R {
                match value {
                    false => PIN30R::LOW,
                    true => PIN30R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN30R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN30R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN31R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN31R::LOW => false,
                    PIN31R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN31R {
                match value {
                    false => PIN31R::LOW,
                    true => PIN31R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN31R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN31R::HIGH
            }
        }
        #[doc = "Values that can be written to the field `PIN0`"]
        pub enum PIN0W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN0W::LOW => false,
                    PIN0W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN0W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN0W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN1`"]
        pub enum PIN1W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN1W::LOW => false,
                    PIN1W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN1W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN1W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN2`"]
        pub enum PIN2W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN2W::LOW => false,
                    PIN2W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN2W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN2W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN3`"]
        pub enum PIN3W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN3W::LOW => false,
                    PIN3W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN3W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN3W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN4`"]
        pub enum PIN4W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN4W::LOW => false,
                    PIN4W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN4W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN4W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN5`"]
        pub enum PIN5W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN5W::LOW => false,
                    PIN5W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN5W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN5W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN6`"]
        pub enum PIN6W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN6W::LOW => false,
                    PIN6W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN6W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN6W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN7`"]
        pub enum PIN7W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN7W::LOW => false,
                    PIN7W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN7W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN7W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN8`"]
        pub enum PIN8W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN8W::LOW => false,
                    PIN8W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN8W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN8W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN9`"]
        pub enum PIN9W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN9W::LOW => false,
                    PIN9W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN9W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN9W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN10`"]
        pub enum PIN10W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN10W::LOW => false,
                    PIN10W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN10W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN10W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN11`"]
        pub enum PIN11W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN11W::LOW => false,
                    PIN11W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN11W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN11W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN12`"]
        pub enum PIN12W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN12W::LOW => false,
                    PIN12W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN12W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN12W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN13`"]
        pub enum PIN13W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN13W::LOW => false,
                    PIN13W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN13W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN13W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN14`"]
        pub enum PIN14W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN14W::LOW => false,
                    PIN14W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN14W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN14W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN15`"]
        pub enum PIN15W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN15W::LOW => false,
                    PIN15W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN15W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN15W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN16`"]
        pub enum PIN16W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN16W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN16W::LOW => false,
                    PIN16W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN16W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN16W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN16W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN17`"]
        pub enum PIN17W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN17W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN17W::LOW => false,
                    PIN17W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN17W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN17W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN17W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN18`"]
        pub enum PIN18W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN18W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN18W::LOW => false,
                    PIN18W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN18W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN18W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN18W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN19`"]
        pub enum PIN19W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN19W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN19W::LOW => false,
                    PIN19W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN19W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN19W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN19W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN20`"]
        pub enum PIN20W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN20W::LOW => false,
                    PIN20W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN20W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN20W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN21`"]
        pub enum PIN21W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN21W::LOW => false,
                    PIN21W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN21W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN21W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN22`"]
        pub enum PIN22W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN22W::LOW => false,
                    PIN22W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN22W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN22W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN23`"]
        pub enum PIN23W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN23W::LOW => false,
                    PIN23W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN23W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN23W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN24`"]
        pub enum PIN24W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN24W::LOW => false,
                    PIN24W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN24W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN24W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN25`"]
        pub enum PIN25W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN25W::LOW => false,
                    PIN25W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN25W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN25W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN26`"]
        pub enum PIN26W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN26W::LOW => false,
                    PIN26W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN26W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN26W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN27`"]
        pub enum PIN27W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN27W::LOW => false,
                    PIN27W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN27W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN27W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN28`"]
        pub enum PIN28W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN28W::LOW => false,
                    PIN28W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN28W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN28W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN29`"]
        pub enum PIN29W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN29W::LOW => false,
                    PIN29W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN29W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN29W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN30`"]
        pub enum PIN30W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN30W::LOW => false,
                    PIN30W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN30W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN30W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN31`"]
        pub enum PIN31W {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN31W::LOW => false,
                    PIN31W::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin driver is low."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(PIN31W::LOW)
            }
            #[doc = "Pin driver is high."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(PIN31W::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                PIN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                PIN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                PIN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                PIN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                PIN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                PIN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                PIN6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                PIN7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                PIN8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                PIN9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                PIN10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                PIN11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                PIN12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                PIN13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                PIN14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                PIN15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                PIN16R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                PIN17R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                PIN18R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                PIN19R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                PIN20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                PIN21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                PIN22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                PIN23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                PIN24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                PIN25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                PIN26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                PIN27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                PIN28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                PIN29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                PIN30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                PIN31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Set individual bits in GPIO port."]
    pub struct OUTSET {
        register: VolatileCell<u32>,
    }
    #[doc = "Set individual bits in GPIO port."]
    pub mod outset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PIN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN0R::LOW => false,
                    PIN0R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN0R {
                match value {
                    false => PIN0R::LOW,
                    true => PIN0R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN0R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN0R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN1R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN1R::LOW => false,
                    PIN1R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN1R {
                match value {
                    false => PIN1R::LOW,
                    true => PIN1R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN1R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN1R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN2R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN2R::LOW => false,
                    PIN2R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN2R {
                match value {
                    false => PIN2R::LOW,
                    true => PIN2R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN2R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN2R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN3R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN3R::LOW => false,
                    PIN3R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN3R {
                match value {
                    false => PIN3R::LOW,
                    true => PIN3R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN3R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN3R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN4R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN4R::LOW => false,
                    PIN4R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN4R {
                match value {
                    false => PIN4R::LOW,
                    true => PIN4R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN4R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN4R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN5R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN5R::LOW => false,
                    PIN5R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN5R {
                match value {
                    false => PIN5R::LOW,
                    true => PIN5R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN5R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN5R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN6R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN6R::LOW => false,
                    PIN6R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN6R {
                match value {
                    false => PIN6R::LOW,
                    true => PIN6R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN6R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN6R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN7R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN7R::LOW => false,
                    PIN7R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN7R {
                match value {
                    false => PIN7R::LOW,
                    true => PIN7R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN7R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN7R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN8R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN8R::LOW => false,
                    PIN8R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN8R {
                match value {
                    false => PIN8R::LOW,
                    true => PIN8R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN8R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN8R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN9R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN9R::LOW => false,
                    PIN9R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN9R {
                match value {
                    false => PIN9R::LOW,
                    true => PIN9R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN9R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN9R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN10R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN10R::LOW => false,
                    PIN10R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN10R {
                match value {
                    false => PIN10R::LOW,
                    true => PIN10R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN10R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN10R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN11R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN11R::LOW => false,
                    PIN11R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN11R {
                match value {
                    false => PIN11R::LOW,
                    true => PIN11R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN11R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN11R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN12R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN12R::LOW => false,
                    PIN12R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN12R {
                match value {
                    false => PIN12R::LOW,
                    true => PIN12R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN12R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN12R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN13R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN13R::LOW => false,
                    PIN13R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN13R {
                match value {
                    false => PIN13R::LOW,
                    true => PIN13R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN13R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN13R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN14R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN14R::LOW => false,
                    PIN14R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN14R {
                match value {
                    false => PIN14R::LOW,
                    true => PIN14R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN14R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN14R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN15R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN15R::LOW => false,
                    PIN15R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN15R {
                match value {
                    false => PIN15R::LOW,
                    true => PIN15R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN15R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN15R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN16`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN16R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN16R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN16R::LOW => false,
                    PIN16R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN16R {
                match value {
                    false => PIN16R::LOW,
                    true => PIN16R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN16R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN16R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN17`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN17R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN17R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN17R::LOW => false,
                    PIN17R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN17R {
                match value {
                    false => PIN17R::LOW,
                    true => PIN17R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN17R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN17R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN18`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN18R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN18R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN18R::LOW => false,
                    PIN18R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN18R {
                match value {
                    false => PIN18R::LOW,
                    true => PIN18R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN18R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN18R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN19`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN19R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN19R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN19R::LOW => false,
                    PIN19R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN19R {
                match value {
                    false => PIN19R::LOW,
                    true => PIN19R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN19R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN19R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN20R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN20R::LOW => false,
                    PIN20R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN20R {
                match value {
                    false => PIN20R::LOW,
                    true => PIN20R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN20R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN20R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN21R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN21R::LOW => false,
                    PIN21R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN21R {
                match value {
                    false => PIN21R::LOW,
                    true => PIN21R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN21R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN21R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN22R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN22R::LOW => false,
                    PIN22R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN22R {
                match value {
                    false => PIN22R::LOW,
                    true => PIN22R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN22R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN22R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN23R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN23R::LOW => false,
                    PIN23R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN23R {
                match value {
                    false => PIN23R::LOW,
                    true => PIN23R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN23R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN23R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN24R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN24R::LOW => false,
                    PIN24R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN24R {
                match value {
                    false => PIN24R::LOW,
                    true => PIN24R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN24R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN24R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN25R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN25R::LOW => false,
                    PIN25R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN25R {
                match value {
                    false => PIN25R::LOW,
                    true => PIN25R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN25R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN25R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN26R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN26R::LOW => false,
                    PIN26R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN26R {
                match value {
                    false => PIN26R::LOW,
                    true => PIN26R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN26R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN26R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN27R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN27R::LOW => false,
                    PIN27R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN27R {
                match value {
                    false => PIN27R::LOW,
                    true => PIN27R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN27R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN27R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN28R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN28R::LOW => false,
                    PIN28R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN28R {
                match value {
                    false => PIN28R::LOW,
                    true => PIN28R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN28R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN28R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN29R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN29R::LOW => false,
                    PIN29R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN29R {
                match value {
                    false => PIN29R::LOW,
                    true => PIN29R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN29R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN29R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN30R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN30R::LOW => false,
                    PIN30R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN30R {
                match value {
                    false => PIN30R::LOW,
                    true => PIN30R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN30R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN30R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN31R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN31R::LOW => false,
                    PIN31R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN31R {
                match value {
                    false => PIN31R::LOW,
                    true => PIN31R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN31R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN31R::HIGH
            }
        }
        #[doc = "Values that can be written to the field `PIN0`"]
        pub enum PIN0W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN0W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN1`"]
        pub enum PIN1W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN1W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN1W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN2`"]
        pub enum PIN2W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN2W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN2W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN3`"]
        pub enum PIN3W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN3W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN3W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN4`"]
        pub enum PIN4W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN4W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN4W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN5`"]
        pub enum PIN5W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN5W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN5W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN6`"]
        pub enum PIN6W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN6W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN6W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN7`"]
        pub enum PIN7W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN7W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN7W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN8`"]
        pub enum PIN8W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN8W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN8W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN9`"]
        pub enum PIN9W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN9W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN9W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN10`"]
        pub enum PIN10W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN10W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN10W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN11`"]
        pub enum PIN11W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN11W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN11W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN12`"]
        pub enum PIN12W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN12W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN12W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN13`"]
        pub enum PIN13W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN13W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN13W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN14`"]
        pub enum PIN14W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN14W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN14W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN15`"]
        pub enum PIN15W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN15W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN15W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN16`"]
        pub enum PIN16W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN16W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN16W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN16W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN16W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN17`"]
        pub enum PIN17W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN17W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN17W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN17W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN17W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN18`"]
        pub enum PIN18W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN18W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN18W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN18W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN18W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN19`"]
        pub enum PIN19W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN19W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN19W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN19W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN19W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN20`"]
        pub enum PIN20W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN20W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN20W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN21`"]
        pub enum PIN21W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN21W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN21W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN22`"]
        pub enum PIN22W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN22W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN22W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN23`"]
        pub enum PIN23W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN23W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN23W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN24`"]
        pub enum PIN24W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN24W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN24W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN25`"]
        pub enum PIN25W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN25W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN25W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN26`"]
        pub enum PIN26W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN26W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN26W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN27`"]
        pub enum PIN27W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN27W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN27W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN28`"]
        pub enum PIN28W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN28W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN28W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN29`"]
        pub enum PIN29W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN29W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN29W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN30`"]
        pub enum PIN30W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN30W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN30W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN31`"]
        pub enum PIN31W {
            #[doc = "Set pin driver high."]
            SET,
        }
        impl PIN31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN31W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver high."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN31W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                PIN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                PIN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                PIN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                PIN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                PIN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                PIN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                PIN6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                PIN7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                PIN8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                PIN9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                PIN10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                PIN11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                PIN12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                PIN13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                PIN14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                PIN15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                PIN16R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                PIN17R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                PIN18R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                PIN19R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                PIN20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                PIN21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                PIN22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                PIN23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                PIN24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                PIN25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                PIN26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                PIN27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                PIN28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                PIN29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                PIN30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                PIN31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Clear individual bits in GPIO port."]
    pub struct OUTCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "Clear individual bits in GPIO port."]
    pub mod outclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::OUTCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PIN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN0R::LOW => false,
                    PIN0R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN0R {
                match value {
                    false => PIN0R::LOW,
                    true => PIN0R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN0R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN0R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN1R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN1R::LOW => false,
                    PIN1R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN1R {
                match value {
                    false => PIN1R::LOW,
                    true => PIN1R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN1R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN1R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN2R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN2R::LOW => false,
                    PIN2R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN2R {
                match value {
                    false => PIN2R::LOW,
                    true => PIN2R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN2R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN2R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN3R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN3R::LOW => false,
                    PIN3R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN3R {
                match value {
                    false => PIN3R::LOW,
                    true => PIN3R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN3R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN3R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN4R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN4R::LOW => false,
                    PIN4R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN4R {
                match value {
                    false => PIN4R::LOW,
                    true => PIN4R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN4R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN4R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN5R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN5R::LOW => false,
                    PIN5R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN5R {
                match value {
                    false => PIN5R::LOW,
                    true => PIN5R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN5R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN5R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN6R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN6R::LOW => false,
                    PIN6R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN6R {
                match value {
                    false => PIN6R::LOW,
                    true => PIN6R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN6R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN6R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN7R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN7R::LOW => false,
                    PIN7R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN7R {
                match value {
                    false => PIN7R::LOW,
                    true => PIN7R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN7R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN7R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN8R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN8R::LOW => false,
                    PIN8R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN8R {
                match value {
                    false => PIN8R::LOW,
                    true => PIN8R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN8R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN8R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN9R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN9R::LOW => false,
                    PIN9R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN9R {
                match value {
                    false => PIN9R::LOW,
                    true => PIN9R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN9R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN9R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN10R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN10R::LOW => false,
                    PIN10R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN10R {
                match value {
                    false => PIN10R::LOW,
                    true => PIN10R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN10R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN10R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN11R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN11R::LOW => false,
                    PIN11R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN11R {
                match value {
                    false => PIN11R::LOW,
                    true => PIN11R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN11R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN11R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN12R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN12R::LOW => false,
                    PIN12R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN12R {
                match value {
                    false => PIN12R::LOW,
                    true => PIN12R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN12R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN12R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN13R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN13R::LOW => false,
                    PIN13R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN13R {
                match value {
                    false => PIN13R::LOW,
                    true => PIN13R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN13R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN13R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN14R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN14R::LOW => false,
                    PIN14R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN14R {
                match value {
                    false => PIN14R::LOW,
                    true => PIN14R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN14R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN14R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN15R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN15R::LOW => false,
                    PIN15R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN15R {
                match value {
                    false => PIN15R::LOW,
                    true => PIN15R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN15R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN15R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN16`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN16R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN16R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN16R::LOW => false,
                    PIN16R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN16R {
                match value {
                    false => PIN16R::LOW,
                    true => PIN16R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN16R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN16R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN17`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN17R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN17R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN17R::LOW => false,
                    PIN17R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN17R {
                match value {
                    false => PIN17R::LOW,
                    true => PIN17R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN17R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN17R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN18`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN18R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN18R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN18R::LOW => false,
                    PIN18R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN18R {
                match value {
                    false => PIN18R::LOW,
                    true => PIN18R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN18R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN18R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN19`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN19R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN19R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN19R::LOW => false,
                    PIN19R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN19R {
                match value {
                    false => PIN19R::LOW,
                    true => PIN19R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN19R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN19R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN20R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN20R::LOW => false,
                    PIN20R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN20R {
                match value {
                    false => PIN20R::LOW,
                    true => PIN20R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN20R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN20R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN21R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN21R::LOW => false,
                    PIN21R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN21R {
                match value {
                    false => PIN21R::LOW,
                    true => PIN21R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN21R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN21R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN22R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN22R::LOW => false,
                    PIN22R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN22R {
                match value {
                    false => PIN22R::LOW,
                    true => PIN22R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN22R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN22R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN23R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN23R::LOW => false,
                    PIN23R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN23R {
                match value {
                    false => PIN23R::LOW,
                    true => PIN23R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN23R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN23R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN24R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN24R::LOW => false,
                    PIN24R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN24R {
                match value {
                    false => PIN24R::LOW,
                    true => PIN24R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN24R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN24R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN25R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN25R::LOW => false,
                    PIN25R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN25R {
                match value {
                    false => PIN25R::LOW,
                    true => PIN25R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN25R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN25R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN26R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN26R::LOW => false,
                    PIN26R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN26R {
                match value {
                    false => PIN26R::LOW,
                    true => PIN26R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN26R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN26R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN27R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN27R::LOW => false,
                    PIN27R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN27R {
                match value {
                    false => PIN27R::LOW,
                    true => PIN27R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN27R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN27R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN28R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN28R::LOW => false,
                    PIN28R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN28R {
                match value {
                    false => PIN28R::LOW,
                    true => PIN28R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN28R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN28R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN29R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN29R::LOW => false,
                    PIN29R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN29R {
                match value {
                    false => PIN29R::LOW,
                    true => PIN29R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN29R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN29R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN30R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN30R::LOW => false,
                    PIN30R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN30R {
                match value {
                    false => PIN30R::LOW,
                    true => PIN30R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN30R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN30R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN31R {
            #[doc = "Pin driver is low."]
            LOW,
            #[doc = "Pin driver is high."]
            HIGH,
        }
        impl PIN31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN31R::LOW => false,
                    PIN31R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN31R {
                match value {
                    false => PIN31R::LOW,
                    true => PIN31R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN31R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN31R::HIGH
            }
        }
        #[doc = "Values that can be written to the field `PIN0`"]
        pub enum PIN0W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN0W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN0W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN1`"]
        pub enum PIN1W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN2`"]
        pub enum PIN2W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN2W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN2W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN3`"]
        pub enum PIN3W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN3W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN3W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN4`"]
        pub enum PIN4W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN4W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN4W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN5`"]
        pub enum PIN5W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN5W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN5W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN6`"]
        pub enum PIN6W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN6W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN6W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN7`"]
        pub enum PIN7W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN7W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN7W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN8`"]
        pub enum PIN8W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN8W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN8W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN9`"]
        pub enum PIN9W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN9W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN9W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN10`"]
        pub enum PIN10W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN10W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN10W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN11`"]
        pub enum PIN11W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN11W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN11W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN12`"]
        pub enum PIN12W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN12W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN12W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN13`"]
        pub enum PIN13W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN13W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN13W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN14`"]
        pub enum PIN14W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN14W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN14W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN15`"]
        pub enum PIN15W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN15W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN15W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN16`"]
        pub enum PIN16W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN16W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN16W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN16W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN16W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN17`"]
        pub enum PIN17W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN17W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN17W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN17W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN17W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN18`"]
        pub enum PIN18W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN18W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN18W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN18W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN18W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN19`"]
        pub enum PIN19W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN19W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN19W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN19W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN19W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN20`"]
        pub enum PIN20W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN20W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN20W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN21`"]
        pub enum PIN21W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN21W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN21W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN22`"]
        pub enum PIN22W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN22W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN22W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN23`"]
        pub enum PIN23W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN23W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN23W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN24`"]
        pub enum PIN24W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN24W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN24W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN25`"]
        pub enum PIN25W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN25W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN25W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN26`"]
        pub enum PIN26W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN26W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN26W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN27`"]
        pub enum PIN27W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN27W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN27W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN28`"]
        pub enum PIN28W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN28W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN28W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN29`"]
        pub enum PIN29W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN29W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN29W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN30`"]
        pub enum PIN30W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN30W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN30W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN31`"]
        pub enum PIN31W {
            #[doc = "Set pin driver low."]
            CLEAR,
        }
        impl PIN31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN31W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin driver low."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN31W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                PIN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                PIN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                PIN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                PIN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                PIN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                PIN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                PIN6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                PIN7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                PIN8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                PIN9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                PIN10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                PIN11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                PIN12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                PIN13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                PIN14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                PIN15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                PIN16R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                PIN17R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                PIN18R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                PIN19R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                PIN20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                PIN21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                PIN22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                PIN23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                PIN24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                PIN25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                PIN26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                PIN27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                PIN28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                PIN29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                PIN30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                PIN31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Read GPIO port."]
    pub struct IN {
        register: VolatileCell<u32>,
    }
    #[doc = "Read GPIO port."]
    pub mod in_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::IN {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
        }
        #[doc = "Possible values of the field `PIN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN0R::LOW => false,
                    PIN0R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN0R {
                match value {
                    false => PIN0R::LOW,
                    true => PIN0R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN0R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN0R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN1R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN1R::LOW => false,
                    PIN1R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN1R {
                match value {
                    false => PIN1R::LOW,
                    true => PIN1R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN1R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN1R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN2R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN2R::LOW => false,
                    PIN2R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN2R {
                match value {
                    false => PIN2R::LOW,
                    true => PIN2R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN2R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN2R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN3R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN3R::LOW => false,
                    PIN3R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN3R {
                match value {
                    false => PIN3R::LOW,
                    true => PIN3R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN3R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN3R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN4R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN4R::LOW => false,
                    PIN4R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN4R {
                match value {
                    false => PIN4R::LOW,
                    true => PIN4R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN4R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN4R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN5R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN5R::LOW => false,
                    PIN5R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN5R {
                match value {
                    false => PIN5R::LOW,
                    true => PIN5R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN5R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN5R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN6R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN6R::LOW => false,
                    PIN6R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN6R {
                match value {
                    false => PIN6R::LOW,
                    true => PIN6R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN6R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN6R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN7R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN7R::LOW => false,
                    PIN7R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN7R {
                match value {
                    false => PIN7R::LOW,
                    true => PIN7R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN7R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN7R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN8R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN8R::LOW => false,
                    PIN8R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN8R {
                match value {
                    false => PIN8R::LOW,
                    true => PIN8R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN8R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN8R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN9R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN9R::LOW => false,
                    PIN9R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN9R {
                match value {
                    false => PIN9R::LOW,
                    true => PIN9R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN9R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN9R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN10R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN10R::LOW => false,
                    PIN10R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN10R {
                match value {
                    false => PIN10R::LOW,
                    true => PIN10R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN10R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN10R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN11R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN11R::LOW => false,
                    PIN11R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN11R {
                match value {
                    false => PIN11R::LOW,
                    true => PIN11R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN11R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN11R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN12R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN12R::LOW => false,
                    PIN12R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN12R {
                match value {
                    false => PIN12R::LOW,
                    true => PIN12R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN12R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN12R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN13R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN13R::LOW => false,
                    PIN13R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN13R {
                match value {
                    false => PIN13R::LOW,
                    true => PIN13R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN13R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN13R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN14R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN14R::LOW => false,
                    PIN14R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN14R {
                match value {
                    false => PIN14R::LOW,
                    true => PIN14R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN14R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN14R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN15R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN15R::LOW => false,
                    PIN15R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN15R {
                match value {
                    false => PIN15R::LOW,
                    true => PIN15R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN15R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN15R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN16`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN16R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN16R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN16R::LOW => false,
                    PIN16R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN16R {
                match value {
                    false => PIN16R::LOW,
                    true => PIN16R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN16R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN16R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN17`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN17R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN17R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN17R::LOW => false,
                    PIN17R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN17R {
                match value {
                    false => PIN17R::LOW,
                    true => PIN17R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN17R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN17R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN18`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN18R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN18R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN18R::LOW => false,
                    PIN18R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN18R {
                match value {
                    false => PIN18R::LOW,
                    true => PIN18R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN18R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN18R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN19`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN19R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN19R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN19R::LOW => false,
                    PIN19R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN19R {
                match value {
                    false => PIN19R::LOW,
                    true => PIN19R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN19R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN19R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN20R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN20R::LOW => false,
                    PIN20R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN20R {
                match value {
                    false => PIN20R::LOW,
                    true => PIN20R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN20R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN20R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN21R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN21R::LOW => false,
                    PIN21R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN21R {
                match value {
                    false => PIN21R::LOW,
                    true => PIN21R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN21R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN21R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN22R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN22R::LOW => false,
                    PIN22R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN22R {
                match value {
                    false => PIN22R::LOW,
                    true => PIN22R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN22R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN22R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN23R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN23R::LOW => false,
                    PIN23R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN23R {
                match value {
                    false => PIN23R::LOW,
                    true => PIN23R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN23R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN23R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN24R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN24R::LOW => false,
                    PIN24R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN24R {
                match value {
                    false => PIN24R::LOW,
                    true => PIN24R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN24R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN24R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN25R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN25R::LOW => false,
                    PIN25R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN25R {
                match value {
                    false => PIN25R::LOW,
                    true => PIN25R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN25R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN25R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN26R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN26R::LOW => false,
                    PIN26R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN26R {
                match value {
                    false => PIN26R::LOW,
                    true => PIN26R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN26R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN26R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN27R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN27R::LOW => false,
                    PIN27R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN27R {
                match value {
                    false => PIN27R::LOW,
                    true => PIN27R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN27R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN27R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN28R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN28R::LOW => false,
                    PIN28R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN28R {
                match value {
                    false => PIN28R::LOW,
                    true => PIN28R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN28R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN28R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN29R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN29R::LOW => false,
                    PIN29R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN29R {
                match value {
                    false => PIN29R::LOW,
                    true => PIN29R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN29R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN29R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN30R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN30R::LOW => false,
                    PIN30R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN30R {
                match value {
                    false => PIN30R::LOW,
                    true => PIN30R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN30R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN30R::HIGH
            }
        }
        #[doc = "Possible values of the field `PIN31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN31R {
            #[doc = "Pin input is low."]
            LOW,
            #[doc = "Pin input is high."]
            HIGH,
        }
        impl PIN31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN31R::LOW => false,
                    PIN31R::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN31R {
                match value {
                    false => PIN31R::LOW,
                    true => PIN31R::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == PIN31R::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == PIN31R::HIGH
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                PIN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                PIN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                PIN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                PIN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                PIN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                PIN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                PIN6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                PIN7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                PIN8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                PIN9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                PIN10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                PIN11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                PIN12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                PIN13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                PIN14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                PIN15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                PIN16R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                PIN17R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                PIN18R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                PIN19R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                PIN20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                PIN21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                PIN22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                PIN23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                PIN24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                PIN25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                PIN26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                PIN27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                PIN28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                PIN29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                PIN30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                PIN31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Direction of GPIO pins."]
    pub struct DIR {
        register: VolatileCell<u32>,
    }
    #[doc = "Direction of GPIO pins."]
    pub mod dir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PIN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN0R::INPUT => false,
                    PIN0R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN0R {
                match value {
                    false => PIN0R::INPUT,
                    true => PIN0R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN0R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN0R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN1R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN1R::INPUT => false,
                    PIN1R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN1R {
                match value {
                    false => PIN1R::INPUT,
                    true => PIN1R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN1R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN1R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN2R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN2R::INPUT => false,
                    PIN2R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN2R {
                match value {
                    false => PIN2R::INPUT,
                    true => PIN2R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN2R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN2R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN3R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN3R::INPUT => false,
                    PIN3R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN3R {
                match value {
                    false => PIN3R::INPUT,
                    true => PIN3R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN3R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN3R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN4R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN4R::INPUT => false,
                    PIN4R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN4R {
                match value {
                    false => PIN4R::INPUT,
                    true => PIN4R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN4R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN4R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN5R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN5R::INPUT => false,
                    PIN5R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN5R {
                match value {
                    false => PIN5R::INPUT,
                    true => PIN5R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN5R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN5R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN6R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN6R::INPUT => false,
                    PIN6R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN6R {
                match value {
                    false => PIN6R::INPUT,
                    true => PIN6R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN6R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN6R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN7R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN7R::INPUT => false,
                    PIN7R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN7R {
                match value {
                    false => PIN7R::INPUT,
                    true => PIN7R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN7R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN7R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN8R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN8R::INPUT => false,
                    PIN8R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN8R {
                match value {
                    false => PIN8R::INPUT,
                    true => PIN8R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN8R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN8R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN9R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN9R::INPUT => false,
                    PIN9R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN9R {
                match value {
                    false => PIN9R::INPUT,
                    true => PIN9R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN9R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN9R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN10R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN10R::INPUT => false,
                    PIN10R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN10R {
                match value {
                    false => PIN10R::INPUT,
                    true => PIN10R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN10R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN10R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN11R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN11R::INPUT => false,
                    PIN11R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN11R {
                match value {
                    false => PIN11R::INPUT,
                    true => PIN11R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN11R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN11R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN12R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN12R::INPUT => false,
                    PIN12R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN12R {
                match value {
                    false => PIN12R::INPUT,
                    true => PIN12R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN12R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN12R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN13R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN13R::INPUT => false,
                    PIN13R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN13R {
                match value {
                    false => PIN13R::INPUT,
                    true => PIN13R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN13R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN13R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN14R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN14R::INPUT => false,
                    PIN14R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN14R {
                match value {
                    false => PIN14R::INPUT,
                    true => PIN14R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN14R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN14R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN15R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN15R::INPUT => false,
                    PIN15R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN15R {
                match value {
                    false => PIN15R::INPUT,
                    true => PIN15R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN15R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN15R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN16`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN16R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN16R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN16R::INPUT => false,
                    PIN16R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN16R {
                match value {
                    false => PIN16R::INPUT,
                    true => PIN16R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN16R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN16R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN17`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN17R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN17R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN17R::INPUT => false,
                    PIN17R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN17R {
                match value {
                    false => PIN17R::INPUT,
                    true => PIN17R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN17R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN17R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN18`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN18R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN18R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN18R::INPUT => false,
                    PIN18R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN18R {
                match value {
                    false => PIN18R::INPUT,
                    true => PIN18R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN18R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN18R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN19`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN19R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN19R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN19R::INPUT => false,
                    PIN19R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN19R {
                match value {
                    false => PIN19R::INPUT,
                    true => PIN19R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN19R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN19R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN20R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN20R::INPUT => false,
                    PIN20R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN20R {
                match value {
                    false => PIN20R::INPUT,
                    true => PIN20R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN20R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN20R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN21R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN21R::INPUT => false,
                    PIN21R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN21R {
                match value {
                    false => PIN21R::INPUT,
                    true => PIN21R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN21R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN21R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN22R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN22R::INPUT => false,
                    PIN22R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN22R {
                match value {
                    false => PIN22R::INPUT,
                    true => PIN22R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN22R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN22R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN23R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN23R::INPUT => false,
                    PIN23R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN23R {
                match value {
                    false => PIN23R::INPUT,
                    true => PIN23R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN23R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN23R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN24R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN24R::INPUT => false,
                    PIN24R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN24R {
                match value {
                    false => PIN24R::INPUT,
                    true => PIN24R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN24R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN24R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN25R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN25R::INPUT => false,
                    PIN25R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN25R {
                match value {
                    false => PIN25R::INPUT,
                    true => PIN25R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN25R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN25R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN26R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN26R::INPUT => false,
                    PIN26R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN26R {
                match value {
                    false => PIN26R::INPUT,
                    true => PIN26R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN26R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN26R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN27R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN27R::INPUT => false,
                    PIN27R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN27R {
                match value {
                    false => PIN27R::INPUT,
                    true => PIN27R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN27R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN27R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN28R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN28R::INPUT => false,
                    PIN28R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN28R {
                match value {
                    false => PIN28R::INPUT,
                    true => PIN28R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN28R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN28R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN29R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN29R::INPUT => false,
                    PIN29R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN29R {
                match value {
                    false => PIN29R::INPUT,
                    true => PIN29R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN29R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN29R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN30R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN30R::INPUT => false,
                    PIN30R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN30R {
                match value {
                    false => PIN30R::INPUT,
                    true => PIN30R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN30R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN30R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN31R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN31R::INPUT => false,
                    PIN31R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN31R {
                match value {
                    false => PIN31R::INPUT,
                    true => PIN31R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN31R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN31R::OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `PIN0`"]
        pub enum PIN0W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN0W::INPUT => false,
                    PIN0W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN0W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN0W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN1`"]
        pub enum PIN1W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN1W::INPUT => false,
                    PIN1W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN1W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN1W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN2`"]
        pub enum PIN2W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN2W::INPUT => false,
                    PIN2W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN2W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN2W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN3`"]
        pub enum PIN3W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN3W::INPUT => false,
                    PIN3W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN3W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN3W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN4`"]
        pub enum PIN4W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN4W::INPUT => false,
                    PIN4W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN4W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN4W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN5`"]
        pub enum PIN5W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN5W::INPUT => false,
                    PIN5W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN5W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN5W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN6`"]
        pub enum PIN6W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN6W::INPUT => false,
                    PIN6W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN6W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN6W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN7`"]
        pub enum PIN7W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN7W::INPUT => false,
                    PIN7W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN7W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN7W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN8`"]
        pub enum PIN8W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN8W::INPUT => false,
                    PIN8W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN8W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN8W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN9`"]
        pub enum PIN9W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN9W::INPUT => false,
                    PIN9W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN9W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN9W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN10`"]
        pub enum PIN10W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN10W::INPUT => false,
                    PIN10W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN10W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN10W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN11`"]
        pub enum PIN11W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN11W::INPUT => false,
                    PIN11W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN11W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN11W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN12`"]
        pub enum PIN12W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN12W::INPUT => false,
                    PIN12W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN12W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN12W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN13`"]
        pub enum PIN13W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN13W::INPUT => false,
                    PIN13W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN13W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN13W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN14`"]
        pub enum PIN14W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN14W::INPUT => false,
                    PIN14W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN14W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN14W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN15`"]
        pub enum PIN15W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN15W::INPUT => false,
                    PIN15W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN15W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN15W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN16`"]
        pub enum PIN16W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN16W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN16W::INPUT => false,
                    PIN16W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN16W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN16W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN16W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN17`"]
        pub enum PIN17W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN17W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN17W::INPUT => false,
                    PIN17W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN17W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN17W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN17W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN18`"]
        pub enum PIN18W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN18W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN18W::INPUT => false,
                    PIN18W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN18W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN18W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN18W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN19`"]
        pub enum PIN19W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN19W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN19W::INPUT => false,
                    PIN19W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN19W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN19W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN19W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN20`"]
        pub enum PIN20W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN20W::INPUT => false,
                    PIN20W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN20W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN20W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN21`"]
        pub enum PIN21W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN21W::INPUT => false,
                    PIN21W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN21W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN21W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN22`"]
        pub enum PIN22W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN22W::INPUT => false,
                    PIN22W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN22W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN22W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN23`"]
        pub enum PIN23W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN23W::INPUT => false,
                    PIN23W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN23W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN23W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN24`"]
        pub enum PIN24W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN24W::INPUT => false,
                    PIN24W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN24W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN24W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN25`"]
        pub enum PIN25W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN25W::INPUT => false,
                    PIN25W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN25W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN25W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN26`"]
        pub enum PIN26W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN26W::INPUT => false,
                    PIN26W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN26W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN26W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN27`"]
        pub enum PIN27W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN27W::INPUT => false,
                    PIN27W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN27W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN27W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN28`"]
        pub enum PIN28W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN28W::INPUT => false,
                    PIN28W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN28W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN28W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN29`"]
        pub enum PIN29W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN29W::INPUT => false,
                    PIN29W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN29W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN29W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN30`"]
        pub enum PIN30W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN30W::INPUT => false,
                    PIN30W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN30W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN30W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN31`"]
        pub enum PIN31W {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN31W::INPUT => false,
                    PIN31W::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Pin set as input."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(PIN31W::INPUT)
            }
            #[doc = "Pin set as output."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(PIN31W::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                PIN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                PIN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                PIN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                PIN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                PIN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                PIN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                PIN6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                PIN7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                PIN8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                PIN9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                PIN10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                PIN11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                PIN12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                PIN13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                PIN14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                PIN15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                PIN16R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                PIN17R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                PIN18R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                PIN19R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                PIN20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                PIN21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                PIN22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                PIN23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                PIN24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                PIN25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                PIN26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                PIN27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                PIN28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                PIN29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                PIN30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                PIN31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pin 0."]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1 - Pin 1."]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2 - Pin 2."]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3 - Pin 3."]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4 - Pin 4."]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5 - Pin 5."]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6 - Pin 6."]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7 - Pin 7."]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8 - Pin 8."]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9 - Pin 9."]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10 - Pin 10."]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11 - Pin 11."]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12 - Pin 12."]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13 - Pin 13."]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14 - Pin 14."]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15 - Pin 15."]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16 - Pin 16."]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17 - Pin 17."]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18 - Pin 18."]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19 - Pin 19."]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20 - Pin 20."]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21 - Pin 21."]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22 - Pin 22."]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23 - Pin 23."]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24 - Pin 24."]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25 - Pin 25."]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26 - Pin 26."]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27 - Pin 27."]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28 - Pin 28."]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29 - Pin 29."]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30 - Pin 30."]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31 - Pin 31."]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "DIR set register."]
    pub struct DIRSET {
        register: VolatileCell<u32>,
    }
    #[doc = "DIR set register."]
    pub mod dirset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PIN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN0R::INPUT => false,
                    PIN0R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN0R {
                match value {
                    false => PIN0R::INPUT,
                    true => PIN0R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN0R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN0R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN1R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN1R::INPUT => false,
                    PIN1R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN1R {
                match value {
                    false => PIN1R::INPUT,
                    true => PIN1R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN1R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN1R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN2R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN2R::INPUT => false,
                    PIN2R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN2R {
                match value {
                    false => PIN2R::INPUT,
                    true => PIN2R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN2R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN2R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN3R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN3R::INPUT => false,
                    PIN3R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN3R {
                match value {
                    false => PIN3R::INPUT,
                    true => PIN3R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN3R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN3R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN4R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN4R::INPUT => false,
                    PIN4R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN4R {
                match value {
                    false => PIN4R::INPUT,
                    true => PIN4R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN4R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN4R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN5R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN5R::INPUT => false,
                    PIN5R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN5R {
                match value {
                    false => PIN5R::INPUT,
                    true => PIN5R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN5R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN5R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN6R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN6R::INPUT => false,
                    PIN6R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN6R {
                match value {
                    false => PIN6R::INPUT,
                    true => PIN6R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN6R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN6R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN7R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN7R::INPUT => false,
                    PIN7R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN7R {
                match value {
                    false => PIN7R::INPUT,
                    true => PIN7R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN7R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN7R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN8R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN8R::INPUT => false,
                    PIN8R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN8R {
                match value {
                    false => PIN8R::INPUT,
                    true => PIN8R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN8R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN8R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN9R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN9R::INPUT => false,
                    PIN9R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN9R {
                match value {
                    false => PIN9R::INPUT,
                    true => PIN9R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN9R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN9R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN10R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN10R::INPUT => false,
                    PIN10R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN10R {
                match value {
                    false => PIN10R::INPUT,
                    true => PIN10R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN10R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN10R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN11R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN11R::INPUT => false,
                    PIN11R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN11R {
                match value {
                    false => PIN11R::INPUT,
                    true => PIN11R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN11R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN11R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN12R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN12R::INPUT => false,
                    PIN12R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN12R {
                match value {
                    false => PIN12R::INPUT,
                    true => PIN12R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN12R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN12R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN13R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN13R::INPUT => false,
                    PIN13R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN13R {
                match value {
                    false => PIN13R::INPUT,
                    true => PIN13R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN13R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN13R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN14R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN14R::INPUT => false,
                    PIN14R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN14R {
                match value {
                    false => PIN14R::INPUT,
                    true => PIN14R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN14R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN14R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN15R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN15R::INPUT => false,
                    PIN15R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN15R {
                match value {
                    false => PIN15R::INPUT,
                    true => PIN15R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN15R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN15R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN16`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN16R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN16R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN16R::INPUT => false,
                    PIN16R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN16R {
                match value {
                    false => PIN16R::INPUT,
                    true => PIN16R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN16R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN16R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN17`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN17R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN17R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN17R::INPUT => false,
                    PIN17R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN17R {
                match value {
                    false => PIN17R::INPUT,
                    true => PIN17R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN17R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN17R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN18`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN18R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN18R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN18R::INPUT => false,
                    PIN18R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN18R {
                match value {
                    false => PIN18R::INPUT,
                    true => PIN18R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN18R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN18R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN19`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN19R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN19R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN19R::INPUT => false,
                    PIN19R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN19R {
                match value {
                    false => PIN19R::INPUT,
                    true => PIN19R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN19R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN19R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN20R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN20R::INPUT => false,
                    PIN20R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN20R {
                match value {
                    false => PIN20R::INPUT,
                    true => PIN20R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN20R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN20R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN21R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN21R::INPUT => false,
                    PIN21R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN21R {
                match value {
                    false => PIN21R::INPUT,
                    true => PIN21R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN21R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN21R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN22R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN22R::INPUT => false,
                    PIN22R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN22R {
                match value {
                    false => PIN22R::INPUT,
                    true => PIN22R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN22R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN22R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN23R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN23R::INPUT => false,
                    PIN23R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN23R {
                match value {
                    false => PIN23R::INPUT,
                    true => PIN23R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN23R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN23R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN24R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN24R::INPUT => false,
                    PIN24R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN24R {
                match value {
                    false => PIN24R::INPUT,
                    true => PIN24R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN24R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN24R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN25R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN25R::INPUT => false,
                    PIN25R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN25R {
                match value {
                    false => PIN25R::INPUT,
                    true => PIN25R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN25R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN25R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN26R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN26R::INPUT => false,
                    PIN26R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN26R {
                match value {
                    false => PIN26R::INPUT,
                    true => PIN26R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN26R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN26R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN27R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN27R::INPUT => false,
                    PIN27R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN27R {
                match value {
                    false => PIN27R::INPUT,
                    true => PIN27R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN27R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN27R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN28R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN28R::INPUT => false,
                    PIN28R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN28R {
                match value {
                    false => PIN28R::INPUT,
                    true => PIN28R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN28R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN28R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN29R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN29R::INPUT => false,
                    PIN29R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN29R {
                match value {
                    false => PIN29R::INPUT,
                    true => PIN29R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN29R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN29R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN30R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN30R::INPUT => false,
                    PIN30R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN30R {
                match value {
                    false => PIN30R::INPUT,
                    true => PIN30R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN30R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN30R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN31R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN31R::INPUT => false,
                    PIN31R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN31R {
                match value {
                    false => PIN31R::INPUT,
                    true => PIN31R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN31R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN31R::OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `PIN0`"]
        pub enum PIN0W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN0W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN0W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN1`"]
        pub enum PIN1W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN1W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN1W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN2`"]
        pub enum PIN2W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN2W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN2W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN3`"]
        pub enum PIN3W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN3W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN3W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN4`"]
        pub enum PIN4W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN4W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN4W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN5`"]
        pub enum PIN5W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN5W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN5W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN6`"]
        pub enum PIN6W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN6W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN6W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN7`"]
        pub enum PIN7W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN7W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN7W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN8`"]
        pub enum PIN8W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN8W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN8W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN9`"]
        pub enum PIN9W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN9W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN9W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN10`"]
        pub enum PIN10W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN10W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN10W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN11`"]
        pub enum PIN11W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN11W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN11W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN12`"]
        pub enum PIN12W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN12W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN12W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN13`"]
        pub enum PIN13W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN13W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN13W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN14`"]
        pub enum PIN14W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN14W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN14W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN15`"]
        pub enum PIN15W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN15W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN15W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN16`"]
        pub enum PIN16W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN16W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN16W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN16W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN16W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN17`"]
        pub enum PIN17W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN17W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN17W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN17W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN17W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN18`"]
        pub enum PIN18W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN18W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN18W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN18W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN18W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN19`"]
        pub enum PIN19W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN19W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN19W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN19W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN19W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN20`"]
        pub enum PIN20W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN20W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN20W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN21`"]
        pub enum PIN21W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN21W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN21W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN22`"]
        pub enum PIN22W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN22W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN22W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN23`"]
        pub enum PIN23W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN23W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN23W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN24`"]
        pub enum PIN24W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN24W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN24W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN25`"]
        pub enum PIN25W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN25W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN25W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN26`"]
        pub enum PIN26W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN26W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN26W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN27`"]
        pub enum PIN27W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN27W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN27W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN28`"]
        pub enum PIN28W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN28W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN28W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN29`"]
        pub enum PIN29W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN29W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN29W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN30`"]
        pub enum PIN30W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN30W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN30W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN31`"]
        pub enum PIN31W {
            #[doc = "Set pin as output."]
            SET,
        }
        impl PIN31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN31W::SET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as output."]
            #[inline]
            pub fn set(self) -> &'a mut W {
                self.variant(PIN31W::SET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Set as output pin 0."]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                PIN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Set as output pin 1."]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                PIN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Set as output pin 2."]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                PIN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Set as output pin 3."]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                PIN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Set as output pin 4."]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                PIN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Set as output pin 5."]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                PIN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Set as output pin 6."]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                PIN6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Set as output pin 7."]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                PIN7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Set as output pin 8."]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                PIN8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Set as output pin 9."]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                PIN9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Set as output pin 10."]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                PIN10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Set as output pin 11."]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                PIN11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Set as output pin 12."]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                PIN12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Set as output pin 13."]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                PIN13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Set as output pin 14."]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                PIN14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Set as output pin 15."]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                PIN15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Set as output pin 16."]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                PIN16R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Set as output pin 17."]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                PIN17R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Set as output pin 18."]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                PIN18R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Set as output pin 19."]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                PIN19R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Set as output pin 20."]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                PIN20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Set as output pin 21."]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                PIN21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Set as output pin 22."]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                PIN22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Set as output pin 23."]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                PIN23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Set as output pin 24."]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                PIN24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Set as output pin 25."]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                PIN25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Set as output pin 26."]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                PIN26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Set as output pin 27."]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                PIN27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Set as output pin 28."]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                PIN28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Set as output pin 29."]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                PIN29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Set as output pin 30."]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                PIN30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Set as output pin 31."]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                PIN31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Set as output pin 0."]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1 - Set as output pin 1."]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2 - Set as output pin 2."]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3 - Set as output pin 3."]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4 - Set as output pin 4."]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5 - Set as output pin 5."]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6 - Set as output pin 6."]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7 - Set as output pin 7."]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8 - Set as output pin 8."]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9 - Set as output pin 9."]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10 - Set as output pin 10."]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11 - Set as output pin 11."]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12 - Set as output pin 12."]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13 - Set as output pin 13."]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14 - Set as output pin 14."]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15 - Set as output pin 15."]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16 - Set as output pin 16."]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17 - Set as output pin 17."]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18 - Set as output pin 18."]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19 - Set as output pin 19."]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20 - Set as output pin 20."]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21 - Set as output pin 21."]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22 - Set as output pin 22."]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23 - Set as output pin 23."]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24 - Set as output pin 24."]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25 - Set as output pin 25."]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26 - Set as output pin 26."]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27 - Set as output pin 27."]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28 - Set as output pin 28."]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29 - Set as output pin 29."]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30 - Set as output pin 30."]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31 - Set as output pin 31."]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "DIR clear register."]
    pub struct DIRCLR {
        register: VolatileCell<u32>,
    }
    #[doc = "DIR clear register."]
    pub mod dirclr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIRCLR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PIN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN0R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN0R::INPUT => false,
                    PIN0R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN0R {
                match value {
                    false => PIN0R::INPUT,
                    true => PIN0R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN0R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN0R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN1R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN1R::INPUT => false,
                    PIN1R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN1R {
                match value {
                    false => PIN1R::INPUT,
                    true => PIN1R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN1R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN1R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN2R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN2R::INPUT => false,
                    PIN2R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN2R {
                match value {
                    false => PIN2R::INPUT,
                    true => PIN2R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN2R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN2R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN3R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN3R::INPUT => false,
                    PIN3R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN3R {
                match value {
                    false => PIN3R::INPUT,
                    true => PIN3R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN3R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN3R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN4`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN4R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN4R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN4R::INPUT => false,
                    PIN4R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN4R {
                match value {
                    false => PIN4R::INPUT,
                    true => PIN4R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN4R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN4R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN5`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN5R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN5R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN5R::INPUT => false,
                    PIN5R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN5R {
                match value {
                    false => PIN5R::INPUT,
                    true => PIN5R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN5R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN5R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN6`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN6R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN6R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN6R::INPUT => false,
                    PIN6R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN6R {
                match value {
                    false => PIN6R::INPUT,
                    true => PIN6R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN6R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN6R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN7`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN7R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN7R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN7R::INPUT => false,
                    PIN7R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN7R {
                match value {
                    false => PIN7R::INPUT,
                    true => PIN7R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN7R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN7R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN8`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN8R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN8R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN8R::INPUT => false,
                    PIN8R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN8R {
                match value {
                    false => PIN8R::INPUT,
                    true => PIN8R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN8R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN8R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN9`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN9R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN9R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN9R::INPUT => false,
                    PIN9R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN9R {
                match value {
                    false => PIN9R::INPUT,
                    true => PIN9R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN9R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN9R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN10`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN10R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN10R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN10R::INPUT => false,
                    PIN10R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN10R {
                match value {
                    false => PIN10R::INPUT,
                    true => PIN10R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN10R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN10R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN11`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN11R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN11R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN11R::INPUT => false,
                    PIN11R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN11R {
                match value {
                    false => PIN11R::INPUT,
                    true => PIN11R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN11R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN11R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN12`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN12R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN12R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN12R::INPUT => false,
                    PIN12R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN12R {
                match value {
                    false => PIN12R::INPUT,
                    true => PIN12R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN12R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN12R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN13`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN13R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN13R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN13R::INPUT => false,
                    PIN13R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN13R {
                match value {
                    false => PIN13R::INPUT,
                    true => PIN13R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN13R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN13R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN14`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN14R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN14R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN14R::INPUT => false,
                    PIN14R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN14R {
                match value {
                    false => PIN14R::INPUT,
                    true => PIN14R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN14R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN14R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN15`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN15R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN15R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN15R::INPUT => false,
                    PIN15R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN15R {
                match value {
                    false => PIN15R::INPUT,
                    true => PIN15R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN15R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN15R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN16`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN16R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN16R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN16R::INPUT => false,
                    PIN16R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN16R {
                match value {
                    false => PIN16R::INPUT,
                    true => PIN16R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN16R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN16R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN17`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN17R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN17R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN17R::INPUT => false,
                    PIN17R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN17R {
                match value {
                    false => PIN17R::INPUT,
                    true => PIN17R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN17R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN17R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN18`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN18R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN18R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN18R::INPUT => false,
                    PIN18R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN18R {
                match value {
                    false => PIN18R::INPUT,
                    true => PIN18R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN18R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN18R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN19`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN19R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN19R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN19R::INPUT => false,
                    PIN19R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN19R {
                match value {
                    false => PIN19R::INPUT,
                    true => PIN19R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN19R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN19R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN20`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN20R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN20R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN20R::INPUT => false,
                    PIN20R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN20R {
                match value {
                    false => PIN20R::INPUT,
                    true => PIN20R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN20R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN20R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN21`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN21R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN21R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN21R::INPUT => false,
                    PIN21R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN21R {
                match value {
                    false => PIN21R::INPUT,
                    true => PIN21R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN21R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN21R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN22`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN22R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN22R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN22R::INPUT => false,
                    PIN22R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN22R {
                match value {
                    false => PIN22R::INPUT,
                    true => PIN22R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN22R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN22R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN23`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN23R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN23R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN23R::INPUT => false,
                    PIN23R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN23R {
                match value {
                    false => PIN23R::INPUT,
                    true => PIN23R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN23R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN23R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN24`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN24R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN24R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN24R::INPUT => false,
                    PIN24R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN24R {
                match value {
                    false => PIN24R::INPUT,
                    true => PIN24R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN24R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN24R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN25`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN25R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN25R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN25R::INPUT => false,
                    PIN25R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN25R {
                match value {
                    false => PIN25R::INPUT,
                    true => PIN25R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN25R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN25R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN26`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN26R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN26R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN26R::INPUT => false,
                    PIN26R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN26R {
                match value {
                    false => PIN26R::INPUT,
                    true => PIN26R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN26R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN26R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN27`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN27R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN27R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN27R::INPUT => false,
                    PIN27R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN27R {
                match value {
                    false => PIN27R::INPUT,
                    true => PIN27R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN27R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN27R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN28`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN28R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN28R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN28R::INPUT => false,
                    PIN28R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN28R {
                match value {
                    false => PIN28R::INPUT,
                    true => PIN28R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN28R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN28R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN29`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN29R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN29R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN29R::INPUT => false,
                    PIN29R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN29R {
                match value {
                    false => PIN29R::INPUT,
                    true => PIN29R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN29R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN29R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN30`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN30R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN30R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN30R::INPUT => false,
                    PIN30R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN30R {
                match value {
                    false => PIN30R::INPUT,
                    true => PIN30R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN30R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN30R::OUTPUT
            }
        }
        #[doc = "Possible values of the field `PIN31`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PIN31R {
            #[doc = "Pin set as input."]
            INPUT,
            #[doc = "Pin set as output."]
            OUTPUT,
        }
        impl PIN31R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PIN31R::INPUT => false,
                    PIN31R::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PIN31R {
                match value {
                    false => PIN31R::INPUT,
                    true => PIN31R::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == PIN31R::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == PIN31R::OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `PIN0`"]
        pub enum PIN0W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN0W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN0W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN1`"]
        pub enum PIN1W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN1W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN1W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN2`"]
        pub enum PIN2W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN2W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN2W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN3`"]
        pub enum PIN3W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN3W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN3W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN4`"]
        pub enum PIN4W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN4W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN4W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN4W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN4W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN4W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN5`"]
        pub enum PIN5W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN5W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN5W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN5W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN5W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN5W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN6`"]
        pub enum PIN6W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN6W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN6W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN6W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN6W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN6W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN7`"]
        pub enum PIN7W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN7W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN7W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN7W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN7W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN7W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN8`"]
        pub enum PIN8W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN8W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN8W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN8W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN8W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN8W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN9`"]
        pub enum PIN9W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN9W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN9W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN9W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN9W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN9W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN10`"]
        pub enum PIN10W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN10W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN10W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN10W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN10W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN10W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN11`"]
        pub enum PIN11W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN11W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN11W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN11W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN11W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN11W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN12`"]
        pub enum PIN12W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN12W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN12W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN12W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN12W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN12W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN12W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN13`"]
        pub enum PIN13W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN13W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN13W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN13W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN13W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN13W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN13W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN14`"]
        pub enum PIN14W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN14W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN14W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN14W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN14W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN14W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN14W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN15`"]
        pub enum PIN15W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN15W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN15W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN15W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN15W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN15W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN15W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN16`"]
        pub enum PIN16W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN16W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN16W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN16W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN16W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN16W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN16W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN17`"]
        pub enum PIN17W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN17W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN17W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN17W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN17W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN17W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN17W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN18`"]
        pub enum PIN18W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN18W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN18W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN18W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN18W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN18W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN18W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN19`"]
        pub enum PIN19W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN19W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN19W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN19W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN19W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN19W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN19W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN20`"]
        pub enum PIN20W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN20W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN20W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN20W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN20W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN20W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN20W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN21`"]
        pub enum PIN21W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN21W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN21W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN21W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN21W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN21W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN21W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN22`"]
        pub enum PIN22W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN22W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN22W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN22W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN22W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN22W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN22W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN23`"]
        pub enum PIN23W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN23W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN23W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN23W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN23W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN23W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN23W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN24`"]
        pub enum PIN24W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN24W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN24W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN24W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN24W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN24W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN24W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN25`"]
        pub enum PIN25W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN25W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN25W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN25W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN25W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN25W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN25W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN26`"]
        pub enum PIN26W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN26W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN26W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN26W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN26W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN26W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN26W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN27`"]
        pub enum PIN27W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN27W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN27W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN27W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN27W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN27W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN27W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN28`"]
        pub enum PIN28W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN28W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN28W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN28W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN28W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN28W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN28W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN29`"]
        pub enum PIN29W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN29W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN29W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN29W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN29W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN29W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN29W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN30`"]
        pub enum PIN30W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN30W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN30W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN30W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN30W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN30W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN30W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PIN31`"]
        pub enum PIN31W {
            #[doc = "Set pin as input."]
            CLEAR,
        }
        impl PIN31W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PIN31W::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PIN31W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PIN31W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PIN31W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Set pin as input."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(PIN31W::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Set as input pin 0."]
            #[inline]
            pub fn pin0(&self) -> PIN0R {
                PIN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Set as input pin 1."]
            #[inline]
            pub fn pin1(&self) -> PIN1R {
                PIN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Set as input pin 2."]
            #[inline]
            pub fn pin2(&self) -> PIN2R {
                PIN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Set as input pin 3."]
            #[inline]
            pub fn pin3(&self) -> PIN3R {
                PIN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Set as input pin 4."]
            #[inline]
            pub fn pin4(&self) -> PIN4R {
                PIN4R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Set as input pin 5."]
            #[inline]
            pub fn pin5(&self) -> PIN5R {
                PIN5R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Set as input pin 6."]
            #[inline]
            pub fn pin6(&self) -> PIN6R {
                PIN6R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Set as input pin 7."]
            #[inline]
            pub fn pin7(&self) -> PIN7R {
                PIN7R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Set as input pin 8."]
            #[inline]
            pub fn pin8(&self) -> PIN8R {
                PIN8R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Set as input pin 9."]
            #[inline]
            pub fn pin9(&self) -> PIN9R {
                PIN9R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Set as input pin 10."]
            #[inline]
            pub fn pin10(&self) -> PIN10R {
                PIN10R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Set as input pin 11."]
            #[inline]
            pub fn pin11(&self) -> PIN11R {
                PIN11R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Set as input pin 12."]
            #[inline]
            pub fn pin12(&self) -> PIN12R {
                PIN12R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Set as input pin 13."]
            #[inline]
            pub fn pin13(&self) -> PIN13R {
                PIN13R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Set as input pin 14."]
            #[inline]
            pub fn pin14(&self) -> PIN14R {
                PIN14R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Set as input pin 15."]
            #[inline]
            pub fn pin15(&self) -> PIN15R {
                PIN15R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Set as input pin 16."]
            #[inline]
            pub fn pin16(&self) -> PIN16R {
                PIN16R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 17 - Set as input pin 17."]
            #[inline]
            pub fn pin17(&self) -> PIN17R {
                PIN17R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Set as input pin 18."]
            #[inline]
            pub fn pin18(&self) -> PIN18R {
                PIN18R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 19 - Set as input pin 19."]
            #[inline]
            pub fn pin19(&self) -> PIN19R {
                PIN19R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 20 - Set as input pin 20."]
            #[inline]
            pub fn pin20(&self) -> PIN20R {
                PIN20R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 21 - Set as input pin 21."]
            #[inline]
            pub fn pin21(&self) -> PIN21R {
                PIN21R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 22 - Set as input pin 22."]
            #[inline]
            pub fn pin22(&self) -> PIN22R {
                PIN22R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 23 - Set as input pin 23."]
            #[inline]
            pub fn pin23(&self) -> PIN23R {
                PIN23R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 24 - Set as input pin 24."]
            #[inline]
            pub fn pin24(&self) -> PIN24R {
                PIN24R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 25 - Set as input pin 25."]
            #[inline]
            pub fn pin25(&self) -> PIN25R {
                PIN25R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 26 - Set as input pin 26."]
            #[inline]
            pub fn pin26(&self) -> PIN26R {
                PIN26R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 27 - Set as input pin 27."]
            #[inline]
            pub fn pin27(&self) -> PIN27R {
                PIN27R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 28 - Set as input pin 28."]
            #[inline]
            pub fn pin28(&self) -> PIN28R {
                PIN28R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 29 - Set as input pin 29."]
            #[inline]
            pub fn pin29(&self) -> PIN29R {
                PIN29R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 30 - Set as input pin 30."]
            #[inline]
            pub fn pin30(&self) -> PIN30R {
                PIN30R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 31 - Set as input pin 31."]
            #[inline]
            pub fn pin31(&self) -> PIN31R {
                PIN31R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Set as input pin 0."]
            #[inline]
            pub fn pin0(&mut self) -> _PIN0W {
                _PIN0W { w: self }
            }
            #[doc = "Bit 1 - Set as input pin 1."]
            #[inline]
            pub fn pin1(&mut self) -> _PIN1W {
                _PIN1W { w: self }
            }
            #[doc = "Bit 2 - Set as input pin 2."]
            #[inline]
            pub fn pin2(&mut self) -> _PIN2W {
                _PIN2W { w: self }
            }
            #[doc = "Bit 3 - Set as input pin 3."]
            #[inline]
            pub fn pin3(&mut self) -> _PIN3W {
                _PIN3W { w: self }
            }
            #[doc = "Bit 4 - Set as input pin 4."]
            #[inline]
            pub fn pin4(&mut self) -> _PIN4W {
                _PIN4W { w: self }
            }
            #[doc = "Bit 5 - Set as input pin 5."]
            #[inline]
            pub fn pin5(&mut self) -> _PIN5W {
                _PIN5W { w: self }
            }
            #[doc = "Bit 6 - Set as input pin 6."]
            #[inline]
            pub fn pin6(&mut self) -> _PIN6W {
                _PIN6W { w: self }
            }
            #[doc = "Bit 7 - Set as input pin 7."]
            #[inline]
            pub fn pin7(&mut self) -> _PIN7W {
                _PIN7W { w: self }
            }
            #[doc = "Bit 8 - Set as input pin 8."]
            #[inline]
            pub fn pin8(&mut self) -> _PIN8W {
                _PIN8W { w: self }
            }
            #[doc = "Bit 9 - Set as input pin 9."]
            #[inline]
            pub fn pin9(&mut self) -> _PIN9W {
                _PIN9W { w: self }
            }
            #[doc = "Bit 10 - Set as input pin 10."]
            #[inline]
            pub fn pin10(&mut self) -> _PIN10W {
                _PIN10W { w: self }
            }
            #[doc = "Bit 11 - Set as input pin 11."]
            #[inline]
            pub fn pin11(&mut self) -> _PIN11W {
                _PIN11W { w: self }
            }
            #[doc = "Bit 12 - Set as input pin 12."]
            #[inline]
            pub fn pin12(&mut self) -> _PIN12W {
                _PIN12W { w: self }
            }
            #[doc = "Bit 13 - Set as input pin 13."]
            #[inline]
            pub fn pin13(&mut self) -> _PIN13W {
                _PIN13W { w: self }
            }
            #[doc = "Bit 14 - Set as input pin 14."]
            #[inline]
            pub fn pin14(&mut self) -> _PIN14W {
                _PIN14W { w: self }
            }
            #[doc = "Bit 15 - Set as input pin 15."]
            #[inline]
            pub fn pin15(&mut self) -> _PIN15W {
                _PIN15W { w: self }
            }
            #[doc = "Bit 16 - Set as input pin 16."]
            #[inline]
            pub fn pin16(&mut self) -> _PIN16W {
                _PIN16W { w: self }
            }
            #[doc = "Bit 17 - Set as input pin 17."]
            #[inline]
            pub fn pin17(&mut self) -> _PIN17W {
                _PIN17W { w: self }
            }
            #[doc = "Bit 18 - Set as input pin 18."]
            #[inline]
            pub fn pin18(&mut self) -> _PIN18W {
                _PIN18W { w: self }
            }
            #[doc = "Bit 19 - Set as input pin 19."]
            #[inline]
            pub fn pin19(&mut self) -> _PIN19W {
                _PIN19W { w: self }
            }
            #[doc = "Bit 20 - Set as input pin 20."]
            #[inline]
            pub fn pin20(&mut self) -> _PIN20W {
                _PIN20W { w: self }
            }
            #[doc = "Bit 21 - Set as input pin 21."]
            #[inline]
            pub fn pin21(&mut self) -> _PIN21W {
                _PIN21W { w: self }
            }
            #[doc = "Bit 22 - Set as input pin 22."]
            #[inline]
            pub fn pin22(&mut self) -> _PIN22W {
                _PIN22W { w: self }
            }
            #[doc = "Bit 23 - Set as input pin 23."]
            #[inline]
            pub fn pin23(&mut self) -> _PIN23W {
                _PIN23W { w: self }
            }
            #[doc = "Bit 24 - Set as input pin 24."]
            #[inline]
            pub fn pin24(&mut self) -> _PIN24W {
                _PIN24W { w: self }
            }
            #[doc = "Bit 25 - Set as input pin 25."]
            #[inline]
            pub fn pin25(&mut self) -> _PIN25W {
                _PIN25W { w: self }
            }
            #[doc = "Bit 26 - Set as input pin 26."]
            #[inline]
            pub fn pin26(&mut self) -> _PIN26W {
                _PIN26W { w: self }
            }
            #[doc = "Bit 27 - Set as input pin 27."]
            #[inline]
            pub fn pin27(&mut self) -> _PIN27W {
                _PIN27W { w: self }
            }
            #[doc = "Bit 28 - Set as input pin 28."]
            #[inline]
            pub fn pin28(&mut self) -> _PIN28W {
                _PIN28W { w: self }
            }
            #[doc = "Bit 29 - Set as input pin 29."]
            #[inline]
            pub fn pin29(&mut self) -> _PIN29W {
                _PIN29W { w: self }
            }
            #[doc = "Bit 30 - Set as input pin 30."]
            #[inline]
            pub fn pin30(&mut self) -> _PIN30W {
                _PIN30W { w: self }
            }
            #[doc = "Bit 31 - Set as input pin 31."]
            #[inline]
            pub fn pin31(&mut self) -> _PIN31W {
                _PIN31W { w: self }
            }
        }
    }
    #[doc = "Configuration of GPIO pins."]
    pub struct PIN_CNF {
        register: VolatileCell<u32>,
    }
    #[doc = "Configuration of GPIO pins."]
    pub mod pin_cnf {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIN_CNF {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R { bits: self.register.get() }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DIR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIRR {
            #[doc = "Configure pin as an input pin."]
            INPUT,
            #[doc = "Configure pin as an output pin."]
            OUTPUT,
        }
        impl DIRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DIRR::INPUT => false,
                    DIRR::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DIRR {
                match value {
                    false => DIRR::INPUT,
                    true => DIRR::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `INPUT`"]
            #[inline]
            pub fn is_input(&self) -> bool {
                *self == DIRR::INPUT
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == DIRR::OUTPUT
            }
        }
        #[doc = "Possible values of the field `INPUT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INPUTR {
            #[doc = "Connect input pin."]
            CONNECT,
            #[doc = "Disconnect input pin."]
            DISCONNECT,
        }
        impl INPUTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INPUTR::CONNECT => false,
                    INPUTR::DISCONNECT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INPUTR {
                match value {
                    false => INPUTR::CONNECT,
                    true => INPUTR::DISCONNECT,
                }
            }
            #[doc = "Checks if the value of the field is `CONNECT`"]
            #[inline]
            pub fn is_connect(&self) -> bool {
                *self == INPUTR::CONNECT
            }
            #[doc = "Checks if the value of the field is `DISCONNECT`"]
            #[inline]
            pub fn is_disconnect(&self) -> bool {
                *self == INPUTR::DISCONNECT
            }
        }
        #[doc = "Possible values of the field `PULL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PULLR {
            #[doc = "No pull."]
            DISABLED,
            #[doc = "Pulldown on pin."]
            PULLDOWN,
            #[doc = "Pullup on pin."]
            PULLUP,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl PULLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PULLR::DISABLED => 0,
                    PULLR::PULLDOWN => 0x01,
                    PULLR::PULLUP => 0x03,
                    PULLR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PULLR {
                match value {
                    0 => PULLR::DISABLED,
                    1 => PULLR::PULLDOWN,
                    3 => PULLR::PULLUP,
                    i => PULLR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == PULLR::DISABLED
            }
            #[doc = "Checks if the value of the field is `PULLDOWN`"]
            #[inline]
            pub fn is_pulldown(&self) -> bool {
                *self == PULLR::PULLDOWN
            }
            #[doc = "Checks if the value of the field is `PULLUP`"]
            #[inline]
            pub fn is_pullup(&self) -> bool {
                *self == PULLR::PULLUP
            }
        }
        #[doc = "Possible values of the field `DRIVE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DRIVER {
            #[doc = "Standard '0', Standard '1'."]
            S0S1,
            #[doc = "High '0', Standard '1'."]
            H0S1,
            #[doc = "Standard '0', High '1'."]
            S0H1,
            #[doc = "High '0', High '1'."]
            H0H1,
            #[doc = "Disconnected '0', Standard '1'."]
            D0S1,
            #[doc = "Disconnected '0', High '1'."]
            D0H1,
            #[doc = "Standard '0', Disconnected '1'."]
            S0D1,
            #[doc = "High '0', Disconnected '1'."]
            H0D1,
        }
        impl DRIVER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    DRIVER::S0S1 => 0,
                    DRIVER::H0S1 => 0x01,
                    DRIVER::S0H1 => 0x02,
                    DRIVER::H0H1 => 0x03,
                    DRIVER::D0S1 => 0x04,
                    DRIVER::D0H1 => 0x05,
                    DRIVER::S0D1 => 0x06,
                    DRIVER::H0D1 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> DRIVER {
                match value {
                    0 => DRIVER::S0S1,
                    1 => DRIVER::H0S1,
                    2 => DRIVER::S0H1,
                    3 => DRIVER::H0H1,
                    4 => DRIVER::D0S1,
                    5 => DRIVER::D0H1,
                    6 => DRIVER::S0D1,
                    7 => DRIVER::H0D1,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `S0S1`"]
            #[inline]
            pub fn is_s0s1(&self) -> bool {
                *self == DRIVER::S0S1
            }
            #[doc = "Checks if the value of the field is `H0S1`"]
            #[inline]
            pub fn is_h0s1(&self) -> bool {
                *self == DRIVER::H0S1
            }
            #[doc = "Checks if the value of the field is `S0H1`"]
            #[inline]
            pub fn is_s0h1(&self) -> bool {
                *self == DRIVER::S0H1
            }
            #[doc = "Checks if the value of the field is `H0H1`"]
            #[inline]
            pub fn is_h0h1(&self) -> bool {
                *self == DRIVER::H0H1
            }
            #[doc = "Checks if the value of the field is `D0S1`"]
            #[inline]
            pub fn is_d0s1(&self) -> bool {
                *self == DRIVER::D0S1
            }
            #[doc = "Checks if the value of the field is `D0H1`"]
            #[inline]
            pub fn is_d0h1(&self) -> bool {
                *self == DRIVER::D0H1
            }
            #[doc = "Checks if the value of the field is `S0D1`"]
            #[inline]
            pub fn is_s0d1(&self) -> bool {
                *self == DRIVER::S0D1
            }
            #[doc = "Checks if the value of the field is `H0D1`"]
            #[inline]
            pub fn is_h0d1(&self) -> bool {
                *self == DRIVER::H0D1
            }
        }
        #[doc = "Possible values of the field `SENSE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SENSER {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Wakeup on high level."]
            HIGH,
            #[doc = "Wakeup on low level."]
            LOW,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl SENSER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SENSER::DISABLED => 0,
                    SENSER::HIGH => 0x02,
                    SENSER::LOW => 0x03,
                    SENSER::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SENSER {
                match value {
                    0 => SENSER::DISABLED,
                    2 => SENSER::HIGH,
                    3 => SENSER::LOW,
                    i => SENSER::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SENSER::DISABLED
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == SENSER::HIGH
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == SENSER::LOW
            }
        }
        #[doc = "Values that can be written to the field `DIR`"]
        pub enum DIRW {
            #[doc = "Configure pin as an input pin."]
            INPUT,
            #[doc = "Configure pin as an output pin."]
            OUTPUT,
        }
        impl DIRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DIRW::INPUT => false,
                    DIRW::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DIRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Configure pin as an input pin."]
            #[inline]
            pub fn input(self) -> &'a mut W {
                self.variant(DIRW::INPUT)
            }
            #[doc = "Configure pin as an output pin."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(DIRW::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `INPUT`"]
        pub enum INPUTW {
            #[doc = "Connect input pin."]
            CONNECT,
            #[doc = "Disconnect input pin."]
            DISCONNECT,
        }
        impl INPUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    INPUTW::CONNECT => false,
                    INPUTW::DISCONNECT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _INPUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _INPUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: INPUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Connect input pin."]
            #[inline]
            pub fn connect(self) -> &'a mut W {
                self.variant(INPUTW::CONNECT)
            }
            #[doc = "Disconnect input pin."]
            #[inline]
            pub fn disconnect(self) -> &'a mut W {
                self.variant(INPUTW::DISCONNECT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PULL`"]
        pub enum PULLW {
            #[doc = "No pull."]
            DISABLED,
            #[doc = "Pulldown on pin."]
            PULLDOWN,
            #[doc = "Pullup on pin."]
            PULLUP,
        }
        impl PULLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PULLW::DISABLED => 0,
                    PULLW::PULLDOWN => 1,
                    PULLW::PULLUP => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PULLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PULLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PULLW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "No pull."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PULLW::DISABLED)
            }
            #[doc = "Pulldown on pin."]
            #[inline]
            pub fn pulldown(self) -> &'a mut W {
                self.variant(PULLW::PULLDOWN)
            }
            #[doc = "Pullup on pin."]
            #[inline]
            pub fn pullup(self) -> &'a mut W {
                self.variant(PULLW::PULLUP)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DRIVE`"]
        pub enum DRIVEW {
            #[doc = "Standard '0', Standard '1'."]
            S0S1,
            #[doc = "High '0', Standard '1'."]
            H0S1,
            #[doc = "Standard '0', High '1'."]
            S0H1,
            #[doc = "High '0', High '1'."]
            H0H1,
            #[doc = "Disconnected '0', Standard '1'."]
            D0S1,
            #[doc = "Disconnected '0', High '1'."]
            D0H1,
            #[doc = "Standard '0', Disconnected '1'."]
            S0D1,
            #[doc = "High '0', Disconnected '1'."]
            H0D1,
        }
        impl DRIVEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DRIVEW::S0S1 => 0,
                    DRIVEW::H0S1 => 1,
                    DRIVEW::S0H1 => 2,
                    DRIVEW::H0H1 => 3,
                    DRIVEW::D0S1 => 4,
                    DRIVEW::D0H1 => 5,
                    DRIVEW::S0D1 => 6,
                    DRIVEW::H0D1 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DRIVEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DRIVEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DRIVEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Standard '0', Standard '1'."]
            #[inline]
            pub fn s0s1(self) -> &'a mut W {
                self.variant(DRIVEW::S0S1)
            }
            #[doc = "High '0', Standard '1'."]
            #[inline]
            pub fn h0s1(self) -> &'a mut W {
                self.variant(DRIVEW::H0S1)
            }
            #[doc = "Standard '0', High '1'."]
            #[inline]
            pub fn s0h1(self) -> &'a mut W {
                self.variant(DRIVEW::S0H1)
            }
            #[doc = "High '0', High '1'."]
            #[inline]
            pub fn h0h1(self) -> &'a mut W {
                self.variant(DRIVEW::H0H1)
            }
            #[doc = "Disconnected '0', Standard '1'."]
            #[inline]
            pub fn d0s1(self) -> &'a mut W {
                self.variant(DRIVEW::D0S1)
            }
            #[doc = "Disconnected '0', High '1'."]
            #[inline]
            pub fn d0h1(self) -> &'a mut W {
                self.variant(DRIVEW::D0H1)
            }
            #[doc = "Standard '0', Disconnected '1'."]
            #[inline]
            pub fn s0d1(self) -> &'a mut W {
                self.variant(DRIVEW::S0D1)
            }
            #[doc = "High '0', Disconnected '1'."]
            #[inline]
            pub fn h0d1(self) -> &'a mut W {
                self.variant(DRIVEW::H0D1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SENSE`"]
        pub enum SENSEW {
            #[doc = "Disabled."]
            DISABLED,
            #[doc = "Wakeup on high level."]
            HIGH,
            #[doc = "Wakeup on low level."]
            LOW,
        }
        impl SENSEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SENSEW::DISABLED => 0,
                    SENSEW::HIGH => 2,
                    SENSEW::LOW => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SENSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SENSEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SENSEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SENSEW::DISABLED)
            }
            #[doc = "Wakeup on high level."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(SENSEW::HIGH)
            }
            #[doc = "Wakeup on low level."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(SENSEW::LOW)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Pin direction."]
            #[inline]
            pub fn dir(&self) -> DIRR {
                DIRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Connect or disconnect input path."]
            #[inline]
            pub fn input(&self) -> INPUTR {
                INPUTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 2:3 - Pull-up or -down configuration."]
            #[inline]
            pub fn pull(&self) -> PULLR {
                PULLR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:10 - Drive configuration."]
            #[inline]
            pub fn drive(&self) -> DRIVER {
                DRIVER::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 16:17 - Pin sensing mechanism."]
            #[inline]
            pub fn sense(&self) -> SENSER {
                SENSER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x02 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Pin direction."]
            #[inline]
            pub fn dir(&mut self) -> _DIRW {
                _DIRW { w: self }
            }
            #[doc = "Bit 1 - Connect or disconnect input path."]
            #[inline]
            pub fn input(&mut self) -> _INPUTW {
                _INPUTW { w: self }
            }
            #[doc = "Bits 2:3 - Pull-up or -down configuration."]
            #[inline]
            pub fn pull(&mut self) -> _PULLW {
                _PULLW { w: self }
            }
            #[doc = "Bits 8:10 - Drive configuration."]
            #[inline]
            pub fn drive(&mut self) -> _DRIVEW {
                _DRIVEW { w: self }
            }
            #[doc = "Bits 16:17 - Pin sensing mechanism."]
            #[inline]
            pub fn sense(&mut self) -> _SENSEW {
                _SENSEW { w: self }
            }
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "POWER"]
    pub POWER: POWER,
    #[doc = "CLOCK"]
    pub CLOCK: CLOCK,
    #[doc = "RADIO"]
    pub RADIO: RADIO,
    #[doc = "UART0"]
    pub UART0: UART0,
    #[doc = "SPI0"]
    pub SPI0: SPI0,
    #[doc = "TWI0"]
    pub TWI0: TWI0,
    #[doc = "SPI1"]
    pub SPI1: SPI1,
    #[doc = "TWI1"]
    pub TWI1: TWI1,
    #[doc = "SPIS1"]
    pub SPIS1: SPIS1,
    #[doc = "SPIM1"]
    pub SPIM1: SPIM1,
    #[doc = "GPIOTE"]
    pub GPIOTE: GPIOTE,
    #[doc = "ADC"]
    pub ADC: ADC,
    #[doc = "TIMER0"]
    pub TIMER0: TIMER0,
    #[doc = "TIMER1"]
    pub TIMER1: TIMER1,
    #[doc = "TIMER2"]
    pub TIMER2: TIMER2,
    #[doc = "RTC0"]
    pub RTC0: RTC0,
    #[doc = "TEMP"]
    pub TEMP: TEMP,
    #[doc = "RNG"]
    pub RNG: RNG,
    #[doc = "ECB"]
    pub ECB: ECB,
    #[doc = "AAR"]
    pub AAR: AAR,
    #[doc = "CCM"]
    pub CCM: CCM,
    #[doc = "WDT"]
    pub WDT: WDT,
    #[doc = "RTC1"]
    pub RTC1: RTC1,
    #[doc = "QDEC"]
    pub QDEC: QDEC,
    #[doc = "LPCOMP"]
    pub LPCOMP: LPCOMP,
    #[doc = "SWI"]
    pub SWI: SWI,
    #[doc = "NVMC"]
    pub NVMC: NVMC,
    #[doc = "PPI"]
    pub PPI: PPI,
    #[doc = "FICR"]
    pub FICR: FICR,
    #[doc = "UICR"]
    pub UICR: UICR,
    #[doc = "GPIO"]
    pub GPIO: GPIO,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| if unsafe { DEVICE_PERIPHERALS } {
            None
        } else {
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`"]
    pub unsafe fn steal() -> Self {
        debug_assert!(!DEVICE_PERIPHERALS);
        DEVICE_PERIPHERALS = true;
        Peripherals {
            POWER: POWER { _marker: PhantomData },
            CLOCK: CLOCK { _marker: PhantomData },
            RADIO: RADIO { _marker: PhantomData },
            UART0: UART0 { _marker: PhantomData },
            SPI0: SPI0 { _marker: PhantomData },
            TWI0: TWI0 { _marker: PhantomData },
            SPI1: SPI1 { _marker: PhantomData },
            TWI1: TWI1 { _marker: PhantomData },
            SPIS1: SPIS1 { _marker: PhantomData },
            SPIM1: SPIM1 { _marker: PhantomData },
            GPIOTE: GPIOTE { _marker: PhantomData },
            ADC: ADC { _marker: PhantomData },
            TIMER0: TIMER0 { _marker: PhantomData },
            TIMER1: TIMER1 { _marker: PhantomData },
            TIMER2: TIMER2 { _marker: PhantomData },
            RTC0: RTC0 { _marker: PhantomData },
            TEMP: TEMP { _marker: PhantomData },
            RNG: RNG { _marker: PhantomData },
            ECB: ECB { _marker: PhantomData },
            AAR: AAR { _marker: PhantomData },
            CCM: CCM { _marker: PhantomData },
            WDT: WDT { _marker: PhantomData },
            RTC1: RTC1 { _marker: PhantomData },
            QDEC: QDEC { _marker: PhantomData },
            LPCOMP: LPCOMP { _marker: PhantomData },
            SWI: SWI { _marker: PhantomData },
            NVMC: NVMC { _marker: PhantomData },
            PPI: PPI { _marker: PhantomData },
            FICR: FICR { _marker: PhantomData },
            UICR: UICR { _marker: PhantomData },
            GPIO: GPIO { _marker: PhantomData },
        }
    }
}
